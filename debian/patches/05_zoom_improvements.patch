--- gimp/app/display/gimpdisplayshell-render.c	(revision 23278)
+++ gimp/app/display/gimpdisplayshell-render.c	(revision 23378)
@@ -46,7 +46,18 @@
 #include "gimpdisplayshell-filter.h"
 #include "gimpdisplayshell-render.h"
 
+#define GIMP_DISPLAY_ZOOM_FAST      1 << 0  /* use the fastest possible code
+                                               path trading quality for speed
+                                             */
+#define GIMP_DISPLAY_ZOOM_PIXEL_AA  1 << 1  /* provide AA edges when zooming in
+                                               on the actual pixels (in current
+                                             code only enables it between 100%
+                                             and 200% zoom) */
 
+/* The default settings are debatable, and perhaps this should even somehow be
+ * configurable by the user. */
+static gint gimp_zoom_quality = GIMP_DISPLAY_ZOOM_PIXEL_AA;
+
 typedef struct _RenderInfo  RenderInfo;
 
 typedef void (* RenderFunc) (RenderInfo *info);
@@ -901,153 +912,119 @@
 }
 
 static inline void
-mix_pixels (gint          dx,
-            gint          dy,
-            const guchar *src0,
-            const guchar *src1,
-            const guchar *src2,
-            const guchar *src3,
-            guchar       *dst,
-            gint          components)
+box_filter (guint          left_weight,
+            guint          center_weight,
+            guint          right_weight,
+            guint          top_weight,
+            guint          middle_weight,
+            guint          bottom_weight,
+            guint          sum,  
+            const guchar **src,   /* the 9 surrounding source pixels */
+            guchar        *dest,
+            gint           bpp)
 {
-  /* FIXME: make sure this is dealing correctly with the alpha */
-#define DO_COMPONENT(iter) \
-  { \
-    gint m0, m1; \
-    m0        = ((256 - dx) * src0[iter] + dx * src1[iter]) >> 8; \
-    m1        = ((256 - dx) * src2[iter] + dx * src3[iter]) >> 8; \
-    dst[iter] = (((256 - dy) * m0 + dy * m1)) >> 8; \
-  }
-
-  /* Adjust the weights of the bilinear mixing in favour of the least important
-   * neighbours, this will both slightly blur the result as well as make sure
-   * that we rather display than throw away information from the original
-   * source data.
-   */
-  dx = (dx-128) * 0.50 + 128;
-  dy = (dy-128) * 0.50 + 128;
-
-  switch (components)
+  switch (bpp)
     {
       gint i;
+
+      guint a;
       case 4:
 #define ALPHA 3
-        DO_COMPONENT(ALPHA);
-        if (dst[ALPHA])
-          {
-            for (i= 0; i < ALPHA; i++)
-              {
-                gint m0 = ((256-dx) * src0[i] * src0[ALPHA] + dx * src1[i] * src1[ALPHA]) >> 8;
-                gint m1 = ((256-dx) * src2[i] * src2[ALPHA] + dx * src3[i] * src3[ALPHA]) >> 8;
-                gint r = (((256-dy) * m0 + dy * m1)/dst[ALPHA]) >> 8;
+        {
+          guint factors[9]={
+              (src[1][ALPHA] * top_weight)    >> 8,
+              (src[4][ALPHA] * middle_weight) >> 8,
+              (src[7][ALPHA] * bottom_weight) >> 8,
+              (src[2][ALPHA] * top_weight)    >> 8,
+              (src[5][ALPHA] * middle_weight) >> 8,
+              (src[8][ALPHA] * bottom_weight) >> 8,
+              (src[0][ALPHA] * top_weight)    >> 8,
+              (src[3][ALPHA] * middle_weight) >> 8,
+              (src[6][ALPHA] * bottom_weight) >> 8
+          };
 
-                if (r<0)
-                  dst[i]=0;
-                else if (r>255)
-                  dst[i]=255;
-                else
-                dst[i]=r;
-              }
-          }
+          a = (center_weight * (factors[0]+factors[1]+factors[2]) +
+               right_weight  * (factors[3]+factors[4]+factors[5]) +
+               left_weight   * (factors[6]+factors[7]+factors[8]));
+
+          dest[ALPHA] = a / sum;
+
+          for (i=0; i<=ALPHA; i++)
+            {
+              if (a)
+                {
+                  dest[i] = ((center_weight * (
+                            factors[0] * src[1][i] + 
+                            factors[1] * src[4][i] +  
+                            factors[2] * src[7][i]) + 
+
+                          right_weight * (
+                            factors[3] * src[2][i] +
+                            factors[4] * src[5][i] +
+                            factors[5] * src[8][i]) +
+
+                          left_weight * (
+                            factors[6] * src[0][i] +
+                            factors[7] * src[3][i] +
+                            factors[8] * src[6][i])
+
+                          ) / a) & 0xff;
+                }
+            }
+        }
 #undef ALPHA
         break;
-      case 3:
-        DO_COMPONENT (0);
-        DO_COMPONENT (1);
-        DO_COMPONENT (2);
-        break;
       case 2:
 #define ALPHA 1
-        DO_COMPONENT(ALPHA);
-        if (dst[ALPHA])
-          {
-            for (i= 0; i < ALPHA; i++)
-              {
-                gint m0 = ((256-dx) * src0[i] * src0[ALPHA] + dx * src1[i] * src1[ALPHA]) >> 8;
-                gint m1 = ((256-dx) * src2[i] * src2[ALPHA] + dx * src3[i] * src3[ALPHA]) >> 8;
-                gint r = (((256-dy) * m0 + dy * m1)/dst[ALPHA]) >> 8;
 
-                if (r<0)
-                  dst[i]=0;
-                else if (r>255)
-                  dst[i]=255;
-                else
-                dst[i]=r;
-              }
-          }
-#undef ALPHA
-        break;
-      case 1:
-        DO_COMPONENT (0);
-        break;
-    }
-}
+        /* NOTE: this is a copy and paste of the code above, the ALPHA changes
+         * the behavior in all needed ways. */
+        {
+          guint factors[9]={
+              (src[1][ALPHA] * top_weight)    >> 8,
+              (src[4][ALPHA] * middle_weight) >> 8,
+              (src[7][ALPHA] * bottom_weight) >> 8,
+              (src[2][ALPHA] * top_weight)    >> 8,
+              (src[5][ALPHA] * middle_weight) >> 8,
+              (src[8][ALPHA] * bottom_weight) >> 8,
+              (src[0][ALPHA] * top_weight)    >> 8,
+              (src[3][ALPHA] * middle_weight) >> 8,
+              (src[6][ALPHA] * bottom_weight) >> 8
+          };
 
+          a = (center_weight * (factors[0]+factors[1]+factors[2]) +
+               right_weight  * (factors[3]+factors[4]+factors[5]) +
+               left_weight   * (factors[6]+factors[7]+factors[8]));
 
-/* this function results in the correct data residing where dest points, if
- * scale_x and|or scale_y have a scale factor >100% the respective dimension
- * will use nearest neighbour instead of bilinear interpolation.
- */
-static inline void
-compute_sample (gdouble       scale_x,
-                gdouble       scale_y,
-                gint          dx,
-                gint          dy,
-                const guchar *src0,
-                const guchar *src1,
-                const guchar *src2,
-                const guchar *src3,
-                guchar       *dest,
-                gint          bpp)
-{
-  if (scale_x < 1.0 &&
-      scale_y < 1.0)
-    {
-      mix_pixels (dx >> 8,
-                  dy >> 8,
-                  src0, src1,
-                  src2, src3,
-                  dest,
-                  bpp);
-      dest += bpp;
-    }
-  else if (scale_x < 1.0 &&
-           scale_y >= 1.0)
-    {
-      mix_pixels (dx >> 8,
-                  0,
-                  src0, src1,
-                  src2, src3,
-                  dest,
-                  bpp);
-      dest += bpp;
-    }
-  else if (scale_x >= 1.0 &&
-           scale_y < 1.0)
-    {
-      mix_pixels (0,
-                  dy >> 8,
-                  src0, src1,
-                  src2, src3,
-                  dest,
-                  bpp);
-      dest += bpp;
-    }
-  else
-    {
-      const guchar *s = src0;
+          dest[ALPHA] = a / sum;
 
-      switch (bpp)
-        {
-          case 4:
-            *dest++ = *s++;
-          case 3:
-            *dest++ = *s++;
-          case 2:
-            *dest++ = *s++;
-          case 1:
-            *dest++ = *s++;
+          for (i=0; i<=ALPHA; i++)
+            {
+              if (a)
+                {
+                  dest[i] = ((center_weight * (
+                            factors[0] * src[1][i] + 
+                            factors[1] * src[4][i] +  
+                            factors[2] * src[7][i]) + 
+
+                          right_weight * (
+                            factors[3] * src[2][i] +
+                            factors[4] * src[5][i] +
+                            factors[5] * src[8][i]) +
+
+                          left_weight * (
+                            factors[6] * src[0][i] +
+                            factors[7] * src[3][i] +
+                            factors[8] * src[6][i])
+
+                          ) / a) & 0xff;
+                }
+            }
         }
+#undef ALPHA
+        break;
+      default:
+        g_warning ("bpp=%i not implemented as box filter", bpp);
     }
 }
 
@@ -1056,98 +1033,209 @@
 static const guchar * render_image_tile_fault_nearest  (RenderInfo *info);
 
 
+/*  012 <- this is the order of the numbered source tiles / pixels.
+ *  345    for the 3x3 neighbourhoods.
+ *  678
+ */
+
 /* function to render a horizontal line of view data */
 static const guchar *
 render_image_tile_fault (RenderInfo *info)
 {
-  Tile         *tile0;
-  Tile         *tile1;
-  Tile         *tile2;
-  Tile         *tile3;
+  Tile         *tile[9];
+  const guchar *src[9];
 
-  const guchar *src0;
-  const guchar *src1;
-  const guchar *src2;
-  const guchar *src3;
-
   guchar       *dest;
   gint          width;
-  gint          tilex0;   /* the current x-tile indice used for the left
+  gint          tilex0;   /* the current x-tile indice used for the middle
                              sample pair*/
   gint          tilex1;   /* the current x-tile indice used for the right
                              sample pair */
+  gint          tilexL;   /* the current x-tile indice used for the left
+                             sample pair */
   gint          xdelta;   /* fixed point amount to increment source x
                              coordinas for each horizontal integer destination
                              pixel increment */
   gint          bpp;
   glong         x;
 
+  gint          footprint_x;
+  gint          footprint_y;
+  guint         foosum;
 
+  guint         left_weight;
+  guint         center_weight;
+  guint         right_weight;
+
+  guint         top_weight;
+  guint         middle_weight;
+  guint         bottom_weight;
+ 
   /* dispatch to fast path functions on special conditions */
-  if ((info->scalex == 1.0 &&
-       info->scaley == 1.0) ||
-      (info->shell->scale_x > 1.0 &&
-       info->shell->scale_y > 1.0))
+  if ((gimp_zoom_quality & GIMP_DISPLAY_ZOOM_FAST) ||
+   
+      /* use nearest neighbour for exact levels */
+      (info->scalex == 1.0 &&
+       info->scaley == 1.0) 
+
+      /* or when we're larger than 1.0 and not using any AA */
+      || (info->shell->scale_x > 1.0 &&
+          info->shell->scale_y > 1.0 &&
+          (!(gimp_zoom_quality & GIMP_DISPLAY_ZOOM_PIXEL_AA))) 
+
+      /* or at any point when both scale factors are more than 200% */
+      || (info->shell->scale_x > 2.0 &&
+          info->shell->scale_y > 2.0 )
+      )
     {
-      /* use nearest neighbour interpolation when the desired scale
-       * is 1:1 with the available pyramid.
-       */
       return render_image_tile_fault_nearest (info);
     }
   else if (((info->src_y)     & ~(TILE_WIDTH -1)) ==
-           ((info->src_y + 1) & ~(TILE_WIDTH -1)))
+           ((info->src_y + 1) & ~(TILE_WIDTH -1)) &&
+           ((info->src_y)     & ~(TILE_WIDTH -1)) ==
+           ((info->src_y - 1) & ~(TILE_WIDTH -1))
+          )
     {
-      /* all the tiles needed are in a single row */
+      /* all the tiles needed are in a single row, use a tile iterator
+       * optimized for this case. */
       return render_image_tile_fault_one_row (info);
     }
 
-  tile0 = tile_manager_get_tile (info->src_tiles,
+  footprint_y = (1.0/info->scaley) * 256;
+  footprint_x = (1.0/info->scalex) * 256;
+  foosum = footprint_x * footprint_y;
+
+    {
+      gint dy = info->yfraction;
+      if (dy > footprint_y/2)
+        top_weight = 0;
+      else
+        top_weight = footprint_y/2 - dy;
+
+      if (0xff - dy > footprint_y/2) 
+        bottom_weight = 0;
+      else
+        bottom_weight = footprint_y/2 - (0xff - dy);
+
+      middle_weight = footprint_y - top_weight - bottom_weight;
+    }
+
+  tile[4] = tile_manager_get_tile (info->src_tiles,
                                  info->src_x, info->src_y, TRUE, FALSE);
-  tile2 = tile_manager_get_tile (info->src_tiles,
+  tile[7] = tile_manager_get_tile (info->src_tiles,
                                  info->src_x, info->src_y+1, TRUE, FALSE);
-  tile1 = tile_manager_get_tile (info->src_tiles,
+  tile[1] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x, info->src_y-1, TRUE, FALSE);
+
+  tile[5] = tile_manager_get_tile (info->src_tiles,
                                  info->src_x+1, info->src_y, TRUE, FALSE);
-  tile3 = tile_manager_get_tile (info->src_tiles,
+  tile[8] = tile_manager_get_tile (info->src_tiles,
                                  info->src_x+1, info->src_y+1, TRUE, FALSE);
+  tile[2] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x+1, info->src_y-1, TRUE, FALSE);
 
-  g_return_val_if_fail (tile0 != NULL, tile_buf);
+  tile[3] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x-1, info->src_y, TRUE, FALSE);
+  tile[6] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x-1, info->src_y+1, TRUE, FALSE);
+  tile[0] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x-1, info->src_y-1, TRUE, FALSE);
 
-  src0 = tile_data_pointer (tile0,
+  g_return_val_if_fail (tile[4] != NULL, tile_buf);
+
+  src[4] = tile_data_pointer (tile[4],
                             info->src_x % TILE_WIDTH,
                             info->src_y % TILE_HEIGHT);
-  if (tile1)
+  if (tile[5])
     {
-      src1 = tile_data_pointer (tile1,
+      src[5] = tile_data_pointer (tile[5],
                                 (info->src_x + 1)% TILE_WIDTH,
                                 info->src_y % TILE_HEIGHT);
     }
   else
     {
-      src1 = src0;  /* reusing existing pixel data */
+      src[5] = src[4];  /* reusing existing pixel data */
     }
 
-  if (tile2)
+  if (tile[7])
     {
-      src2 = tile_data_pointer (tile2,
+      src[7] = tile_data_pointer (tile[7],
                                 info->src_x % TILE_WIDTH,
                                 (info->src_y + 1) % TILE_HEIGHT);
     }
   else
     {
-      src2 = src0;  /* reusing existing pixel data */
+      src[7] = src[4];  /* reusing existing pixel data */
     }
 
-  if (tile3)
+  if (tile[1])
     {
-      src3 = tile_data_pointer (tile3,
+      src[1] = tile_data_pointer (tile[1],
+                                (info->src_x) % TILE_WIDTH,
+                                (info->src_y - 1) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[1] = src[4];  /* reusing existing pixel data */
+    }
+
+  if (tile[8])
+    {
+      src[8] = tile_data_pointer (tile[8],
                                 (info->src_x + 1) % TILE_WIDTH,
                                 (info->src_y + 1) % TILE_HEIGHT);
     }
   else
     {
-      src3 = src1;  /* reusing existing pixel data */
+      src[8] = src[5];  /* reusing existing pixel data */
     }
 
+
+
+  if (tile[0])
+    {
+      src[0] = tile_data_pointer (tile[0],
+                                (info->src_x - 1) % TILE_WIDTH,
+                                (info->src_y - 1) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[0] = src[1];  /* reusing existing pixel data */
+    }
+
+  if (tile[2])
+    {
+      src[2] = tile_data_pointer (tile[2],
+                                (info->src_x + 1) % TILE_WIDTH,
+                                (info->src_y - 1) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[2] = src[4];  /* reusing existing pixel data */
+    }
+
+  if (tile[3])
+    {
+      src[3] = tile_data_pointer (tile[3],
+                                (info->src_x - 1) % TILE_WIDTH,
+                                (info->src_y) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[3] = src[4];  /* reusing existing pixel data */
+    }
+
+  if (tile[6])
+    {
+      src[6] = tile_data_pointer (tile[6],
+                                (info->src_x - 1) % TILE_WIDTH,
+                                (info->src_y + 1) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[6] = src[7];  /* reusing existing pixel data */
+    }
+
   bpp    = tile_manager_bpp (info->src_tiles);
   dest   = tile_buf;
 
@@ -1157,6 +1245,7 @@
 
   tilex0 = info->src_x / TILE_WIDTH;
   tilex1 = (info->src_x + 1) / TILE_WIDTH;
+  tilexL = (info->src_x - 1) / TILE_WIDTH;
 
   xdelta = info->xdelta;
 
@@ -1165,14 +1254,24 @@
       gint  src_x = x >> 16;
       gint  skipped;
 
-      compute_sample (info->shell->scale_x,
-                      info->shell->scale_y,
-                      (x >> 8) & 0xff,
-                      info->yfraction,
-                      src0, src1,
-                      src2, src3,
-                      dest,
-                      bpp);
+      {
+        gint  dx = (x >> 8) & 0xff;
+        if (dx > footprint_x/2)
+          left_weight = 0;
+        else
+          left_weight = footprint_x/2 - dx;
+
+        if (0xff - dx > footprint_x/2)
+          right_weight = 0;
+        else
+          right_weight = footprint_x/2 - (0xff - dx);
+
+        center_weight = footprint_x - left_weight - right_weight;
+
+      box_filter (left_weight, center_weight, right_weight,
+                  top_weight, middle_weight, bottom_weight, foosum,
+                  src, dest, bpp);
+      }
       dest += bpp;
 
       x += xdelta;
@@ -1185,96 +1284,211 @@
            * buffer, make sure the src pointers (and their backing tiles) are
            * correct
            */ 
-          src0 += skipped * bpp;
-          src1 += skipped * bpp;
-          src2 += skipped * bpp;
-          src3 += skipped * bpp;
 
+          if (src[0] != src[1])
+            {
+              src[0] += skipped * bpp;
+            }
+          else
+            {
+              tilexL=-1;  /* this forces a refetch of the left most source
+                             samples */
+            }
+            
+          if (src[3] != src[4])
+            {
+              src[3] += skipped * bpp;
+            }
+          else
+            {
+              tilexL=-1;  /* this forces a refetch of the left most source
+                             samples */
+            }
+
+          if (src[6] != src[7])
+            {
+              src[6] += skipped * bpp;
+            }
+          else
+            {
+              tilexL=-1;  /* this forces a refetch of the left most source
+                             samples */
+            }
+
+          src[1] += skipped * bpp;
+          src[4] += skipped * bpp;
+          src[7] += skipped * bpp;
+
+          src[5] += skipped * bpp;
+          src[8] += skipped * bpp;
+          src[2] += skipped * bpp;
+
+
           src_x += skipped;
 
           if ((src_x / TILE_WIDTH) != tilex0)
             {
-              tile_release (tile0, FALSE);
+              tile_release (tile[4], FALSE);
 
-              if (tile2)
-                tile_release (tile2, FALSE);
+              if (tile[7])
+                tile_release (tile[7], FALSE);
+              if (tile[1])
+                tile_release (tile[1], FALSE);
 
               tilex0 += 1;
 
-              tile0 = tile_manager_get_tile (info->src_tiles,
+              tile[4] = tile_manager_get_tile (info->src_tiles,
                                              src_x, info->src_y, TRUE, FALSE);
-              tile2 = tile_manager_get_tile (info->src_tiles,
+              tile[7] = tile_manager_get_tile (info->src_tiles,
                                              src_x, info->src_y+1, TRUE, FALSE);
-              if (!tile0)
+              tile[1] = tile_manager_get_tile (info->src_tiles,
+                                             src_x, info->src_y-1, TRUE, FALSE);
+              if (!tile[4])
                 goto done;
 
-              if (!tile2)
-                goto done;
-
-              src0 = tile_data_pointer (tile0,
+              src[4] = tile_data_pointer (tile[4],
                                         src_x % TILE_WIDTH,
                                         info->src_y % TILE_HEIGHT);
-              src2 = tile_data_pointer (tile2,
-                                        src_x % TILE_WIDTH,
-                                        (info->src_y + 1)% TILE_HEIGHT);
+              if (!tile[7])
+                {
+                  src[7] = src[4];
+                }
+              else
+                {
+                  src[7] = tile_data_pointer (tile[7],
+                                            (src_x) % TILE_WIDTH,
+                                            (info->src_y + 1) % TILE_HEIGHT);
+                }
+              if (!tile[1])
+                {
+                  src[1] = src[4];
+                }
+              else
+                {
+                  src[1] = tile_data_pointer (tile[1],
+                                            src_x % TILE_WIDTH,
+                                            (info->src_y - 1)% TILE_HEIGHT);
+                }
             }
 
           if (((src_x+1) / TILE_WIDTH) != tilex1)
             {
-              if (tile1)
-                tile_release (tile1, FALSE);
+              if (tile[5])
+                tile_release (tile[5], FALSE);
+              if (tile[8])
+                tile_release (tile[8], FALSE);
+              if (tile[2])
+                tile_release (tile[2], FALSE);
 
-              if (tile3)
-                tile_release (tile3, FALSE);
-
               tilex1 += 1;
 
-              tile1 = tile_manager_get_tile (info->src_tiles,
+              tile[5] = tile_manager_get_tile (info->src_tiles,
                                              src_x + 1, info->src_y,
                                              TRUE, FALSE);
-              tile3 = tile_manager_get_tile (info->src_tiles,
+              tile[8] = tile_manager_get_tile (info->src_tiles,
                                              src_x + 1, info->src_y + 1,
                                              TRUE, FALSE);
+              tile[2] = tile_manager_get_tile (info->src_tiles,
+                                             src_x + 1, info->src_y - 1,
+                                             TRUE, FALSE);
 
-              if (!tile1)
+              if (!tile[5])
                 {
-                  src1 = src0;
+                  src[5] = src[4];
                 }
               else
                 {
-                  src1 = tile_data_pointer (tile1,
+                  src[5] = tile_data_pointer (tile[5],
                                             (src_x + 1) % TILE_WIDTH,
                                             info->src_y % TILE_HEIGHT);
                 }
 
-              if (!tile3)
+              if (!tile[8])
                 {
-                  src3 = src2;
+                  src[8] = src[7];
                 }
               else
                 {
-                  src3 = tile_data_pointer (tile3,
+                  src[8] = tile_data_pointer (tile[8],
                                             (src_x + 1) % TILE_WIDTH,
                                             (info->src_y+1) % TILE_HEIGHT);
                 }
+
+              if (!tile[2])
+                {
+                  src[2] = src[1];
+                }
+              else
+                {
+                  src[2] = tile_data_pointer (tile[2],
+                                            (src_x + 1) % TILE_WIDTH,
+                                            (info->src_y-1) % TILE_HEIGHT);
+                }
             }
+
+          if (((src_x-1) / TILE_WIDTH) != tilexL)
+            {
+              if (tile[0])
+                tile_release (tile[0], FALSE);
+              if (tile[3])
+                tile_release (tile[3], FALSE);
+              if (tile[6])
+                tile_release (tile[6], FALSE);
+
+              tilexL += 1;
+
+              tile[0] = tile_manager_get_tile (info->src_tiles,
+                                             src_x - 1, info->src_y - 1,
+                                             TRUE, FALSE);
+              tile[3] = tile_manager_get_tile (info->src_tiles,
+                                             src_x - 1, info->src_y,
+                                             TRUE, FALSE);
+              tile[6] = tile_manager_get_tile (info->src_tiles,
+                                             src_x - 1, info->src_y + 1,
+                                             TRUE, FALSE);
+
+              if (!tile[3])
+                {
+                  src[3] = src[4];
+                }
+              else
+                {
+                  src[3] = tile_data_pointer (tile[3],
+                                            (src_x - 1) % TILE_WIDTH,
+                                            info->src_y % TILE_HEIGHT);
+                }
+
+              if (!tile[6])
+                {
+                  src[6] = src[7];
+                }
+              else
+                {
+                  src[6] = tile_data_pointer (tile[6],
+                                            (src_x - 1) % TILE_WIDTH,
+                                            (info->src_y+1) % TILE_HEIGHT);
+                }
+
+              if (!tile[0])
+                {
+                  src[0] = src[1];
+                }
+              else
+                {
+                  src[0] = tile_data_pointer (tile[0],
+                                            (src_x - 1) % TILE_WIDTH,
+                                            (info->src_y-1) % TILE_HEIGHT);
+                }
+            }
         }
     }
   while (--width);
 
 done:
-  if (tile0)
-    tile_release (tile0, FALSE);
+  for (x=0; x<9; x++)
+    if (tile[x])
+      tile_release (tile[x], FALSE);
 
-  if (tile2)
-    tile_release (tile2, FALSE);
-
-  if (tile1)
-    tile_release (tile1, FALSE);
-
-  if (tile3)
-    tile_release (tile3, FALSE);
-
   return tile_buf;
 }
 
@@ -1304,7 +1518,6 @@
   dest  = tile_buf;
 
   x     = info->xstart;
-  
 
   width = info->w;
 
@@ -1360,87 +1573,152 @@
   return tile_buf;
 }
 
-
-/* optimized renderer for a line of view data that assumes source data
- * to lie in the same row of tiles.
- */
 static const guchar *
 render_image_tile_fault_one_row (RenderInfo *info)
 {
-  Tile         *current_tile;
-  Tile         *next_tile=NULL;  /* only used when crossing over right edge
-                                    of tiles */
-  const guchar *src0;
-  const guchar *src1;
-  const guchar *src2;
-  const guchar *src3;
+  /* NOTE: there are some additional overhead that can be factored out
+   * in the tile administration of this fast path
+   */ 
+
+  Tile         *tile[3];
+
+  const guchar *src[9];
+
   guchar       *dest;
   gint          width;
-  gint          tilex0;
-  gint          tilex1;
-  gint          xdelta;
+  gint          tilex0;   /* the current x-tile indice used for the middle
+                             sample pair*/
+  gint          tilex1;   /* the current x-tile indice used for the right
+                             sample pair */
+  gint          tilexL;   /* the current x-tile indice used for the left
+                             sample pair */
+  gint          xdelta;   /* fixed point amount to increment source x
+                             coordinas for each horizontal integer destination
+                             pixel increment */
   gint          bpp;
   glong         x;
 
-  current_tile = tile_manager_get_tile (info->src_tiles,
-                                        info->src_x, info->src_y, TRUE, FALSE);
+  guint         footprint_x;
+  guint         footprint_y;
+  guint         foosum;
 
-  g_return_val_if_fail (current_tile != NULL, tile_buf);
+  guint         left_weight;
+  guint         center_weight;
+  guint         right_weight;
 
+  guint         top_weight;
+  guint         middle_weight;
+  guint         bottom_weight;
+  
+  footprint_y = (1.0/info->scaley) * 256;
+  footprint_x = (1.0/info->scalex) * 256;
+  foosum      = footprint_x * footprint_y;
 
-  src0 = tile_data_pointer (current_tile,
+    {
+      gint dy = info->yfraction;
+      if (dy > footprint_y/2)
+        top_weight = 0;
+      else
+        top_weight = footprint_y/2 - dy;
+
+      if (0xff - dy > footprint_y/2)
+        bottom_weight = 0;
+      else
+        bottom_weight = footprint_y/2 - (0xff - dy);
+
+      middle_weight = footprint_y - top_weight - bottom_weight;
+    }
+
+  tile[0] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x, info->src_y, TRUE, FALSE);
+
+  tile[1] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x+1, info->src_y, TRUE, FALSE);
+
+  tile[2] = tile_manager_get_tile (info->src_tiles,
+                                 info->src_x-1, info->src_y, TRUE, FALSE);
+
+  g_return_val_if_fail (tile[0] != NULL, tile_buf);
+
+  src[4] = tile_data_pointer (tile[0],
                             info->src_x % TILE_WIDTH,
                             info->src_y % TILE_HEIGHT);
-  src2 = tile_data_pointer (current_tile,
+  src[7] = tile_data_pointer (tile[0],
                             info->src_x % TILE_WIDTH,
                             (info->src_y + 1) % TILE_HEIGHT);
+  if (tile[1])
+    {
+      src[5] = tile_data_pointer (tile[1],
+                                (info->src_x + 1)% TILE_WIDTH,
+                                info->src_y % TILE_HEIGHT);
+      src[8] = tile_data_pointer (tile[1],
+                                (info->src_x + 1) % TILE_WIDTH,
+                                (info->src_y + 1) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[5] = src[4];  /* reusing existing pixel data */
+      src[8] = src[5];  /* reusing existing pixel data */
+    }
 
-  if ((info->src_x & ~(TILE_WIDTH -1)) !=
-      ((info->src_x + 1) & ~(TILE_WIDTH -1))) /* need two tiles */
+  if (tile[0])
     {
-      next_tile = tile_manager_get_tile (info->src_tiles,
-                                         info->src_x+1, info->src_y,
-                                         TRUE, FALSE);
+      src[1] = tile_data_pointer (tile[0],
+                                (info->src_x) % TILE_WIDTH,
+                                (info->src_y - 1) % TILE_HEIGHT);
     }
+  else
+    {
+      src[1] = src[4];  /* reusing existing pixel data */
+    }
 
-  if (next_tile != NULL)  
+  if (tile[2])
     {
-      src1 = tile_data_pointer (next_tile,
-                                (info->src_x + 1)% TILE_WIDTH,
-                                info->src_y % TILE_HEIGHT);
-      src3 = tile_data_pointer (next_tile,
+      src[0] = tile_data_pointer (tile[2],
+                                (info->src_x - 1) % TILE_WIDTH,
+                                (info->src_y - 1) % TILE_HEIGHT);
+    }
+  else
+    {
+      src[0] = src[1];  /* reusing existing pixel data */
+    }
+
+  if (tile[1])
+    {
+      src[2] = tile_data_pointer (tile[1],
                                 (info->src_x + 1) % TILE_WIDTH,
-                                (info->src_y + 1) % TILE_HEIGHT);
+                                (info->src_y - 1) % TILE_HEIGHT);
     }
-  else if (((info->src_x & ~(TILE_WIDTH -1)) ==
-           ((info->src_x + 1) & ~(TILE_WIDTH -1))))
-    /* the common case get all data from the same tile */
+  else
     {
-      src1 = tile_data_pointer (current_tile,
-                                (info->src_x + 1)% TILE_WIDTH,
-                                info->src_y % TILE_HEIGHT);
-      src3 = tile_data_pointer (current_tile,
-                                (info->src_x + 1) % TILE_WIDTH,
+      src[2] = src[4];  /* reusing existing pixel data */
+    }
+
+  if (tile[2])
+    {
+      src[3] = tile_data_pointer (tile[2],
+                                (info->src_x - 1) % TILE_WIDTH,
+                                (info->src_y) % TILE_HEIGHT);
+      src[6] = tile_data_pointer (tile[2],
+                                (info->src_x - 1) % TILE_WIDTH,
                                 (info->src_y + 1) % TILE_HEIGHT);
     }
   else
     {
-      /* we should have gotten the rightmost pair of samples from a
-       * separate tile that we couldn't retrieve
-       */
-      src1 = src0;
-      src3 = src2;
+      src[3] = src[4];  /* reusing existing pixel data */
+      src[6] = src[7];  /* reusing existing pixel data */
     }
 
-  bpp   = tile_manager_bpp (info->src_tiles);
-  dest  = tile_buf;
+  bpp    = tile_manager_bpp (info->src_tiles);
+  dest   = tile_buf;
 
-  x     = info->xstart;
+  x      = info->xstart;
 
-  width = info->w;
+  width  = info->w;
 
-  tilex0= info->src_x / TILE_WIDTH;
-  tilex1= (info->src_x+1)/ TILE_WIDTH;
+  tilex0 = info->src_x / TILE_WIDTH;
+  tilex1 = (info->src_x + 1) / TILE_WIDTH;
+  tilexL = (info->src_x - 1) / TILE_WIDTH;
 
   xdelta = info->xdelta;
 
@@ -1449,104 +1727,169 @@
       gint  src_x = x >> 16;
       gint  skipped;
 
-      compute_sample (info->shell->scale_x,
-                      info->shell->scale_y,
-                      (x >> 8) & 0xff,
-                      info->yfraction,
-                      src0, src1,
-                      src2, src3,
-                      dest,
-                      bpp);
+      {
+        gint  dx = (x >> 8) & 0xff;
+        if (dx > footprint_x/2)
+          left_weight = 0;
+        else
+          left_weight = footprint_x/2 - dx;
+
+        if (0xff - dx > footprint_x/2)
+          right_weight = 0;
+        else
+          right_weight = footprint_x/2 - (0xff - dx);
+
+        center_weight = footprint_x - left_weight - right_weight;
+
+        box_filter (left_weight, center_weight, right_weight,
+                    top_weight, middle_weight, bottom_weight, foosum,
+                    src, dest, bpp);
+      }
       dest += bpp;
 
-      if (next_tile)  /* we should only need two tiles for one of
-                         the rounds when generating data
-                       */
-        {
-          tile_release (next_tile, FALSE);
-          next_tile = NULL;
-        }
-
       x += xdelta;
 
       skipped = (x >> 16) - src_x;
 
       if (skipped)
         {
-          src0 += skipped * bpp;
-          src1 += skipped * bpp;
-          src2 += skipped * bpp;
-          src3 += skipped * bpp;
+          /* if we changed integer source pixel coordinates in the source
+           * buffer, make sure the src pointers (and their backing tiles) are
+           * correct
+           */ 
 
+          if (src[0] != src[1])
+            {
+              src[0] += skipped * bpp;
+            }
+          else
+            {
+              tilexL=-1;  /* this forces a refetch of the left most source
+                             samples */
+            }
+            
+          if (src[3] != src[4])
+            {
+              src[3] += skipped * bpp;
+            }
+          else
+            {
+              tilexL=-1;  /* this forces a refetch of the left most source
+                             samples */
+            }
+
+          if (src[6] != src[7])
+            {
+              src[6] += skipped * bpp;
+            }
+          else
+            {
+              tilexL=-1;  /* this forces a refetch of the left most source
+                             samples */
+            }
+
+          src[1] += skipped * bpp;
+          src[4] += skipped * bpp;
+          src[7] += skipped * bpp;
+
+          src[5] += skipped * bpp;
+          src[8] += skipped * bpp;
+          src[2] += skipped * bpp;
+
+
           src_x += skipped;
 
-          /* check if src0 or src2 was pushed out of the
-           * current tile
-           */
           if ((src_x / TILE_WIDTH) != tilex0)
             {
-              tile_release (current_tile, FALSE);
+              tile_release (tile[0], FALSE);
+
               tilex0 += 1;
 
-              if (next_tile)
-                { /* reuse tile1 fetched for src0 and src2 if available */
-                  current_tile=next_tile;
-                  next_tile=NULL;
-                }
-              else
-                {
-                  current_tile = tile_manager_get_tile (info->src_tiles,
-                                                        src_x, info->src_y,
-                                                        TRUE, FALSE);
-                }
-
-              if (!current_tile)
+              tile[0] = tile_manager_get_tile (info->src_tiles,
+                                             src_x, info->src_y, TRUE, FALSE);
+              if (!tile[0])
                 goto done;
 
-              src0 = tile_data_pointer (current_tile,
+              src[4] = tile_data_pointer (tile[0],
                                         src_x % TILE_WIDTH,
                                         info->src_y % TILE_HEIGHT);
-              src2 = tile_data_pointer (current_tile,
+              src[7] = tile_data_pointer (tile[0],
+                                        (src_x) % TILE_WIDTH,
+                                        (info->src_y + 1) % TILE_HEIGHT);
+              src[1] = tile_data_pointer (tile[0],
                                         src_x % TILE_WIDTH,
-                                        (info->src_y + 1)% TILE_HEIGHT);
+                                        (info->src_y - 1)% TILE_HEIGHT);
             }
 
           if (((src_x+1) / TILE_WIDTH) != tilex1)
             {
-              if (next_tile)
-                tile_release (next_tile, FALSE);
+              if (tile[1])
+                tile_release (tile[1], FALSE);
 
               tilex1 += 1;
 
-              next_tile = tile_manager_get_tile (info->src_tiles,
+              tile[1] = tile_manager_get_tile (info->src_tiles,
                                              src_x + 1, info->src_y,
                                              TRUE, FALSE);
-              if (!next_tile)
-                { /* use the data pointers from src0 and src2 when
-                     we're outside the defined region */
-                  src1 = src0;
-                  src3 = src2;
+
+              if (!tile[1])
+                {
+                  src[5] = src[4];
+                  src[8] = src[7];
+                  src[2] = src[1];
                 }
               else
                 {
-                  src1 = tile_data_pointer (next_tile,
+                  src[5] = tile_data_pointer (tile[1],
                                             (src_x + 1) % TILE_WIDTH,
                                             info->src_y % TILE_HEIGHT);
-                  src3 = tile_data_pointer (next_tile,
+                  src[8] = tile_data_pointer (tile[1],
                                             (src_x + 1) % TILE_WIDTH,
                                             (info->src_y+1) % TILE_HEIGHT);
+                  src[2] = tile_data_pointer (tile[1],
+                                            (src_x + 1) % TILE_WIDTH,
+                                            (info->src_y-1) % TILE_HEIGHT);
                 }
             }
+
+          if (((src_x-1) / TILE_WIDTH) != tilexL)
+            {
+              if (tile[2])
+                tile_release (tile[2], FALSE);
+
+              tilexL += 1;
+
+              tile[2] = tile_manager_get_tile (info->src_tiles,
+                                             src_x - 1, info->src_y,
+                                             TRUE, FALSE);
+
+              if (!tile[2])
+                {
+                  src[3] = src[4];
+                  src[6] = src[7];
+                  src[0] = src[1];
+                }
+              else
+                {
+                  src[3] = tile_data_pointer (tile[2],
+                                            (src_x - 1) % TILE_WIDTH,
+                                            info->src_y % TILE_HEIGHT);
+                  src[6] = tile_data_pointer (tile[2],
+                                            (src_x - 1) % TILE_WIDTH,
+                                            (info->src_y+1) % TILE_HEIGHT);
+                  src[0] = tile_data_pointer (tile[2],
+                                            (src_x - 1) % TILE_WIDTH,
+                                            (info->src_y-1) % TILE_HEIGHT);
+                }
+            }
         }
     }
   while (--width);
 
 done:
-  if (current_tile!=NULL)
-    tile_release (current_tile, FALSE);
+  for (x=0; x<3; x++)
+    if (tile[x])
+      tile_release (tile[x], FALSE);
 
-  if (next_tile!=NULL)
-    tile_release (next_tile, FALSE);
-
   return tile_buf;
 }

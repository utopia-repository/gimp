diff -Naur gimp-2.2.15/app/xcf/xcf-load.c gimp-2.2.13/app/xcf/xcf-load.c
--- gimp-2.2.15/app/xcf/xcf-load.c	2007-04-17 23:09:51.000000000 +0200
+++ gimp-2.2.13/app/xcf/xcf-load.c	2007-07-06 10:19:21.000000000 +0200
@@ -121,6 +121,7 @@
 {
   GimpImage    *gimage;
   GimpLayer    *layer;
+  GimpLayer    *last_layer = NULL;
   GimpChannel  *channel;
   GimpParasite *parasite;
   guint32       saved_pos;
@@ -291,7 +294,7 @@
 
   while (TRUE)
     {
-      if (!xcf_load_prop (info, &prop_type, &prop_size))
+      if (! xcf_load_prop (info, &prop_type, &prop_size))
         return FALSE;
 
       switch (prop_type)
@@ -370,8 +373,10 @@
             nguides = prop_size / (4 + 1);
             for (i = 0; i < nguides; i++)
               {
-                info->cp += xcf_read_int32 (info->fp, (guint32 *) &position, 1);
-                info->cp += xcf_read_int8 (info->fp, (guint8 *) &orientation, 1);
+                info->cp += xcf_read_int32 (info->fp,
+                                            (guint32 *) &position, 1);
+                info->cp += xcf_read_int8 (info->fp,
+                                           (guint8 *) &orientation, 1);
 
                 /*  skip -1 guides from old XCFs  */
                 if (position < 0)
@@ -581,7 +586,7 @@
 
   while (TRUE)
     {
-      if (!xcf_load_prop (info, &prop_type, &prop_size))
+      if (! xcf_load_prop (info, &prop_type, &prop_size))
         return FALSE;
 
       switch (prop_type)
@@ -678,6 +683,7 @@
                 gimp_item_parasite_attach (GIMP_ITEM (layer), p);
                 gimp_parasite_free (p);
               }
+
             if (info->cp - base != prop_size)
               g_message ("Error while loading a layer's parasites");
           }
@@ -724,7 +730,7 @@
 
   while (TRUE)
     {
-      if (!xcf_load_prop (info, &prop_type, &prop_size))
+      if (! xcf_load_prop (info, &prop_type, &prop_size))
         return FALSE;
 
       switch (prop_type)
@@ -819,6 +825,7 @@
                 gimp_item_parasite_attach (GIMP_ITEM (*channel), p);
                 gimp_parasite_free (p);
               }
+
             if (info->cp - base != prop_size)
               g_message ("Error while loading a channel's parasites");
           }
@@ -856,8 +863,16 @@
                PropType *prop_type,
                guint32  *prop_size)
 {
-  info->cp += xcf_read_int32 (info->fp, (guint32 *) prop_type, 1);
-  info->cp += xcf_read_int32 (info->fp, (guint32 *) prop_size, 1);
+  if (G_UNLIKELY (xcf_read_int32 (info->fp, (guint32 *) prop_type, 1) != 4))
+    return FALSE;
+
+  info->cp += 4;
+
+  if (G_UNLIKELY (xcf_read_int32 (info->fp, (guint32 *) prop_size, 1) != 4))
+    return FALSE;
+
+  info->cp += 4;
+
   return TRUE;
 }
 
diff -Naur gimp-2.2.15/app/xcf/xcf-read.c gimp-2.2.13/app/xcf/xcf-read.c
--- gimp-2.2.15/app/xcf/xcf-read.c	2007-04-17 23:09:51.000000000 +0200
+++ gimp-2.2.13/app/xcf/xcf-read.c	2007-07-06 10:19:21.000000000 +0200
@@ -34,11 +34,11 @@
 		guint32 *data,
 		gint     count)
 {
-  guint total = count;
+  guint total = 0;
 
   if (count > 0)
     {
-      xcf_read_int8 (fp, (guint8 *) data, count * 4);
+      total += xcf_read_int8 (fp, (guint8 *) data, count * 4);
 
       while (count--)
         {
@@ -47,7 +47,7 @@
         }
     }
 
-  return total * 4;
+  return total;
 }
 
 guint
@@ -63,15 +63,17 @@
 	       guint8 *data,
 	       gint    count)
 {
-  guint total = count;
+  guint total = 0;
 
   while (count > 0)
     {
-      gint  bytes = fread ((char *) data, sizeof (char), count, fp);
+      gint bytes = fread ((char *) data, sizeof (char), count, fp);
 
       if (bytes <= 0) /* something bad happened */
         break;
 
+      total += bytes;
+
       count -= bytes;
       data += bytes;
     }
diff -Naur gimp-2.2.15/plug-ins/bmp/bmpread.c gimp-2.2.13/plug-ins/bmp/bmpread.c
--- gimp-2.2.15/plug-ins/bmp/bmpread.c	2007-04-17 23:11:13.000000000 +0200
+++ gimp-2.2.13/plug-ins/bmp/bmpread.c	2007-07-06 10:19:21.000000000 +0200
@@ -390,6 +390,9 @@
 			Grey,
 			masks);
 
+  if (image_ID < 0)
+    return -1;
+
   if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)
     {
       /* Fixed up from scott@asofyet's changes last year, njl195 */
@@ -482,10 +485,20 @@
       break;
 
     default:
-      g_message (_("Unrecognized or invalid BMP compression format."));
+      g_message (_("Unsupported or invalid bitdepth."));
       return -1;
     }
 
+  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))
+    {
+      g_message (_("Unsupported or invalid image width: %d"), width);
+      return -1;
+    }
+  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))
+    {
+      g_message (_("Unsupported or invalid image height: %d"), height);
+      return -1;
+    }
   image = gimp_image_new (width, height, base_type);
   layer = gimp_layer_new (image, _("Background"),
                           width, height,
diff -Naur gimp-2.2.15/plug-ins/common/dicom.c gimp-2.2.13/plug-ins/common/dicom.c
--- gimp-2.2.15/plug-ins/common/dicom.c	2007-04-17 23:11:23.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/dicom.c	2007-07-06 10:19:22.000000000 +0200
@@ -42,7 +42,7 @@
 /* Declare local data types */
 typedef struct _DicomInfo
 {
-  gint       width, height;	 /* The size of the image                  */
+  guint      width, height;	 /* The size of the image                  */
   gint       maxval;		 /* For 16 and 24 bit image files, the max
 				    value which we need to normalize to    */
   gint       samples_per_pixel;  /* Number of image planes (0 for pbm)     */
@@ -275,8 +275,8 @@
   gchar          *temp;
   gchar           buf[500];    /* buffer for random things like scanning */
   DicomInfo      *dicominfo;
-  gint            width             = 0;
-  gint            height            = 0;
+  guint           width             = 0;
+  guint           height            = 0;
   gint            samples_per_pixel = 0;
   gint            bpp               = 0;
   guint8         *pix_buf           = NULL;
@@ -406,6 +406,15 @@
       if (tag == 0xFFFEE000)
 	continue;
 
+      /* Even for pixel data, we don't handle very large element
+         lengths */
+
+      if (element_length >= (G_MAXUINT - 6))
+        {
+          g_error ("'%s' seems to have an incorrect value field length.",
+                     gimp_filename_to_utf8 (filename));
+        }
+
       /* Read contents. Allocate a bit more to make room for casts to int
        below. */
       value = g_new0 (guint8, element_length + 4);
@@ -466,6 +475,12 @@
         }
     }
 
+  if ((width > GIMP_MAX_IMAGE_SIZE) || (height > GIMP_MAX_IMAGE_SIZE))
+    {
+      g_error ("'%s' has a larger image size than GIMP can handle.",
+                 gimp_filename_to_utf8 (filename));
+    }
+
   dicominfo->width  = width;
   dicominfo->height = height;
   dicominfo->bpp    = bpp;
diff -Naur gimp-2.2.15/plug-ins/common/pcx.c gimp-2.2.13/plug-ins/common/pcx.c
--- gimp-2.2.15/plug-ins/common/pcx.c	2007-04-17 23:11:24.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/pcx.c	2007-07-06 10:19:22.000000000 +0200
@@ -328,6 +328,23 @@
   width = qtohs (pcx_header.x2) - offset_x + 1;
   height = qtohs (pcx_header.y2) - offset_y + 1;
 
+  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))
+    {
+      g_message (_("Unsupported or invalid image width: %d"), width);
+      return -1;
+    }
+  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))
+    {
+      g_message (_("Unsupported or invalid image height: %d"), height);
+      return -1;
+    }
+  if (qtohs (pcx_header.bytesperline) <= 0)
+    {
+      g_message (_("Invalid number of bytes per line: %hd"),
+                 qtohs (pcx_header.bytesperline));
+      return -1;
+    }
+
   if (pcx_header.planes == 3 && pcx_header.bpp == 8)
     {
       image= gimp_image_new (width, height, GIMP_RGB);
diff -Naur gimp-2.2.15/plug-ins/common/pnm.c gimp-2.2.13/plug-ins/common/pnm.c
--- gimp-2.2.15/plug-ins/common/pnm.c	2007-04-17 23:11:23.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/pnm.c	2007-07-06 10:19:22.000000000 +0200
@@ -487,6 +487,8 @@
   pnminfo->xres = g_ascii_isdigit(*buf)?atoi(buf):0;
   CHECK_FOR_ERROR(pnminfo->xres<=0, pnminfo->jmpbuf,
 		  _("PNM: Invalid X resolution."));
+  CHECK_FOR_ERROR (pnminfo->xres > GIMP_MAX_IMAGE_SIZE, pnminfo->jmpbuf,
+                   _("Image width is larger than GIMP can handle."));
 
   pnmscanner_gettoken(scan, buf, BUFLEN);
   CHECK_FOR_ERROR(pnmscanner_eof(scan), pnminfo->jmpbuf,
@@ -494,6 +496,8 @@
   pnminfo->yres = g_ascii_isdigit(*buf)?atoi(buf):0;
   CHECK_FOR_ERROR(pnminfo->yres<=0, pnminfo->jmpbuf,
 		  _("PNM: Invalid Y resolution."));
+  CHECK_FOR_ERROR (pnminfo->yres > GIMP_MAX_IMAGE_SIZE, pnminfo->jmpbuf,
+                   _("Image height is larger than GIMP can handle."));
 
   if (pnminfo->np != 0)		/* pbm's don't have a maxval field */
     {
@@ -554,6 +558,7 @@
   char           buf[BUFLEN];
 
   np = (info->np)?(info->np):1;
+  /* No overflow as long as gimp_tile_height() < 2730 = 2^(31 - 18) / 3 */
   data = g_malloc (gimp_tile_height () * info->xres * np);
 
   /* Buffer reads to increase performance */
diff -Naur gimp-2.2.15/plug-ins/common/psd.c gimp-2.2.13/plug-ins/common/psd.c
--- gimp-2.2.15/plug-ins/common/psd.c	2007-04-17 23:11:24.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/psd.c	2007-07-06 10:53:53.000000000 +0200
@@ -396,7 +396,7 @@
 static void xfread(FILE *fd, void *buf, long len, gchar *why);
 static void xfread_interlaced(FILE *fd, guchar *buf, long len, gchar *why,
 			      gint step);
-static void read_whole_file(FILE *fd);
+static void read_whole_file(FILE *fd, const gchar *name);
 static void reshuffle_cmap(guchar *map256);
 static gchar* getpascalstring(FILE *fd, gchar *why);
 static gchar* getstring(size_t n, FILE * fd, gchar *why);
@@ -954,6 +954,17 @@
   layer->width = right - left;
   layer->height = bottom - top;
 
+  if ((layer->height > GIMP_MAX_IMAGE_SIZE) ||
+      (layer->width > GIMP_MAX_IMAGE_SIZE))
+    {
+      g_error ("Input file has a larger layer size than GIMP can handle.");
+    }
+
+  if (layer->width > (G_MAXUINT / layer->height))
+    {
+      g_error ("Input file has a larger layer size than GIMP can handle.");
+    }
+
   IFDBG printf("\t\t\t\tLayer extents: (%d,%d) -> (%d,%d)\n",
 	       left,top,right,bottom);
 
@@ -963,6 +974,13 @@
   IFDBG printf("\t\t\t\tNumber of channels: %d\n",
 	       (int)layer->num_channels);
 
+  if ((layer->num_channels < 0) || (layer->num_channels > 56))
+    {
+      g_message ("Error: invalid number of channels in layer %d: %d",
+                 layernum, layer->num_channels);
+      gimp_quit();
+    }
+
   if (layer->num_channels)
     {
       layer->channel = g_new(PSDchannel, layer->num_channels);
@@ -1063,6 +1081,17 @@
       layer->lm_width = right - left;
       layer->lm_height = bottom - top;
 
+      if ((layer->lm_height > GIMP_MAX_IMAGE_SIZE) ||
+          (layer->lm_width > GIMP_MAX_IMAGE_SIZE))
+        {
+          g_error ("Input file has a larger layer mask size than GIMP can handle.");
+        }
+
+      if (layer->lm_width > (G_MAXUINT / layer->lm_height))
+        {
+          g_error ("Input file has a larger layer mask size than GIMP can handle.");
+        }
+
       getglong(fd, "lmask data throw");
       (*offset) += 4;
 
@@ -1199,9 +1228,15 @@
   compression = getgshort(fd, "layer channel compression type");
   offset+=2;
 
-  width = channel->width;
+  width  = channel->width;
   height = channel->height;
 
+  if (width > G_MAXINT16 || height > G_MAXINT16)
+    {
+      g_message ("Error: Invalid channel dimensions");
+      gimp_quit ();
+    }
+
   IFDBG
     {
       printf("\t\t\tLayer (%d) Channel (%d:%d) Compression: %d (%s)\n",
@@ -1787,7 +1822,7 @@
   gimp_progress_init (name_buf);
   g_free (name_buf);
 
-  read_whole_file (fd);
+  read_whole_file (fd, name);
 
   if (psd_image.num_layers > 0) /* PS3-style */
     {
@@ -2767,7 +2802,7 @@
 }
 
 static void
-read_whole_file(FILE * fd)
+read_whole_file(FILE * fd, const gchar *filename)
 {
     guint16 w;
     gint32 pos;
@@ -2777,9 +2812,36 @@
     xfread(fd, &PSDheader.signature, 4, "signature");
     PSDheader.version = getgshort(fd, "version");
     xfread(fd, &dummy, 6, "reserved");
+
     PSDheader.channels = getgshort(fd, "channels");
+
+    /* Photoshop CS (version 8) supports a maximum of 56 channels */
+
+    if (PSDheader.channels > 56)
+      {
+        g_error ("'%s' has more channels than GIMP can handle.",
+                 gimp_filename_to_utf8 (filename));
+      }
+
     PSDheader.rows = getglong(fd, "rows");
     PSDheader.columns = getglong(fd, "columns");
+
+    /* Photoshop CS (version 8) supports 300000 x 300000, but this
+       is currently larger than GIMP_MAX_IMAGE_SIZE */
+
+    if ((PSDheader.rows > GIMP_MAX_IMAGE_SIZE) ||
+        (PSDheader.columns > GIMP_MAX_IMAGE_SIZE))
+      {
+        g_error ("'%s' has a larger image size than GIMP can handle.",
+                 gimp_filename_to_utf8 (filename));
+      }
+
+    if (PSDheader.columns > (G_MAXUINT / PSDheader.rows))
+      {
+        g_error ("'%s' has a larger image size than GIMP can handle.",
+                 gimp_filename_to_utf8 (filename));
+      }
+
     PSDheader.bpp = getgshort(fd, "depth");
     PSDheader.mode = getgshort(fd, "mode");
 
diff -Naur gimp-2.2.15/plug-ins/common/psp.c gimp-2.2.13/plug-ins/common/psp.c
--- gimp-2.2.15/plug-ins/common/psp.c	2007-04-17 23:11:24.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/psp.c	2007-07-06 10:19:22.000000000 +0200
@@ -479,7 +479,6 @@
       || (major < 4 && fread (total_len, 4, 1, f) < 1))
     {
       g_message ("Error reading block header");
-      fclose (f);
       return -1;
     }
   if (memcmp (buf, "~BK\0", 4) != 0)
@@ -488,8 +487,6 @@
 	g_message ("Invalid block header at %ld", header_start);
       else
 	g_message ("Invalid block header");
-
-      fclose (f);
       return -1;
     }
 
@@ -524,7 +521,6 @@
   if (init_len < 38 || total_len < 38)
     {
       g_message ("Invalid general image attribute chunk size");
-      fclose (f);
       return -1;
     }
 
@@ -544,7 +540,6 @@
       || fread (&ia->layer_count, 2, 1, f) < 1)
     {
       g_message ("Error reading general image attribute block");
-      fclose (f);
       return -1;
     }
   ia->width = GUINT32_FROM_LE (ia->width);
@@ -559,7 +554,6 @@
   if (ia->compression > PSP_COMP_LZ77)
     {
       g_message ("Unknown compression type %d", ia->compression);
-      fclose (f);
       return -1;
     }
 
@@ -567,7 +561,6 @@
   if (ia->depth != 24)
     {
       g_message ("Unsupported bit depth %d", ia->depth);
-      fclose (f);
       return -1;
     }
 
@@ -618,15 +611,11 @@
 	  || fread (&length, 4, 1, f) < 1)
 	{
 	  g_message ("Error reading creator keyword chunk");
-	  fclose (f);
-	  gimp_image_delete (image_ID);
 	  return -1;
 	}
       if (memcmp (buf, "~FL\0", 4) != 0)
 	{
 	  g_message ("Invalid keyword chunk header");
-	  fclose (f);
-	  gimp_image_delete (image_ID);
 	  return -1;
 	}
       keyword = GUINT16_FROM_LE (keyword);
@@ -641,8 +630,6 @@
 	  if (fread (string, length, 1, f) < 1)
 	    {
 	      g_message ("Error reading creator keyword data");
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 	  switch (keyword)
@@ -666,8 +653,6 @@
 	  if (fread (&dword, 4, 1, f) < 1)
 	    {
 	      g_message ("Error reading creator keyword data");
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 	  switch (keyword)
@@ -685,7 +670,6 @@
 	default:
 	  if (try_fseek (f, length, SEEK_CUR) < 0)
 	    {
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 	  break;
@@ -971,7 +955,6 @@
       if (inflateInit (&zstream) != Z_OK)
 	{
 	  g_message ("zlib error");
-	  fclose (f);
 	  return -1;
 	}
       if (bytespp == 1)
@@ -986,7 +969,6 @@
 	{
 	  g_message ("zlib error");
 	  inflateEnd (&zstream);
-	  fclose (f);
 	  return -1;
 	}
       inflateEnd (&zstream);
@@ -1019,7 +1001,7 @@
   long block_start, sub_block_start, channel_start;
   gint sub_id;
   guint32 sub_init_len, sub_total_len;
-  gchar *name;
+  gchar *name = NULL;
   guint16 namelen;
   guchar type, opacity, blend_mode, visibility, transparency_protected;
   guchar link_group_id, mask_linked, mask_disabled;
@@ -1044,16 +1026,12 @@
       /* Read the layer sub-block header */
       sub_id = read_block_header (f, &sub_init_len, &sub_total_len);
       if (sub_id == -1)
-	{
-	  gimp_image_delete (image_ID);
-	  return -1;
-	}
+        return -1;
+
       if (sub_id != PSP_LAYER_BLOCK)
 	{
 	  g_message ("Invalid layer sub-block %s, should be LAYER",
 		     block_name (sub_id));
-	  fclose (f);
-	  gimp_image_delete (image_ID);
 	  return -1;
 	}
 
@@ -1084,10 +1062,10 @@
 	      || fread (&channel_count, 2, 1, f) < 1)
 	    {
 	      g_message ("Error reading layer information chunk");
-	      fclose (f);
-	      gimp_image_delete (image_ID);
+              g_free (name);
 	      return -1;
 	    }
+
 	  name[namelen] = 0;
 	  type = PSP_LAYER_NORMAL; /* ??? */
 	}
@@ -1095,6 +1073,7 @@
 	{
 	  name = g_malloc (257);
 	  name[256] = 0;
+
 	  if (fread (name, 256, 1, f) < 1
 	      || fread (&type, 1, 1, f) < 1
 	      || fread (&image_rect, 16, 1, f) < 1
@@ -1114,8 +1093,6 @@
 	    {
 	      g_message ("Error reading layer information chunk");
 	      g_free (name);
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 	}
@@ -1143,6 +1120,14 @@
       width = saved_image_rect[2] - saved_image_rect[0];
       height = saved_image_rect[3] - saved_image_rect[1];
 
+      if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE)       /* w <= 2^18 */
+          || (height < 0) || (height > GIMP_MAX_IMAGE_SIZE)  /* h <= 2^18 */
+          || ((width / 256) * (height / 256) >= 8192))       /* w * h < 2^29 */
+        {
+          g_message ("Invalid layer dimensions: %dx%d", width, height);
+          return -1;
+        }
+
       IFDBG(2) g_message
 	("layer: %s %dx%d (%dx%d) @%d,%d opacity %d blend_mode %s "
 	 "%d bitmaps %d channels",
@@ -1191,8 +1176,6 @@
       if (layer_ID == -1)
 	{
 	  g_message ("Error creating layer");
-	  fclose (f);
-	  gimp_image_delete (image_ID);
 	  return -1;
 	}
 
@@ -1212,16 +1195,17 @@
       if (major < 4)
 	if (try_fseek (f, sub_block_start + sub_init_len, SEEK_SET) < 0)
 	  {
-	    gimp_image_delete (image_ID);
 	    return -1;
 	  }
 
       pixel = g_malloc0 (height * width * bytespp);
       if (null_layer)
-	pixels = NULL;
+        {
+          pixels = NULL;
+        }
       else
 	{
-	  pixels = g_new(guchar *, height);
+	  pixels = g_new (guchar *, height);
 	  for (i = 0; i < height; i++)
 	    pixels[i] = pixel + width * bytespp * i;
 	}
@@ -1247,8 +1231,6 @@
 	    {
 	      g_message ("Invalid layer sub-block %s, should be CHANNEL",
 			 block_name (sub_id));
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 
@@ -1263,8 +1245,6 @@
 	      || fread (&channel_type, 2, 1, f) < 1)
 	    {
 	      g_message ("Error reading channel information chunk");
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 
@@ -1277,8 +1257,6 @@
 	    {
 	      g_message ("Invalid bitmap type %d in channel information chunk",
 			 bitmap_type);
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 
@@ -1286,8 +1264,6 @@
 	    {
 	      g_message ("Invalid channel type %d in channel information chunk",
 			 channel_type);
-	      fclose (f);
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 
@@ -1305,7 +1281,6 @@
 	  if (major < 4)
 	    if (try_fseek (f, channel_start + channel_init_len, SEEK_SET) < 0)
 	      {
-		gimp_image_delete (image_ID);
 		return -1;
 	      }
 
@@ -1313,13 +1288,11 @@
 	    if (read_channel_data (f, ia, pixels, bytespp,
 				   offset, drawable, compressed_len) == -1)
 	      {
-		gimp_image_delete (image_ID);
 		return -1;
 	      }
 
 	  if (try_fseek (f, channel_start + channel_total_len, SEEK_SET) < 0)
 	    {
-	      gimp_image_delete (image_ID);
 	      return -1;
 	    }
 	}
@@ -1332,9 +1305,9 @@
       g_free (pixels);
       g_free (pixel);
     }
+
   if (try_fseek (f, block_start + total_len, SEEK_SET) < 0)
     {
-      gimp_image_delete (image_ID);
       return -1;
     }
 
@@ -1368,10 +1341,9 @@
       || fread (&selection_mode, 4, 1, f) < 1)
     {
       g_message ("Error reading tube data chunk");
-      fclose (f);
-      gimp_image_delete (image_ID);
       return -1;
     }
+
   name[513] = 0;
   version = GUINT16_FROM_LE (version);
   params.step = GUINT32_FROM_LE (step_size);
@@ -1465,18 +1437,18 @@
       || fread (&minor, 2, 1, f) < 1)
     {
       g_message ("Error reading file header");
-      fclose (f);
-      return -1;
+      goto error;
     }
+
   if (memcmp (buf, "Paint Shop Pro Image File\n\032\0\0\0\0\0", 32) != 0)
     {
       g_message ("Incorrect file signature");
-      fclose (f);
-      return -1;
+      goto error;
     }
 
   major = GUINT16_FROM_LE (major);
   minor = GUINT16_FROM_LE (minor);
+
   /* I only have the documentation for file format version 3.0,
    * but PSP 6 writes version 4.0. Let's hope it's backwards compatible.
    * Earlier versions probably don't have all the fields I expect
@@ -1487,8 +1459,7 @@
       g_message ("Unsupported PSP file format version "
 		 "%d.%d, only knows 3.0 (and later?)",
 		 major, minor);
-      fclose (f);
-      return -1;
+      goto error;
     }
   else if (major == 3)
     ; /* OK */
@@ -1501,8 +1472,7 @@
     {
       g_message ("Unsupported PSP file format version %d.%d",
 		 major, minor);
-      fclose (f);
-      return -1;
+      goto error;
     }
 
   /* Read all the blocks */
@@ -1520,12 +1490,13 @@
 	  if (block_number != 0)
 	    {
 	      g_message ("Duplicate General Image Attributes block");
-	      fclose (f);
-	      return -1;
+              goto error;
 	    }
 	  if (read_general_image_attribute_block (f, block_init_len,
 						  block_total_len, &ia) == -1)
-	    return -1;
+            {
+              goto error;
+            }
 
 	  IFDBG(2) g_message ("%d dpi %dx%d %s",
 			      (int) ia.resolution,
@@ -1535,7 +1506,9 @@
 	  image_ID = gimp_image_new (ia.width, ia.height,
 				     ia.greyscale ? GIMP_GRAY : GIMP_RGB);
 	  if (image_ID == -1)
-	    return -1;
+            {
+              goto error;
+            }
 
 	  gimp_image_set_filename (image_ID, filename);
 
@@ -1546,15 +1519,14 @@
 	  if (block_number == 0)
 	    {
 	      g_message ("Missing General Image Attributes block");
-	      fclose (f);
-	      gimp_image_delete (image_ID);
-	      return -1;
+              goto error;
 	    }
+
 	  switch (id)
 	    {
 	    case PSP_CREATOR_BLOCK:
 	      if (read_creator_block (f, image_ID, block_total_len, &ia) == -1)
-		return -1;
+                goto error;
 	      break;
 
 	    case PSP_COLOR_BLOCK:
@@ -1562,7 +1534,7 @@
 
 	    case PSP_LAYER_START_BLOCK:
 	      if (read_layer_block (f, image_ID, block_total_len, &ia) == -1)
-		return -1;
+		goto error;
 	      break;
 
 	    case PSP_SELECTION_BLOCK:
@@ -1579,7 +1551,7 @@
 
 	    case PSP_TUBE_BLOCK:
 	      if (read_tube_block (f, image_ID, block_total_len, &ia) == -1)
-		return -1;
+		goto error;
 	      break;
 
 	    case PSP_LAYER_BLOCK:
@@ -1600,17 +1572,17 @@
 	break;
 
       if (try_fseek (f, block_start + block_total_len, SEEK_SET) < 0)
-	{
-	  gimp_image_delete (image_ID);
-	  return -1;
-	}
+        goto error;
+
       block_number++;
     }
 
   if (id == -1)
     {
+    error:
       fclose (f);
-      gimp_image_delete (image_ID);
+      if (image_ID != -1)
+        gimp_image_delete (image_ID);
       return -1;
     }
 
diff -Naur gimp-2.2.15/plug-ins/common/sunras.c gimp-2.2.13/plug-ins/common/sunras.c
--- gimp-2.2.15/plug-ins/common/sunras.c	2007-05-26 16:10:46.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/sunras.c	2007-07-06 11:29:35.000000000 +0200
@@ -401,6 +401,11 @@
       return (-1);
     }
 
+  if ((sunhdr.l_ras_maplength < 0) || (sunhdr.l_ras_maplength > (256 * 3)))
+    {
+      g_error ("Map lengths greater than 256 entries are unsupported by GIMP.");
+    }
+
   /* Is there a RGB colourmap ? */
   if ((sunhdr.l_ras_maptype == 1) && (sunhdr.l_ras_maplength > 0))
     {
@@ -432,6 +437,38 @@
 	     *4 + sunhdr.l_ras_maplength, SEEK_SET);
     }
 
+  if (sunhdr.l_ras_width <= 0)
+    {
+      g_message (_("'%s':\nNo image width specified"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
+  if (sunhdr.l_ras_width > GIMP_MAX_IMAGE_SIZE)
+    {
+      g_message (_("'%s':\nImage width is larger than GIMP can handle"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
+  if (sunhdr.l_ras_height <= 0)
+    {
+      g_message (_("'%s':\nNo image height specified"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
+  if (sunhdr.l_ras_height > GIMP_MAX_IMAGE_SIZE)
+    {
+      g_message (_("'%s':\nImage height is larger than GIMP can handle"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
   temp = g_strdup_printf (_("Opening '%s'..."),
                           gimp_filename_to_utf8 (filename));
   gimp_progress_init (temp);
diff -Naur gimp-2.2.15/plug-ins/common/xbm.c gimp-2.2.13/plug-ins/common/xbm.c
--- gimp-2.2.15/plug-ins/common/xbm.c	2007-04-17 23:11:23.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/xbm.c	2007-07-06 10:19:22.000000000 +0200
@@ -806,21 +806,35 @@
       return -1;
     }
 
-  if (width == 0)
+  if (width <= 0)
     {
       g_message (_("'%s':\nNo image width specified"),
                  gimp_filename_to_utf8 (filename));
       return -1;
     }
 
-  if (height == 0)
+  if (width > GIMP_MAX_IMAGE_SIZE)
+    {
+      g_message (_("'%s':\nImage width is larger than GIMP can handle"),
+                 gimp_filename_to_utf8 (filename));
+      return -1;
+    }
+
+   if (height <= 0)
     {
       g_message (_("'%s':\nNo image height specified"),
                  gimp_filename_to_utf8 (filename));
       return -1;
     }
 
-  if (intbits == 0)
+  if (height > GIMP_MAX_IMAGE_SIZE)
+    {
+      g_message (_("'%s':\nImage height is larger than GIMP can handle"),
+                 gimp_filename_to_utf8 (filename));
+      return -1;
+    }
+
+   if (intbits == 0)
     {
       g_message (_("'%s':\nNo image data type specified"),
                  gimp_filename_to_utf8 (filename));
@@ -1059,7 +1073,7 @@
 
 #ifdef VERBOSE
       if (verbose > 1)
-	printf ("TGA: writing %dx(%d+%d) pixel region\n",
+	printf ("XBM: writing %dx(%d+%d) pixel region\n",
 		width, i, tileheight);
 #endif
 
diff -Naur gimp-2.2.15/plug-ins/common/xwd.c gimp-2.2.13/plug-ins/common/xwd.c
--- gimp-2.2.15/plug-ins/common/xwd.c	2007-04-17 23:11:23.000000000 +0200
+++ gimp-2.2.13/plug-ins/common/xwd.c	2007-07-06 10:19:22.000000000 +0200
@@ -472,6 +472,39 @@
         }
     }
 
+  if (xwdhdr.l_pixmap_width <= 0)
+    {
+      g_message (_("'%s':\nNo image width specified"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
+  if (xwdhdr.l_pixmap_width > GIMP_MAX_IMAGE_SIZE
+      || xwdhdr.l_bytes_per_line > GIMP_MAX_IMAGE_SIZE * 3)
+    {
+      g_message (_("'%s':\nImage width is larger than GIMP can handle"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
+  if (xwdhdr.l_pixmap_height <= 0)
+    {
+      g_message (_("'%s':\nNo image height specified"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
+  if (xwdhdr.l_pixmap_height > GIMP_MAX_IMAGE_SIZE)
+    {
+      g_message (_("'%s':\nImage height is larger than GIMP can handle"),
+                 gimp_filename_to_utf8 (filename));
+      fclose (ifp);
+      return (-1);
+    }
+
   temp = g_strdup_printf (_("Opening '%s'..."),
                           gimp_filename_to_utf8 (filename));
   gimp_progress_init (temp);

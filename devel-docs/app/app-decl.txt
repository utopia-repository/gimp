<FUNCTION>
<NAME>app_libs_init</NAME>
<RETURNS>void      </RETURNS>
GOptionContext      *context,gboolean             no_interface
</FUNCTION>
<FUNCTION>
<NAME>app_abort</NAME>
<RETURNS>void      </RETURNS>
gboolean             no_interface,const gchar         *abort_message
</FUNCTION>
<FUNCTION>
<NAME>app_exit</NAME>
<RETURNS>void      </RETURNS>
gint                 status
</FUNCTION>
<FUNCTION>
<NAME>app_run</NAME>
<RETURNS>void      </RETURNS>
const gchar         *full_prog_name,const gchar        **filenames,const gchar         *alternate_system_gimprc,const gchar         *alternate_gimprc,const gchar         *session_name,const gchar         *batch_interpreter,const gchar        **batch_commands,gboolean             no_interface,gboolean             no_data,gboolean             no_fonts,gboolean             no_splash,gboolean             be_verbose,gboolean             use_shm,gboolean             use_cpu_accel,gboolean             console_messages,GimpStackTraceMode   stack_trace_mode,GimpPDBCompatMode    pdb_compat_mode
</FUNCTION>
<FUNCTION>
<NAME>batch_run</NAME>
<RETURNS>void   </RETURNS>
Gimp         *gimp,const gchar  *batch_interpreter,const gchar **batch_commands
</FUNCTION>
<FUNCTION>
<NAME>gimp_errors_init</NAME>
<RETURNS>void   </RETURNS>
const gchar        *full_prog_name,gboolean            use_debug_handler,GimpStackTraceMode  stack_trace_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_log_func</NAME>
<RETURNS>void   </RETURNS>
const gchar        *log_domain,GLogLevelFlags      flags,const gchar        *message,gpointer            data
</FUNCTION>
<FUNCTION>
<NAME>gimp_error_log_func</NAME>
<RETURNS>void   </RETURNS>
const gchar        *domain,GLogLevelFlags      flags,const gchar        *message,gpointer            data
</FUNCTION>
<FUNCTION>
<NAME>gimp_fatal_error</NAME>
<RETURNS>void   </RETURNS>
const gchar        *message,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_terminate</NAME>
<RETURNS>void   </RETURNS>
const gchar        *message,...
</FUNCTION>
<FUNCTION>
<NAME>sanity_check</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>units_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_ACRONYM</NAME>
#define GIMP_ACRONYM \
  _("GIMP")
</MACRO>
<MACRO>
<NAME>GIMP_NAME</NAME>
#define GIMP_NAME \
  _("GNU Image Manipulation Program")
</MACRO>
<MACRO>
<NAME>GIMP_COPYRIGHT</NAME>
#define GIMP_COPYRIGHT \
  _("Copyright Â© 1995-2006\n" \
    "Spencer Kimball, Peter Mattis and the GIMP Development Team")
</MACRO>
<MACRO>
<NAME>GIMP_LICENSE</NAME>
#define GIMP_LICENSE \
  _("GIMP is free software; you can redistribute it and/or modify it "   \
    "under the terms of the GNU General Public License as published by " \
    "the Free Software Foundation; either version 2 of the License, or " \
    "(at your option) any later version."                                \
    "\n\n"                                                               \
    "GIMP is distributed in the hope that it will be useful, "           \
    "but WITHOUT ANY WARRANTY; without even the implied warranty of "    \
    "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the "     \
    "GNU General Public License for more details."                       \
    "\n\n"                                                               \
    "You should have received a copy of the GNU General Public License " \
    "along with GIMP; if not, write to the Free Software Foundation, "   \
    "Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.")
</MACRO>
<ENUM>
<NAME>GimpActionSelectType</NAME>
typedef enum
{
  GIMP_ACTION_SELECT_SET           =  0,
  GIMP_ACTION_SELECT_FIRST         = -1,
  GIMP_ACTION_SELECT_LAST          = -2,
  GIMP_ACTION_SELECT_PREVIOUS      = -3,
  GIMP_ACTION_SELECT_NEXT          = -4,
  GIMP_ACTION_SELECT_SKIP_PREVIOUS = -5,
  GIMP_ACTION_SELECT_SKIP_NEXT     = -6
} GimpActionSelectType;
</ENUM>
<VARIABLE>
<NAME>global_action_factory</NAME>
extern GimpActionFactory *global_action_factory;
</VARIABLE>
<FUNCTION>
<NAME>actions_init</NAME>
<RETURNS>void          </RETURNS>
Gimp                 *gimp
</FUNCTION>
<FUNCTION>
<NAME>actions_exit</NAME>
<RETURNS>void          </RETURNS>
Gimp                 *gimp
</FUNCTION>
<FUNCTION>
<NAME>action_data_get_gimp</NAME>
<RETURNS>Gimp        *</RETURNS>
gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>action_data_get_context</NAME>
<RETURNS>GimpContext *</RETURNS>
gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>action_data_get_image</NAME>
<RETURNS>GimpImage   *</RETURNS>
gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>action_data_get_display</NAME>
<RETURNS>GimpDisplay *</RETURNS>
gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>action_data_get_widget</NAME>
<RETURNS>GtkWidget   *</RETURNS>
gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>action_select_value</NAME>
<RETURNS>gdouble       </RETURNS>
GimpActionSelectType  select_type,gdouble               value,gdouble               min,gdouble               max,gdouble               inc,gdouble               skip_inc,gboolean              wrap
</FUNCTION>
<FUNCTION>
<NAME>action_select_property</NAME>
<RETURNS>void          </RETURNS>
GimpActionSelectType  select_type,GObject              *object,const gchar          *property_name,gdouble               inc,gdouble               skip_inc,gboolean              wrap
</FUNCTION>
<FUNCTION>
<NAME>action_select_object</NAME>
<RETURNS>GimpObject  *</RETURNS>
GimpActionSelectType  select_type,GimpContainer        *container,GimpObject           *current
</FUNCTION>
<MACRO>
<NAME>return_if_no_gimp</NAME>
#define return_if_no_gimp(gimp,data) \
  gimp = action_data_get_gimp (data); \
  if (! gimp) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_context</NAME>
#define return_if_no_context(context,data) \
  context = action_data_get_context (data); \
  if (! context) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_image</NAME>
#define return_if_no_image(image,data) \
  image = action_data_get_image (data); \
  if (! image) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_display</NAME>
#define return_if_no_display(display,data) \
  display = action_data_get_display (data); \
  if (! display) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_widget</NAME>
#define return_if_no_widget(widget,data) \
  widget = action_data_get_widget (data); \
  if (! widget) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_drawable</NAME>
#define return_if_no_drawable(image,drawable,data) \
  return_if_no_image (image,data); \
  drawable = gimp_image_active_drawable (image); \
  if (! drawable) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_layer</NAME>
#define return_if_no_layer(image,layer,data) \
  return_if_no_image (image,data); \
  layer = gimp_image_get_active_layer (image); \
  if (! layer) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_channel</NAME>
#define return_if_no_channel(image,channel,data) \
  return_if_no_image (image,data); \
  channel = gimp_image_get_active_channel (image); \
  if (! channel) \
    return
</MACRO>
<MACRO>
<NAME>return_if_no_vectors</NAME>
#define return_if_no_vectors(image,vectors,data) \
  return_if_no_image (image,data); \
  vectors = gimp_image_get_active_vectors (image); \
  if (! vectors) \
    return
</MACRO>
<FUNCTION>
<NAME>brushes_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>brushes_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>buffers_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>buffers_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>buffers_paste_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>buffers_paste_into_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>buffers_paste_as_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>buffers_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>channels_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>channels_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>channels_edit_attributes_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_new_last_vals_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_raise_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_raise_to_top_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_lower_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_lower_to_bottom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_duplicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>channels_to_selection_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>colormap_editor_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>colormap_editor_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>colormap_editor_edit_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>colormap_editor_add_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>context_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>context_colors_default_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>context_colors_swap_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>context_foreground_red_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_foreground_green_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_foreground_blue_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_background_red_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_background_green_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_background_blue_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_foreground_hue_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_foreground_saturation_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_foreground_value_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_background_hue_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_background_saturation_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_background_value_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_opacity_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_paint_mode_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_tool_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_pattern_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_palette_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_gradient_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_font_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_shape_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_radius_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_spikes_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_hardness_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_aspect_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>context_brush_angle_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>data_open_as_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>data_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>data_duplicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>data_copy_location_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     user_data
</FUNCTION>
<FUNCTION>
<NAME>data_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>data_refresh_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>data_edit_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,const gchar *value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>debug_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>debug_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<MACRO>
<NAME>ENABLE_DEBUG_MENU</NAME>
#define ENABLE_DEBUG_MENU 1
</MACRO>
<FUNCTION>
<NAME>debug_mem_profile_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>debug_dump_menus_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>debug_dump_managers_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<VARIABLE>
<NAME>n_dialogs_dockable_actions</NAME>
extern gint                        n_dialogs_dockable_actions;
</VARIABLE>
<FUNCTION>
<NAME>dialogs_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>dialogs_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_show_toolbox_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_create_toplevel_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,const gchar *value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_create_dockable_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,const gchar *value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_create_lc_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_create_data_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_create_stuff_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dialogs_show_toolbox</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>dock_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>dock_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>dock_toggle_image_menu_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>dock_toggle_auto_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>dockable_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>dockable_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>dockable_add_tab_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,const gchar *value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dockable_close_tab_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dockable_detach_tab_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dockable_toggle_view_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,GtkAction   *current,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dockable_view_size_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,GtkAction   *current,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dockable_tab_style_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,GtkAction   *current,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>dockable_show_button_bar_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>documents_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>documents_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>documents_open_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_raise_or_open_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_file_open_dialog_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_copy_location_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_remove_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_clear_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_recreate_preview_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_reload_previews_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>documents_remove_dangling_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>drawable_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>drawable_desaturate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_equalize_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_invert_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_levels_stretch_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_offset_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_linked_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_visible_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_flip_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>drawable_rotate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>edit_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>edit_undo_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_redo_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_undo_clear_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_cut_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_copy_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_copy_visible_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_paste_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_paste_into_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_paste_as_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_named_cut_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_named_copy_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_named_copy_visible_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_named_paste_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_clear_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>edit_fill_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>error_console_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>error_console_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>error_console_clear_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>error_console_save_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>file_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>file_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>file_open_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_open_from_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_open_as_layer_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_open_location_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_last_opened_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_save_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_save_as_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_save_a_copy_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_save_template_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_revert_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_close_all_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_quit_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>file_file_open_dialog</NAME>
<RETURNS>void   </RETURNS>
Gimp        *gimp,const gchar *uri,GtkWidget   *parent
</FUNCTION>
<FUNCTION>
<NAME>fonts_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>fonts_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>fonts_refresh_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_left_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_load_left_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_save_left_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_right_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_load_right_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_save_right_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_blending_func_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,GtkAction *current,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_coloring_type_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,GtkAction *current,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_flip_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_replicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_split_midpoint_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_split_uniformly_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_recenter_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_redistribute_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_blend_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_blend_opacity_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradient_editor_zoom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>gradients_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>gradients_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>gradients_save_as_pov_ray_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>help_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>help_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>help_help_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>help_context_help_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>image_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>image_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_new_from_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_convert_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_resize_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_resize_to_layers_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_print_size_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_scale_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_flip_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_rotate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_crop_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_duplicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_merge_layers_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_flatten_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_configure_grid_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>image_properties_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>images_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>images_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>images_raise_views_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>images_new_view_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>images_delete_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>layers_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>layers_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>layers_text_tool_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_edit_attributes_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_new_last_vals_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_raise_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_raise_to_top_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_lower_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_lower_to_bottom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_duplicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_anchor_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_merge_down_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_text_discard_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_resize_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_resize_to_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_scale_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_crop_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mask_add_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mask_apply_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mask_edit_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mask_show_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mask_disable_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mask_to_selection_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_alpha_add_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_alpha_remove_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_alpha_to_selection_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_opacity_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_mode_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>layers_lock_alpha_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>palette_editor_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>palette_editor_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>palette_editor_edit_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>palette_editor_new_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>palette_editor_delete_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>palette_editor_zoom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>palettes_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>palettes_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>palettes_import_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>palettes_merge_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>patterns_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>patterns_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>plug_in_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group
</FUNCTION>
<FUNCTION>
<NAME>plug_in_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,gpointer             data
</FUNCTION>
<FUNCTION>
<NAME>plug_in_actions_add_proc</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_actions_add_path</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,GimpPlugInProcedure *proc,const gchar         *menu_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_actions_remove_proc</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_actions_add_branch</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *progname,const gchar         *menu_path,const gchar         *menu_label
</FUNCTION>
<FUNCTION>
<NAME>plug_in_run_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction           *action,GimpPlugInProcedure *proc,gpointer             data
</FUNCTION>
<FUNCTION>
<NAME>plug_in_repeat_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction           *action,gint                 value,gpointer             data
</FUNCTION>
<FUNCTION>
<NAME>plug_in_reset_all_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction           *action,gpointer             data
</FUNCTION>
<FUNCTION>
<NAME>quick_mask_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>quick_mask_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>select_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>select_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>select_invert_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_all_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_none_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_float_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_feather_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_sharpen_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_shrink_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_border_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_grow_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_save_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_stroke_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>select_stroke_last_vals_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>templates_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>templates_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>templates_create_image_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction    *action,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>templates_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction    *action,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>templates_duplicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction    *action,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>templates_edit_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction    *action,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>templates_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction    *action,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>text_editor_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>text_editor_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>text_editor_load_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>text_editor_clear_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>text_editor_direction_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,GtkAction *current,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>tool_options_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_save_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_save_to_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_restore_from_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_rename_saved_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_delete_saved_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_reset_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tool_options_reset_all_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>tools_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>tools_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>tools_select_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,const gchar *value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_toggle_visibility_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_raise_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_raise_to_top_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_lower_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_lower_to_bottom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_reset_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_color_average_radius_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_ink_blob_size_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_ink_blob_aspect_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_ink_blob_angle_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_value_1_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_value_2_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_value_3_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_value_4_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_object_1_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>tools_object_2_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>vectors_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>vectors_vectors_tool_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_edit_attributes_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_new_last_vals_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_raise_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_raise_to_top_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_lower_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_lower_to_bottom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_duplicate_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_delete_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_merge_visible_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_to_selection_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_selection_to_vectors_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gint         value,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_stroke_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_stroke_last_vals_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_copy_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_paste_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_export_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_import_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_visible_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>vectors_linked_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction   *action,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>view_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>view_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>view_new_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_zoom_fit_in_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_zoom_fit_to_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_zoom_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_zoom_explicit_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,GtkAction *current,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_zoom_other_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_dot_for_dot_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_scroll_horizontal_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_scroll_vertical_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_navigation_window_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_display_filters_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_selection_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_layer_boundary_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_menubar_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_rulers_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_scrollbars_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_statusbar_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_guides_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_grid_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_toggle_sample_points_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_snap_to_guides_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_snap_to_grid_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_snap_to_canvas_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_snap_to_vectors_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_padding_color_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gint       value,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_shrink_wrap_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>view_fullscreen_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>window_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,const gchar     *move_to_screen_help_id
</FUNCTION>
<FUNCTION>
<NAME>window_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,GtkWidget       *window
</FUNCTION>
<FUNCTION>
<NAME>cursor_info_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>cursor_info_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>cursor_info_sample_merged_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>sample_point_editor_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>sample_point_editor_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>sample_point_editor_sample_merged_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>quick_mask_toggle_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>quick_mask_invert_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,GtkAction *current,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>quick_mask_configure_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>brush_editor_actions_setup</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group
</FUNCTION>
<FUNCTION>
<NAME>brush_editor_actions_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup *group,gpointer         data
</FUNCTION>
<FUNCTION>
<NAME>data_editor_edit_active_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>window_close_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>window_open_display_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,gpointer   data
</FUNCTION>
<FUNCTION>
<NAME>window_move_to_screen_cmd_callback</NAME>
<RETURNS>void   </RETURNS>
GtkAction *action,GtkAction *current,gpointer   data
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CURVE_TYPE</NAME>
#define GIMP_TYPE_CURVE_TYPE (gimp_curve_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_curve_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCurveType</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_CURVE_SMOOTH,   /*< desc="Smooth"   >*/
  GIMP_CURVE_FREE      /*< desc="Freehand" >*/
} GimpCurveType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_HISTOGRAM_CHANNEL</NAME>
#define GIMP_TYPE_HISTOGRAM_CHANNEL (gimp_histogram_channel_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_histogram_channel_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpHistogramChannel</NAME>
typedef enum
{
  GIMP_HISTOGRAM_VALUE = 0,  /*< desc="Value" >*/
  GIMP_HISTOGRAM_RED   = 1,  /*< desc="Red"   >*/
  GIMP_HISTOGRAM_GREEN = 2,  /*< desc="Green" >*/
  GIMP_HISTOGRAM_BLUE  = 3,  /*< desc="Blue"  >*/
  GIMP_HISTOGRAM_ALPHA = 4,  /*< desc="Alpha" >*/
  GIMP_HISTOGRAM_RGB   = 5   /*< desc="RGB", pdb-skip >*/
} GimpHistogramChannel;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_LAYER_MODE_EFFECTS</NAME>
#define GIMP_TYPE_LAYER_MODE_EFFECTS (gimp_layer_mode_effects_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_layer_mode_effects_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpLayerModeEffects</NAME>
typedef enum
{
  GIMP_NORMAL_MODE,          /*< desc="Normal"        >*/
  GIMP_DISSOLVE_MODE,        /*< desc="Dissolve"      >*/
  GIMP_BEHIND_MODE,          /*< desc="Behind"        >*/
  GIMP_MULTIPLY_MODE,        /*< desc="Multiply"      >*/
  GIMP_SCREEN_MODE,          /*< desc="Screen"        >*/
  GIMP_OVERLAY_MODE,         /*< desc="Overlay"       >*/
  GIMP_DIFFERENCE_MODE,      /*< desc="Difference"    >*/
  GIMP_ADDITION_MODE,        /*< desc="Addition"      >*/
  GIMP_SUBTRACT_MODE,        /*< desc="Subtract"      >*/
  GIMP_DARKEN_ONLY_MODE,     /*< desc="Darken only"   >*/
  GIMP_LIGHTEN_ONLY_MODE,    /*< desc="Lighten only"  >*/
  GIMP_HUE_MODE,             /*< desc="Hue"           >*/
  GIMP_SATURATION_MODE,      /*< desc="Saturation"    >*/
  GIMP_COLOR_MODE,           /*< desc="Color"         >*/
  GIMP_VALUE_MODE,           /*< desc="Value"         >*/
  GIMP_DIVIDE_MODE,          /*< desc="Divide"        >*/
  GIMP_DODGE_MODE,           /*< desc="Dodge"         >*/
  GIMP_BURN_MODE,            /*< desc="Burn"          >*/
  GIMP_HARDLIGHT_MODE,       /*< desc="Hard light"    >*/
  GIMP_SOFTLIGHT_MODE,       /*< desc="Soft light"    >*/
  GIMP_GRAIN_EXTRACT_MODE,   /*< desc="Grain extract" >*/
  GIMP_GRAIN_MERGE_MODE,     /*< desc="Grain merge"   >*/
  GIMP_COLOR_ERASE_MODE,     /*< desc="Color erase"   >*/
  GIMP_ERASE_MODE,           /*< pdb-skip, skip       >*/
  GIMP_REPLACE_MODE,         /*< pdb-skip, skip       >*/
  GIMP_ANTI_ERASE_MODE       /*< pdb-skip, skip       >*/
} GimpLayerModeEffects;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_HUE_RANGE</NAME>
#define GIMP_TYPE_HUE_RANGE (gimp_hue_range_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_hue_range_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpHueRange</NAME>
typedef enum
{
  GIMP_ALL_HUES,
  GIMP_RED_HUES,
  GIMP_YELLOW_HUES,
  GIMP_GREEN_HUES,
  GIMP_CYAN_HUES,
  GIMP_BLUE_HUES,
  GIMP_MAGENTA_HUES
} GimpHueRange;
</ENUM>
<ENUM>
<NAME>GimpConvolutionType</NAME>
typedef enum  /*< skip >*/
{
  GIMP_NORMAL_CONVOL,      /*  Negative numbers truncated  */
  GIMP_ABSOLUTE_CONVOL,    /*  Absolute value              */
  GIMP_NEGATIVE_CONVOL     /*  add 127 to values           */
} GimpConvolutionType;
</ENUM>
<ENUM>
<NAME>SioxRefinementType</NAME>
typedef enum  /*< pdb-skip, skip >*/
{
  SIOX_REFINEMENT_NO_CHANGE          = 0,
  SIOX_REFINEMENT_ADD_FOREGROUND     = (1 << 0),
  SIOX_REFINEMENT_ADD_BACKGROUND     = (1 << 1),
  SIOX_REFINEMENT_CHANGE_SENSITIVITY = (1 << 2),
  SIOX_REFINEMENT_CHANGE_SMOOTHNESS  = (1 << 3),
  SIOX_REFINEMENT_CHANGE_MULTIBLOB   = (1 << 4),
  SIOX_REFINEMENT_RECALCULATE        = 0xFF
} SioxRefinementType;
</ENUM>
<MACRO>
<NAME>MAX_CHANNELS</NAME>
#define MAX_CHANNELS     4
</MACRO>
<MACRO>
<NAME>GRAY_PIX</NAME>
#define GRAY_PIX         0
</MACRO>
<MACRO>
<NAME>ALPHA_G_PIX</NAME>
#define ALPHA_G_PIX      1
</MACRO>
<MACRO>
<NAME>RED_PIX</NAME>
#define RED_PIX          0
</MACRO>
<MACRO>
<NAME>GREEN_PIX</NAME>
#define GREEN_PIX        1
</MACRO>
<MACRO>
<NAME>BLUE_PIX</NAME>
#define BLUE_PIX         2
</MACRO>
<MACRO>
<NAME>ALPHA_PIX</NAME>
#define ALPHA_PIX        3
</MACRO>
<MACRO>
<NAME>INDEXED_PIX</NAME>
#define INDEXED_PIX      0
</MACRO>
<MACRO>
<NAME>ALPHA_I_PIX</NAME>
#define ALPHA_I_PIX      1
</MACRO>
<STRUCT>
<NAME>BoundSeg</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogram</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLut</NAME>
</STRUCT>
<STRUCT>
<NAME>ColorBalance</NAME>
</STRUCT>
<STRUCT>
<NAME>Colorize</NAME>
</STRUCT>
<STRUCT>
<NAME>Curves</NAME>
</STRUCT>
<STRUCT>
<NAME>HueSaturation</NAME>
</STRUCT>
<STRUCT>
<NAME>Levels</NAME>
</STRUCT>
<STRUCT>
<NAME>Threshold</NAME>
</STRUCT>
<STRUCT>
<NAME>PixelRegionIterator</NAME>
</STRUCT>
<STRUCT>
<NAME>PixelRegion</NAME>
</STRUCT>
<STRUCT>
<NAME>PixelRegionHolder</NAME>
</STRUCT>
<STRUCT>
<NAME>SioxState</NAME>
</STRUCT>
<STRUCT>
<NAME>TempBuf</NAME>
</STRUCT>
<TYPEDEF>
<NAME>MaskBuf</NAME>
typedef struct _TempBuf             MaskBuf;
</TYPEDEF>
<STRUCT>
<NAME>Tile</NAME>
</STRUCT>
<STRUCT>
<NAME>TileManager</NAME>
</STRUCT>
<STRUCT>
<NAME>PixelDataHandle</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>TileValidateProc</NAME>
<RETURNS>void </RETURNS>
TileManager *tm,
                                      Tile        *tile
</USER_FUNCTION>
<FUNCTION>
<NAME>base_init</NAME>
<RETURNS>gboolean </RETURNS>
GimpBaseConfig *config,gboolean        be_verbose,gboolean        use_cpu_accel
</FUNCTION>
<FUNCTION>
<NAME>base_exit</NAME>
<RETURNS>void     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BOUNDARY_HALF_WAY</NAME>
#define BOUNDARY_HALF_WAY 127
</MACRO>
<ENUM>
<NAME>BoundaryType</NAME>
typedef enum
{
  BOUNDARY_WITHIN_BOUNDS,
  BOUNDARY_IGNORE_BOUNDS
} BoundaryType;
</ENUM>
<STRUCT>
<NAME>BoundSeg</NAME>
struct _BoundSeg
{
  gint     x1;
  gint     y1;
  gint     x2;
  gint     y2;
  guint    open : 1;
  guint    visited : 1;
};
</STRUCT>
<FUNCTION>
<NAME>boundary_find</NAME>
<RETURNS>BoundSeg *</RETURNS>
PixelRegion    *maskPR,BoundaryType    type,gint            x1,gint            y1,gint            x2,gint            y2,guchar          threshold,gint           *num_segs
</FUNCTION>
<FUNCTION>
<NAME>boundary_sort</NAME>
<RETURNS>BoundSeg *</RETURNS>
const BoundSeg *segs,gint            num_segs,gint           *num_groups
</FUNCTION>
<FUNCTION>
<NAME>boundary_simplify</NAME>
<RETURNS>BoundSeg *</RETURNS>
BoundSeg       *sorted_segs,gint            num_groups,gint           *num_segs
</FUNCTION>
<FUNCTION>
<NAME>brush_scale_mask</NAME>
<RETURNS>MaskBuf *</RETURNS>
MaskBuf *brush_mask,gint     dest_width,gint     dest_height
</FUNCTION>
<FUNCTION>
<NAME>brush_scale_pixmap</NAME>
<RETURNS>MaskBuf *</RETURNS>
MaskBuf *pixmap,gint     dest_width,gint     dest_height
</FUNCTION>
<STRUCT>
<NAME>ColorBalance</NAME>
struct _ColorBalance
{
  gboolean preserve_luminosity;

  gdouble  cyan_red[3];
  gdouble  magenta_green[3];
  gdouble  yellow_blue[3];

  guchar   r_lookup[256];
  guchar   g_lookup[256];
  guchar   b_lookup[256];
};
</STRUCT>
<FUNCTION>
<NAME>color_balance_init</NAME>
<RETURNS>void   </RETURNS>
ColorBalance     *cb
</FUNCTION>
<FUNCTION>
<NAME>color_balance_range_reset</NAME>
<RETURNS>void   </RETURNS>
ColorBalance     *cb,GimpTransferMode  range
</FUNCTION>
<FUNCTION>
<NAME>color_balance_create_lookup_tables</NAME>
<RETURNS>void   </RETURNS>
ColorBalance     *cb
</FUNCTION>
<FUNCTION>
<NAME>color_balance</NAME>
<RETURNS>void   </RETURNS>
ColorBalance     *cb,PixelRegion      *srcPR,PixelRegion      *destPR
</FUNCTION>
<STRUCT>
<NAME>Colorize</NAME>
struct _Colorize
{
  gdouble hue;
  gdouble saturation;
  gdouble lightness;

  gint    lum_red_lookup[256];
  gint    lum_green_lookup[256];
  gint    lum_blue_lookup[256];

  gint    final_red_lookup[256];
  gint    final_green_lookup[256];
  gint    final_blue_lookup[256];
};
</STRUCT>
<FUNCTION>
<NAME>colorize_init</NAME>
<RETURNS>void   </RETURNS>
Colorize      *colorize
</FUNCTION>
<FUNCTION>
<NAME>colorize_calculate</NAME>
<RETURNS>void   </RETURNS>
Colorize      *colorize
</FUNCTION>
<FUNCTION>
<NAME>colorize</NAME>
<RETURNS>void   </RETURNS>
Colorize      *colorize,PixelRegion   *srcPR,PixelRegion   *destPR
</FUNCTION>
<MACRO>
<NAME>CPU_ACCEL_X86_MMX</NAME>
#define CPU_ACCEL_X86_MMX        0x80000000
</MACRO>
<MACRO>
<NAME>CPU_ACCEL_X86_3DNOW</NAME>
#define CPU_ACCEL_X86_3DNOW      0x40000000
</MACRO>
<MACRO>
<NAME>CPU_ACCEL_X86_MMXEXT</NAME>
#define CPU_ACCEL_X86_MMXEXT     0x20000000
</MACRO>
<MACRO>
<NAME>CPU_ACCEL_X86_SSE</NAME>
#define CPU_ACCEL_X86_SSE        0x10000000
</MACRO>
<MACRO>
<NAME>CPU_ACCEL_X86_SSE2</NAME>
#define CPU_ACCEL_X86_SSE2       0x08000000
</MACRO>
<MACRO>
<NAME>CPU_ACCEL_X86_SSE3</NAME>
#define CPU_ACCEL_X86_SSE3       0x02000000
</MACRO>
<MACRO>
<NAME>CPU_ACCEL_PPC_ALTIVEC</NAME>
#define CPU_ACCEL_PPC_ALTIVEC    0x04000000
</MACRO>
<FUNCTION>
<NAME>cpu_accel</NAME>
<RETURNS>guint32  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cpu_accel_print_results</NAME>
<RETURNS>void     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>CURVES_NUM_POINTS</NAME>
#define CURVES_NUM_POINTS 17
</MACRO>
<STRUCT>
<NAME>Curves</NAME>
struct _Curves
{
  GimpCurveType curve_type[5];
  gint          points[5][CURVES_NUM_POINTS][2];
  guchar        curve[5][256];
};
</STRUCT>
<FUNCTION>
<NAME>curves_init</NAME>
<RETURNS>void    </RETURNS>
Curves               *curves
</FUNCTION>
<FUNCTION>
<NAME>curves_channel_reset</NAME>
<RETURNS>void    </RETURNS>
Curves               *curves,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>curves_calculate_curve</NAME>
<RETURNS>void    </RETURNS>
Curves               *curves,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>curves_lut_func</NAME>
<RETURNS>gfloat  </RETURNS>
Curves               *curves,gint                  nchannels,gint                  channel,gfloat                value
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_new</NAME>
<RETURNS>GimpHistogram *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_free</NAME>
<RETURNS>void            </RETURNS>
GimpHistogram        *histogram
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_calculate</NAME>
<RETURNS>void            </RETURNS>
GimpHistogram        *histogram,PixelRegion          *region,PixelRegion          *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_maximum</NAME>
<RETURNS>gdouble         </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_count</NAME>
<RETURNS>gdouble         </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel,gint                  start,gint                  end
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_mean</NAME>
<RETURNS>gdouble         </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel,gint                  start,gint                  end
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_median</NAME>
<RETURNS>gint            </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel,gint                  start,gint                  end
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_std_dev</NAME>
<RETURNS>gdouble         </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel,gint                  start,gint                  end
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_value</NAME>
<RETURNS>gdouble         </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel,gint                  bin
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_get_channel</NAME>
<RETURNS>gdouble         </RETURNS>
GimpHistogram        *histogram,GimpHistogramChannel  channel,gint                  bin
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_n_channels</NAME>
<RETURNS>gint            </RETURNS>
GimpHistogram        *histogram
</FUNCTION>
<STRUCT>
<NAME>GimpLut</NAME>
struct _GimpLut
{
  guchar **luts;
  gint     nchannels;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GimpLutFunc</NAME>
<RETURNS>gfloat </RETURNS>
gpointer user_data,
                               gint     nchannels,
                               gint     channel,
                               gfloat   value
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_lut_free</NAME>
<RETURNS>void      </RETURNS>
GimpLut     *lut
</FUNCTION>
<FUNCTION>
<NAME>gimp_lut_setup</NAME>
<RETURNS>void      </RETURNS>
GimpLut     *lut,GimpLutFunc  func,gpointer     user_data,gint         nchannels
</FUNCTION>
<FUNCTION>
<NAME>gimp_lut_setup_exact</NAME>
<RETURNS>void      </RETURNS>
GimpLut     *lut,GimpLutFunc  func,gpointer     user_data,gint         nchannels
</FUNCTION>
<FUNCTION>
<NAME>gimp_lut_process</NAME>
<RETURNS>void      </RETURNS>
GimpLut     *lut,PixelRegion *srcPR,PixelRegion *destPR
</FUNCTION>
<FUNCTION>
<NAME>gimp_lut_process_inline</NAME>
<RETURNS>void      </RETURNS>
GimpLut     *lut,PixelRegion *src_destPR
</FUNCTION>
<STRUCT>
<NAME>HueSaturation</NAME>
struct _HueSaturation
{
  gdouble hue[7];
  gdouble lightness[7];
  gdouble saturation[7];
  gdouble overlap;

  gint    hue_transfer[6][256];
  gint    lightness_transfer[6][256];
  gint    saturation_transfer[6][256];
};
</STRUCT>
<FUNCTION>
<NAME>hue_saturation_init</NAME>
<RETURNS>void   </RETURNS>
HueSaturation *hs
</FUNCTION>
<FUNCTION>
<NAME>hue_saturation_partition_reset</NAME>
<RETURNS>void   </RETURNS>
HueSaturation *hs,GimpHueRange   partition
</FUNCTION>
<FUNCTION>
<NAME>hue_saturation_calculate_transfers</NAME>
<RETURNS>void   </RETURNS>
HueSaturation *hs
</FUNCTION>
<FUNCTION>
<NAME>hue_saturation</NAME>
<RETURNS>void   </RETURNS>
HueSaturation *hs,PixelRegion   *srcPR,PixelRegion   *destPR
</FUNCTION>
<STRUCT>
<NAME>Levels</NAME>
struct _Levels
{
  gdouble gamma[5];

  gint    low_input[5];
  gint    high_input[5];

  gint    low_output[5];
  gint    high_output[5];

  guchar  input[5][256]; /* this is used only by the gui */
};
</STRUCT>
<FUNCTION>
<NAME>levels_init</NAME>
<RETURNS>void     </RETURNS>
Levels               *levels
</FUNCTION>
<FUNCTION>
<NAME>levels_channel_reset</NAME>
<RETURNS>void     </RETURNS>
Levels               *levels,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>levels_stretch</NAME>
<RETURNS>void     </RETURNS>
Levels               *levels,GimpHistogram        *hist,gboolean              is_color
</FUNCTION>
<FUNCTION>
<NAME>levels_channel_stretch</NAME>
<RETURNS>void     </RETURNS>
Levels               *levels,GimpHistogram        *hist,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>levels_adjust_by_colors</NAME>
<RETURNS>void     </RETURNS>
Levels               *levels,GimpHistogramChannel  channel,guchar               *black,guchar               *gray,guchar               *white
</FUNCTION>
<FUNCTION>
<NAME>levels_calculate_transfers</NAME>
<RETURNS>void     </RETURNS>
Levels               *levels
</FUNCTION>
<FUNCTION>
<NAME>levels_lut_func</NAME>
<RETURNS>gfloat   </RETURNS>
Levels               *levels,gint                  n_channels,gint                  channel,gfloat                value
</FUNCTION>
<FUNCTION>
<NAME>brightness_contrast_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
gdouble        brightness,gdouble        contrast,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>brightness_contrast_lut_setup</NAME>
<RETURNS>void      </RETURNS>
GimpLut       *lut,gdouble        brightness,gdouble        contrast,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>invert_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>add_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
gdouble        amount,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>intersect_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
gdouble        value,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>threshold_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
gdouble        value,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>posterize_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
gint           levels,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>posterize_lut_setup</NAME>
<RETURNS>void      </RETURNS>
GimpLut       *lut,gint           levels,gint           n_channels
</FUNCTION>
<FUNCTION>
<NAME>equalize_lut_new</NAME>
<RETURNS>GimpLut *</RETURNS>
GimpHistogram *histogram,gint           n_channels
</FUNCTION>
<MACRO>
<NAME>GIMP_MAX_NUM_THREADS</NAME>
#define GIMP_MAX_NUM_THREADS  16
</MACRO>
<USER_FUNCTION>
<NAME>PixelProcessorFunc</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>PixelProcessorProgressFunc</NAME>
<RETURNS>void </RETURNS>
gpointer  progress_data,
                                             gdouble   fraction
</USER_FUNCTION>
<FUNCTION>
<NAME>pixel_processor_init</NAME>
<RETURNS>void  </RETURNS>
gint num_threads
</FUNCTION>
<FUNCTION>
<NAME>pixel_processor_set_num_threads</NAME>
<RETURNS>void  </RETURNS>
gint num_threads
</FUNCTION>
<FUNCTION>
<NAME>pixel_processor_exit</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>pixel_regions_process_parallel</NAME>
<RETURNS>void  </RETURNS>
PixelProcessorFunc  func,gpointer            data,gint                num_regions,...
</FUNCTION>
<FUNCTION>
<NAME>pixel_regions_process_parallel_progress</NAME>
<RETURNS>void  </RETURNS>
PixelProcessorFunc          func,gpointer                    data,PixelProcessorProgressFunc  progress_func,gpointer                    progress_data,gint                        num_regions,...
</FUNCTION>
<STRUCT>
<NAME>PixelRegion</NAME>
struct _PixelRegion
{
  guchar      *data;           /*  pointer to region data        */
  TileManager *tiles;          /*  pointer to tiles              */
  Tile        *curtile;        /*  current tile                  */
  gint         offx;           /*  tile offsets                  */
  gint         offy;           /*  tile offsets                  */
  gint         rowstride;      /*  bytes per pixel row           */
  gint         x;              /*  origin                        */
  gint         y;              /*  origin                        */
  gint         w;              /*  width of region               */
  gint         h;              /*  height of region              */
  gint         bytes;          /*  bytes per pixel               */
  gboolean     dirty;          /*  will this region be dirtied?  */
  gint         process_count;  /*  used internally               */
};
</STRUCT>
<STRUCT>
<NAME>PixelRegionHolder</NAME>
struct _PixelRegionHolder
{
  PixelRegion *PR;
  guchar      *original_data;
  gint         startx;
  gint         starty;
  gint         count;
};
</STRUCT>
<STRUCT>
<NAME>PixelRegionIterator</NAME>
struct _PixelRegionIterator
{
  GSList *pixel_regions;
  gint    dirty_tiles;
  gint    region_width;
  gint    region_height;
  gint    portion_width;
  gint    portion_height;
  gint    process_count;
};
</STRUCT>
<FUNCTION>
<NAME>pixel_region_init</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,TileManager         *tiles,gint                 x,gint                 y,gint                 w,gint                 h,gboolean             dirty
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_init_temp_buf</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,TempBuf             *temp_buf,gint                 x,gint                 y,gint                 w,gint                 h
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_init_data</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,guchar              *data,gint                 bytes,gint                 rowstride,gint                 x,gint                 y,gint                 w,gint                 h
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_resize</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,gint                 x,gint                 y,gint                 w,gint                 h
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_get_async</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,gint                 ulx,gint                 uly,gint                 lrx,gint                 lry
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_get_row</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,gint                 x,gint                 y,gint                 w,guchar              *data,gint                 subsample
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_set_row</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,gint                 x,gint                 y,gint                 w,guchar              *data
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_get_col</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,gint                 x,gint                 y,gint                 h,guchar              *data,gint                 subsample
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_set_col</NAME>
<RETURNS>void     </RETURNS>
PixelRegion         *PR,gint                 x,gint                 y,gint                 h,guchar              *data
</FUNCTION>
<FUNCTION>
<NAME>pixel_region_has_alpha</NAME>
<RETURNS>gboolean </RETURNS>
PixelRegion         *PR
</FUNCTION>
<FUNCTION>
<NAME>pixel_regions_register</NAME>
<RETURNS>PixelRegionIterator *</RETURNS>
gint                 num_regions,...
</FUNCTION>
<FUNCTION>
<NAME>pixel_regions_process</NAME>
<RETURNS>PixelRegionIterator *</RETURNS>
PixelRegionIterator *PRI
</FUNCTION>
<FUNCTION>
<NAME>pixel_regions_process_stop</NAME>
<RETURNS>void                  </RETURNS>
PixelRegionIterator *PRI
</FUNCTION>
<FUNCTION>
<NAME>pixel_surround_init</NAME>
<RETURNS>void     </RETURNS>
PixelSurround *ps,TileManager   *tm,gint           w,gint           h,const guchar   bg[MAX_CHANNELS]
</FUNCTION>
<FUNCTION>
<NAME>pixel_surround_lock</NAME>
<RETURNS>guchar *</RETURNS>
PixelSurround *ps,gint           x,gint           y
</FUNCTION>
<FUNCTION>
<NAME>pixel_surround_rowstride</NAME>
<RETURNS>gint     </RETURNS>
PixelSurround *ps
</FUNCTION>
<FUNCTION>
<NAME>pixel_surround_release</NAME>
<RETURNS>void     </RETURNS>
PixelSurround *ps
</FUNCTION>
<FUNCTION>
<NAME>pixel_surround_clear</NAME>
<RETURNS>void     </RETURNS>
PixelSurround *ps
</FUNCTION>
<STRUCT>
<NAME>TempBuf</NAME>
struct _TempBuf
{
  gint    bytes;      /*  the necessary info                             */
  gint    width;
  gint    height;
  gint    x, y;       /*  origin of data source                          */
  guchar *data;       /*  The data buffer. Do never access this field
                          directly, use temp_buf_data() instead !!       */
};
</STRUCT>
<FUNCTION>
<NAME>temp_buf_new</NAME>
<RETURNS>TempBuf *</RETURNS>
gint           width,gint           height,gint           bytes,gint           x,gint           y,guchar        *col
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_new_check</NAME>
<RETURNS>TempBuf *</RETURNS>
gint           width,gint              height,GimpCheckType  check_type,GimpCheckSize  check_size
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_copy</NAME>
<RETURNS>TempBuf *</RETURNS>
TempBuf       *src,TempBuf       *dest
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_resize</NAME>
<RETURNS>TempBuf *</RETURNS>
TempBuf       *buf,gint           bytes,gint           x,gint           y,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_scale</NAME>
<RETURNS>TempBuf *</RETURNS>
TempBuf       *buf,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_copy_area</NAME>
<RETURNS>TempBuf *</RETURNS>
TempBuf       *src,TempBuf       *dest,gint           x,gint           y,gint           width,gint           height,gint           dest_x,gint           dest_y
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_free</NAME>
<RETURNS>void      </RETURNS>
TempBuf       *buf
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_data</NAME>
<RETURNS>guchar  *</RETURNS>
TempBuf       *buf
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_data_clear</NAME>
<RETURNS>guchar  *</RETURNS>
TempBuf       *buf
</FUNCTION>
<FUNCTION>
<NAME>temp_buf_get_memsize</NAME>
<RETURNS>gsize     </RETURNS>
TempBuf       *buf
</FUNCTION>
<FUNCTION>
<NAME>mask_buf_new</NAME>
<RETURNS>MaskBuf *</RETURNS>
gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>mask_buf_free</NAME>
<RETURNS>void      </RETURNS>
MaskBuf       *mask_buf
</FUNCTION>
<FUNCTION>
<NAME>mask_buf_data</NAME>
<RETURNS>guchar  *</RETURNS>
MaskBuf       *mask_buf
</FUNCTION>
<FUNCTION>
<NAME>mask_buf_data_clear</NAME>
<RETURNS>guchar  *</RETURNS>
MaskBuf       *mask_buf
</FUNCTION>
<STRUCT>
<NAME>Threshold</NAME>
struct _Threshold
{
  gboolean color;
  gint     low_threshold;
  gint     high_threshold;
};
</STRUCT>
<FUNCTION>
<NAME>threshold</NAME>
<RETURNS>void   </RETURNS>
Threshold   *tr,PixelRegion *srcPR,PixelRegion *destPR
</FUNCTION>
<FUNCTION>
<NAME>tile_cache_init</NAME>
<RETURNS>void   </RETURNS>
gulong  cache_size
</FUNCTION>
<FUNCTION>
<NAME>tile_cache_exit</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>tile_cache_set_size</NAME>
<RETURNS>void   </RETURNS>
gulong  cache_size
</FUNCTION>
<FUNCTION>
<NAME>tile_cache_insert</NAME>
<RETURNS>void   </RETURNS>
Tile   *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_cache_flush</NAME>
<RETURNS>void   </RETURNS>
Tile   *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_crop</NAME>
<RETURNS>TileManager *</RETURNS>
TileManager  *tiles,gint          border
</FUNCTION>
<STRUCT>
<NAME>TileManager</NAME>
struct _TileManager
{
  gint               ref_count;     /*  reference counter                    */

  gint               x, y;          /*  tile manager offsets                 */

  gint               width;         /*  the width of the tiled area          */
  gint               height;        /*  the height of the tiled area         */
  gint               bpp;           /*  the bpp of each tile                 */

  gint               ntile_rows;    /*  the number of tiles in each row      */
  gint               ntile_cols;    /*  the number of tiles in each columns  */

  Tile             **tiles;         /*  the tiles for this level             */
  TileValidateProc   validate_proc; /*  this proc is called when an attempt
                                     *  to get an invalid tile is made.
                                     */
  gint               cached_num;    /*  number of cached tile */
  Tile              *cached_tile;   /*  the actual cached tile */

  gpointer           user_data;     /*  hook for hanging data off of         */
};
</STRUCT>
<STRUCT>
<NAME>PixelDataHandlePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>PixelDataHandlePrivate</NAME>
struct _PixelDataHandlePrivate
{
  PixelDataHandle  public;
  TileManager     *tm;
  gint                   x1, x2, y1, y2;
  gboolean           readable;
  gboolean         writeable;
  gboolean         local_buffer;
  Tile            *tile;
};
</STRUCT>
<STRUCT>
<NAME>PixelDataHandle</NAME>
struct _PixelDataHandle
{
  guchar *data;
  gint    width;
  gint          height;
  gint    stride;
  gint          bpp;
};
</STRUCT>
<FUNCTION>
<NAME>tile_manager_new</NAME>
<RETURNS>TileManager *</RETURNS>
gint toplevel_width,gint toplevel_height,gint bpp
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_ref</NAME>
<RETURNS>TileManager *</RETURNS>
TileManager *tm
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_unref</NAME>
<RETURNS>void          </RETURNS>
TileManager *tm
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_set_validate_proc</NAME>
<RETURNS>void          </RETURNS>
TileManager      *tm,TileValidateProc  proc
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get_tile</NAME>
<RETURNS>Tile        *</RETURNS>
TileManager *tm,gint         xpixel,gint         ypixel,gint         wantread,gint         wantwrite
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get</NAME>
<RETURNS>Tile        *</RETURNS>
TileManager *tm,gint         tile_num,gint         wantread,gint         wantwrite
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get_async</NAME>
<RETURNS>void          </RETURNS>
TileManager *tm,gint         xpixel,gint         ypixel
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_map_tile</NAME>
<RETURNS>void          </RETURNS>
TileManager *tm,gint         xpixel,gint         ypixel,Tile        *srctile
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_map</NAME>
<RETURNS>void          </RETURNS>
TileManager *tm,gint         tile_num,Tile        *srctile
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_validate</NAME>
<RETURNS>void          </RETURNS>
TileManager  *tm,Tile         *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_invalidate</NAME>
<RETURNS>void          </RETURNS>
Tile        **tile_ptr,TileManager  *tm,gint          tile_num
</FUNCTION>
<FUNCTION>
<NAME>tile_invalidate_tile</NAME>
<RETURNS>void          </RETURNS>
Tile        **tile_ptr,TileManager  *tm,gint          xpixel,gint          ypixel
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_invalidate_tiles</NAME>
<RETURNS>void          </RETURNS>
TileManager       *tm,Tile              *toplevel_tile
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_set_user_data</NAME>
<RETURNS>void          </RETURNS>
TileManager       *tm,gpointer           user_data
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get_user_data</NAME>
<RETURNS>gpointer      </RETURNS>
const TileManager *tm
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_width</NAME>
<RETURNS>gint          </RETURNS>
const TileManager *tm
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_height</NAME>
<RETURNS>gint          </RETURNS>
const TileManager *tm
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_bpp</NAME>
<RETURNS>gint          </RETURNS>
const TileManager *tm
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get_offsets</NAME>
<RETURNS>void          </RETURNS>
const TileManager *tm,gint              *x,gint              *y
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_set_offsets</NAME>
<RETURNS>void          </RETURNS>
TileManager       *tm,gint               x,gint               y
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
const TileManager *tm,gboolean           sparse
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_get_tile_coordinates</NAME>
<RETURNS>void          </RETURNS>
TileManager *tm,Tile        *tile,gint        *x,gint        *y
</FUNCTION>
<FUNCTION>
<NAME>tile_manager_map_over_tile</NAME>
<RETURNS>void          </RETURNS>
TileManager *tm,Tile        *tile,Tile        *srctile
</FUNCTION>
<FUNCTION>
<NAME>request_pixel_data</NAME>
<RETURNS>PixelDataHandle *</RETURNS>
TileManager *tm,gint         x1,gint           y1,gint           x2,gint           y2,gboolean     wantread,gboolean     wantwrite
</FUNCTION>
<FUNCTION>
<NAME>release_pixel_data</NAME>
<RETURNS>void              </RETURNS>
PixelDataHandle *pdh
</FUNCTION>
<FUNCTION>
<NAME>read_pixel_data</NAME>
<RETURNS>void              </RETURNS>
TileManager  *tm,gint          x1,gint          y1,gint          x2,gint          y2,guchar       *buffer,guint         stride
</FUNCTION>
<FUNCTION>
<NAME>write_pixel_data</NAME>
<RETURNS>void              </RETURNS>
TileManager  *tm,gint          x1,gint          y1,gint          x2,gint          y2,const guchar *buffer,guint         stride
</FUNCTION>
<FUNCTION>
<NAME>read_pixel_data_1</NAME>
<RETURNS>void                  </RETURNS>
TileManager  *tm,gint            x,gint            y,guchar       *buffer
</FUNCTION>
<FUNCTION>
<NAME>write_pixel_data_1</NAME>
<RETURNS>void                  </RETURNS>
TileManager  *tm,gint            x,gint            y,const guchar *buffer
</FUNCTION>
<STRUCT>
<NAME>TileLink</NAME>
</STRUCT>
<STRUCT>
<NAME>TileLink</NAME>
struct _TileLink
{
  TileLink    *next;
  gint         tile_num; /* the number of this tile within the drawable */
  TileManager *tm;       /* A pointer to the tile manager for this tile.
                          *  We need this in order to call the tile managers
                          *  validate proc whenever the tile is referenced
                          *  yet invalid.
                          */
};
</STRUCT>
<STRUCT>
<NAME>Tile</NAME>
struct _Tile
{
  gshort  ref_count;    /* reference count. when the reference count is
                          *  non-zero then the "data" for this tile must
                         *  be valid. when the reference count for a tile
                         *  is 0 then the "data" for this tile must be
                         *  NULL.
                         */
  gshort  write_count;  /* write count: number of references that are
                           for write access */
  gshort  share_count;  /* share count: number of tile managers that
                           hold this tile */
  guint   dirty : 1;    /* is the tile dirty? has it been modified? */
  guint   valid : 1;    /* is the tile valid? */

  guchar  bpp;          /* the bytes per pixel (1, 2, 3 or 4) */
  gushort ewidth;       /* the effective width of the tile */
  gushort eheight;      /* the effective height of the tile
                         *  a tile's effective width and height may be smaller
                         *  (but not larger) than TILE_WIDTH and TILE_HEIGHT.
                         *  this is to handle edge tiles of a drawable.
                         */
  gint    size;         /* size of the tile data (ewidth * eheight * bpp) */

  TileRowHint *rowhint; /* An array of hints for rendering purposes */

  guchar *data;         /* the data for the tile. this may be NULL in which
                         *  case the tile data is on disk.
                         */

  gint    swap_num;     /* the index into the file table of the file to be used
                         * for swapping. swap_num 1 is always the global
                         * swap file.
                         */
  off_t   swap_offset;  /* the offset within the swap file of the tile data.
                         * if the tile data is in memory this will be set
                         * to -1.
                         */

  TileLink *tlink;

  Tile     *next;
  Tile     *prev;       /* List pointers for the tile cache lists */
  gpointer  listhead;   /* Pointer to the head of the list this tile is on */

#ifdef ENABLE_THREADED_TILE_SWAPPER
  GMutex   *mutex;
#endif
};
</STRUCT>
<MACRO>
<NAME>TILE_MUTEX_LOCK</NAME>
#define TILE_MUTEX_LOCK(tile)   g_mutex_lock((tile)->mutex)
</MACRO>
<MACRO>
<NAME>TILE_MUTEX_UNLOCK</NAME>
#define TILE_MUTEX_UNLOCK(tile) g_mutex_unlock((tile)->mutex)
</MACRO>
<MACRO>
<NAME>TILE_MUTEX_LOCK</NAME>
#define TILE_MUTEX_LOCK(tile)   /* nothing */
</MACRO>
<MACRO>
<NAME>TILE_MUTEX_UNLOCK</NAME>
#define TILE_MUTEX_UNLOCK(tile) /* nothing */
</MACRO>
<ENUM>
<NAME>SwapCommand</NAME>
typedef enum
{
  SWAP_IN = 1,
  SWAP_IN_ASYNC,
  SWAP_OUT,
  SWAP_DELETE,
  SWAP_COMPRESS
} SwapCommand;
</ENUM>
<USER_FUNCTION>
<NAME>SwapFunc</NAME>
<RETURNS>gint </RETURNS>
gint      fd,
                           Tile     *tile,
                           gint      cmd,
                           gpointer  user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>tile_swap_init</NAME>
<RETURNS>void     </RETURNS>
const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_exit</NAME>
<RETURNS>void     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_add</NAME>
<RETURNS>gint     </RETURNS>
gchar       *filename,SwapFunc     swap_func,gpointer     user_data
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_remove</NAME>
<RETURNS>void     </RETURNS>
gint         swap_num
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_in</NAME>
<RETURNS>void     </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_in_async</NAME>
<RETURNS>void     </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_out</NAME>
<RETURNS>void     </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_delete</NAME>
<RETURNS>void     </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_compress</NAME>
<RETURNS>void     </RETURNS>
gint         swap_num
</FUNCTION>
<FUNCTION>
<NAME>tile_swap_test</NAME>
<RETURNS>gboolean </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>TILE_WIDTH</NAME>
#define TILE_WIDTH   64
</MACRO>
<MACRO>
<NAME>TILE_HEIGHT</NAME>
#define TILE_HEIGHT  64
</MACRO>
<TYPEDEF>
<NAME>TileRowHint</NAME>
typedef guchar TileRowHint;
</TYPEDEF>
<MACRO>
<NAME>TILEROWHINT_UNKNOWN</NAME>
#define TILEROWHINT_UNKNOWN     0
</MACRO>
<MACRO>
<NAME>TILEROWHINT_OPAQUE</NAME>
#define TILEROWHINT_OPAQUE      1
</MACRO>
<MACRO>
<NAME>TILEROWHINT_TRANSPARENT</NAME>
#define TILEROWHINT_TRANSPARENT 2
</MACRO>
<MACRO>
<NAME>TILEROWHINT_MIXED</NAME>
#define TILEROWHINT_MIXED       3
</MACRO>
<MACRO>
<NAME>TILEROWHINT_OUTOFRANGE</NAME>
#define TILEROWHINT_OUTOFRANGE  4
</MACRO>
<MACRO>
<NAME>TILEROWHINT_UNDEFINED</NAME>
#define TILEROWHINT_UNDEFINED   5
</MACRO>
<MACRO>
<NAME>TILEROWHINT_BROKEN</NAME>
#define TILEROWHINT_BROKEN      6
</MACRO>
<FUNCTION>
<NAME>tile_init</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile,gint         bpp
</FUNCTION>
<FUNCTION>
<NAME>tile_lock</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_release</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile,gboolean     dirty
</FUNCTION>
<FUNCTION>
<NAME>tile_alloc</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_size</NAME>
<RETURNS>gint          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_ewidth</NAME>
<RETURNS>gint          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_eheight</NAME>
<RETURNS>gint          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_bpp</NAME>
<RETURNS>gint          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_is_valid</NAME>
<RETURNS>gboolean      </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_mark_valid</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_get_rowhint</NAME>
<RETURNS>TileRowHint   </RETURNS>
Tile        *tile,gint         yoff
</FUNCTION>
<FUNCTION>
<NAME>tile_set_rowhint</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile,gint         yoff,TileRowHint  rowhint
</FUNCTION>
<FUNCTION>
<NAME>tile_sanitize_rowhints</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile
</FUNCTION>
<FUNCTION>
<NAME>tile_data_pointer</NAME>
<RETURNS>void        *</RETURNS>
Tile        *tile,gint         xoff,gint         yoff
</FUNCTION>
<FUNCTION>
<NAME>tile_attach</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile,void        *tm,gint         tile_num
</FUNCTION>
<FUNCTION>
<NAME>tile_detach</NAME>
<RETURNS>void          </RETURNS>
Tile        *tile,void        *tm,gint         tile_num
</FUNCTION>
<MACRO>
<NAME>SIOX_DEFAULT_SMOOTHNESS</NAME>
#define SIOX_DEFAULT_SMOOTHNESS     3
</MACRO>
<MACRO>
<NAME>SIOX_DEFAULT_SENSITIVITY_L</NAME>
#define SIOX_DEFAULT_SENSITIVITY_L  0.64
</MACRO>
<MACRO>
<NAME>SIOX_DEFAULT_SENSITIVITY_A</NAME>
#define SIOX_DEFAULT_SENSITIVITY_A  1.28
</MACRO>
<MACRO>
<NAME>SIOX_DEFAULT_SENSITIVITY_B</NAME>
#define SIOX_DEFAULT_SENSITIVITY_B  2.56
</MACRO>
<MACRO>
<NAME>SIOX_DRB_ADD</NAME>
#define SIOX_DRB_ADD                0
</MACRO>
<MACRO>
<NAME>SIOX_DRB_SUBTRACT</NAME>
#define SIOX_DRB_SUBTRACT           1
</MACRO>
<USER_FUNCTION>
<NAME>SioxProgressFunc</NAME>
<RETURNS>void </RETURNS>
gpointer  progress_data,
                                   gdouble   fraction
</USER_FUNCTION>
<FUNCTION>
<NAME>siox_init</NAME>
<RETURNS>SioxState *</RETURNS>
TileManager        *pixels,const guchar       *colormap,gint                offset_x,gint                offset_y,gint                x,gint                y,gint                width,gint                height
</FUNCTION>
<FUNCTION>
<NAME>siox_foreground_extract</NAME>
<RETURNS>void        </RETURNS>
SioxState          *state,SioxRefinementType  refinement,TileManager        *mask,gint                x1,gint                y1,gint                x2,gint                y2,gint                smoothness,const gdouble       sensitivity[3],gboolean            multiblob,SioxProgressFunc    progress_callback,gpointer            progress_data
</FUNCTION>
<FUNCTION>
<NAME>siox_done</NAME>
<RETURNS>void        </RETURNS>
SioxState          *state
</FUNCTION>
<FUNCTION>
<NAME>siox_drb</NAME>
<RETURNS>void        </RETURNS>
SioxState          *state,TileManager        *mask,gint                x,gint                y,gint                brush_radius,gint                brush_mode,gfloat              threshold
</FUNCTION>
<FUNCTION>
<NAME>cpercep_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cpercep_rgb_to_space</NAME>
<RETURNS>void  </RETURNS>
double  inr,double  ing,double  inb,double *outr,double *outg,double *outb
</FUNCTION>
<FUNCTION>
<NAME>cpercep_space_to_rgb</NAME>
<RETURNS>void  </RETURNS>
double  inr,double  ing,double  inb,double *outr,double *outg,double *outb
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_generic_init</NAME>
<RETURNS>gboolean </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_generic_install</NAME>
<RETURNS>gboolean </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_addition_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_anti_erase_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_blend_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_burn_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_color_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
guchar       *dest,const guchar *color,guint         w,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_color_erase_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_color_only_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_convert_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_darken_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_difference_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_dissolve_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_divide_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_dodge_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_erase_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_grain_extract_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_grain_merge_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_hardlight_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_hue_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_lighten_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_multiply_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_normal_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_overlay_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_replace_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_saturation_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_scale_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_screen_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_softlight_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_subtract_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_swap_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_value_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_behind_any_any_any_generic</NAME>
<RETURNS>void </RETURNS>
GimpCompositeContext *ctx
</FUNCTION>
<ENUM>
<NAME>GimpPixelFormat</NAME>
typedef enum
{
  GIMP_PIXELFORMAT_V8,
  GIMP_PIXELFORMAT_VA8,
  GIMP_PIXELFORMAT_RGB8,
  GIMP_PIXELFORMAT_RGBA8,
  GIMP_PIXELFORMAT_ANY,
  GIMP_PIXELFORMAT_N
} GimpPixelFormat;
</ENUM>
<MACRO>
<NAME>GIMP_COMPOSITE_ALPHA_OPAQUE</NAME>
#define GIMP_COMPOSITE_ALPHA_OPAQUE      (-1)
</MACRO>
<MACRO>
<NAME>GIMP_COMPOSITE_ALPHA_TRANSPARENT</NAME>
#define GIMP_COMPOSITE_ALPHA_TRANSPARENT (0)
</MACRO>
<ENUM>
<NAME>GimpCompositeOperation</NAME>
typedef enum
{
  GIMP_COMPOSITE_NORMAL        = GIMP_NORMAL_MODE,
  GIMP_COMPOSITE_DISSOLVE      = GIMP_DISSOLVE_MODE,
  GIMP_COMPOSITE_BEHIND        = GIMP_BEHIND_MODE,
  GIMP_COMPOSITE_MULTIPLY      = GIMP_MULTIPLY_MODE,
  GIMP_COMPOSITE_SCREEN        = GIMP_SCREEN_MODE,
  GIMP_COMPOSITE_OVERLAY       = GIMP_OVERLAY_MODE,
  GIMP_COMPOSITE_DIFFERENCE    = GIMP_DIFFERENCE_MODE,
  GIMP_COMPOSITE_ADDITION      = GIMP_ADDITION_MODE,
  GIMP_COMPOSITE_SUBTRACT      = GIMP_SUBTRACT_MODE,
  GIMP_COMPOSITE_DARKEN        = GIMP_DARKEN_ONLY_MODE,
  GIMP_COMPOSITE_LIGHTEN       = GIMP_LIGHTEN_ONLY_MODE,
  GIMP_COMPOSITE_HUE           = GIMP_HUE_MODE,
  GIMP_COMPOSITE_SATURATION    = GIMP_SATURATION_MODE,
  GIMP_COMPOSITE_COLOR_ONLY    = GIMP_COLOR_MODE,
  GIMP_COMPOSITE_VALUE         = GIMP_VALUE_MODE,
  GIMP_COMPOSITE_DIVIDE        = GIMP_DIVIDE_MODE,
  GIMP_COMPOSITE_DODGE         = GIMP_DODGE_MODE,
  GIMP_COMPOSITE_BURN          = GIMP_BURN_MODE,
  GIMP_COMPOSITE_HARDLIGHT     = GIMP_HARDLIGHT_MODE,
  GIMP_COMPOSITE_SOFTLIGHT     = GIMP_SOFTLIGHT_MODE,
  GIMP_COMPOSITE_GRAIN_EXTRACT = GIMP_GRAIN_EXTRACT_MODE,
  GIMP_COMPOSITE_GRAIN_MERGE   = GIMP_GRAIN_MERGE_MODE,
  GIMP_COMPOSITE_COLOR_ERASE   = GIMP_COLOR_ERASE_MODE,
  GIMP_COMPOSITE_ERASE         = GIMP_ERASE_MODE,
  GIMP_COMPOSITE_REPLACE       = GIMP_REPLACE_MODE,
  GIMP_COMPOSITE_ANTI_ERASE    = GIMP_ANTI_ERASE_MODE,
  GIMP_COMPOSITE_BLEND,
  GIMP_COMPOSITE_SHADE,
  GIMP_COMPOSITE_SWAP,
  GIMP_COMPOSITE_SCALE,
  GIMP_COMPOSITE_CONVERT,
  GIMP_COMPOSITE_XOR,
  GIMP_COMPOSITE_N
} GimpCompositeOperation;
</ENUM>
<STRUCT>
<NAME>GimpCompositeOperationEffects</NAME>
struct GimpCompositeOperationEffects
{
  guchar affect_opacity;
  guchar increase_opacity;
  guchar decrease_opacity;
};
</STRUCT>
<STRUCT>
<NAME>GimpCompositeOptions</NAME>
struct GimpCompositeOptions
{
  gulong  bits;
};
</STRUCT>
<MACRO>
<NAME>GIMP_COMPOSITE_OPTION_USE</NAME>
#define GIMP_COMPOSITE_OPTION_USE           0x1
</MACRO>
<MACRO>
<NAME>GIMP_COMPOSITE_OPTION_NOEXTENSIONS</NAME>
#define GIMP_COMPOSITE_OPTION_NOEXTENSIONS  0x2
</MACRO>
<MACRO>
<NAME>GIMP_COMPOSITE_OPTION_VERBOSE</NAME>
#define GIMP_COMPOSITE_OPTION_VERBOSE       0x4
</MACRO>
<FUNCTION>
<NAME>gimp_composite_init</NAME>
<RETURNS>void          </RETURNS>
gboolean  be_verbose,gboolean  use_cpu_accel
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_dispatch</NAME>
<RETURNS>void          </RETURNS>
GimpCompositeContext   *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_context_print</NAME>
<RETURNS>void          </RETURNS>
GimpCompositeContext   *ctx
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_mode_astext</NAME>
<RETURNS>const gchar *</RETURNS>
GimpCompositeOperation  op
</FUNCTION>
<FUNCTION>
<NAME>gimp_composite_pixelformat_astext</NAME>
<RETURNS>const gchar *</RETURNS>
GimpPixelFormat         format
</FUNCTION>
<FUNCTION>
<NAME>void</NAME>
<RETURNS>extern </RETURNS>
*gimp_composite_function[GIMP_COMPOSITE_N][GIMP_PIXELFORMAT_N][GIMP_PIXELFORMAT_N][GIMP_PIXELFORMAT_N])(GimpCompositeContext *
</FUNCTION>
<STRUCT>
<NAME>GimpBaseConfig</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCoreConfig</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplayConfig</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGuiConfig</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPluginConfig</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRc</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpXmlParser</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplayOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGrid</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemplate</NAME>
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_BASE_CONFIG</NAME>
#define GIMP_TYPE_BASE_CONFIG            (gimp_base_config_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BASE_CONFIG</NAME>
#define GIMP_BASE_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BASE_CONFIG, GimpBaseConfig))
</MACRO>
<MACRO>
<NAME>GIMP_BASE_CONFIG_CLASS</NAME>
#define GIMP_BASE_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BASE_CONFIG, GimpBaseConfigClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BASE_CONFIG</NAME>
#define GIMP_IS_BASE_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BASE_CONFIG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BASE_CONFIG_CLASS</NAME>
#define GIMP_IS_BASE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BASE_CONFIG))
</MACRO>
<STRUCT>
<NAME>GimpBaseConfigClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBaseConfig</NAME>
struct _GimpBaseConfig
{
  GObject   parent_instance;

  gchar    *temp_path;
  gchar    *swap_path;
  guint     num_processors;
  guint64   tile_cache_size;
};
</STRUCT>
<STRUCT>
<NAME>GimpBaseConfigClass</NAME>
struct _GimpBaseConfigClass
{
  GObjectClass           parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_base_config_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpConfigDumpFormat</NAME>
typedef enum
{
  GIMP_CONFIG_DUMP_NONE,
  GIMP_CONFIG_DUMP_GIMPRC,
  GIMP_CONFIG_DUMP_GIMPRC_SYSTEM,
  GIMP_CONFIG_DUMP_GIMPRC_MANPAGE
} GimpConfigDumpFormat;
</ENUM>
<FUNCTION>
<NAME>gimp_config_dump</NAME>
<RETURNS>gboolean  </RETURNS>
GimpConfigDumpFormat  format
</FUNCTION>
<FUNCTION>
<NAME>gimp_config_file_copy</NAME>
<RETURNS>gboolean   </RETURNS>
const gchar  *source,const gchar  *dest,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_config_file_backup_on_error</NAME>
<RETURNS>gboolean   </RETURNS>
const gchar  *filename,const gchar  *name,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_config_connect</NAME>
<RETURNS>void   </RETURNS>
GObject     *a,GObject     *b,const gchar *property_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_config_connect_full</NAME>
<RETURNS>void   </RETURNS>
GObject     *a,GObject     *b,const gchar *property_name_a,const gchar *property_name_b
</FUNCTION>
<FUNCTION>
<NAME>gimp_config_disconnect</NAME>
<RETURNS>void   </RETURNS>
GObject     *a,GObject     *b
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CORE_CONFIG</NAME>
#define GIMP_TYPE_CORE_CONFIG            (gimp_core_config_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CORE_CONFIG</NAME>
#define GIMP_CORE_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CORE_CONFIG, GimpCoreConfig))
</MACRO>
<MACRO>
<NAME>GIMP_CORE_CONFIG_CLASS</NAME>
#define GIMP_CORE_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CORE_CONFIG, GimpCoreConfigClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CORE_CONFIG</NAME>
#define GIMP_IS_CORE_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CORE_CONFIG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CORE_CONFIG_CLASS</NAME>
#define GIMP_IS_CORE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CORE_CONFIG))
</MACRO>
<STRUCT>
<NAME>GimpCoreConfigClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCoreConfig</NAME>
struct _GimpCoreConfig
{
  GimpBaseConfig         parent_instance;

  GimpInterpolationType  interpolation_type;
  gchar                 *plug_in_path;
  gchar                 *module_path;
  gchar                 *interpreter_path;
  gchar                 *environ_path;
  gchar                 *brush_path;
  gchar                 *brush_path_writable;
  gchar                 *pattern_path;
  gchar                 *pattern_path_writable;
  gchar                 *palette_path;
  gchar                 *palette_path_writable;
  gchar                 *gradient_path;
  gchar                 *gradient_path_writable;
  gchar                 *font_path;
  gchar                 *font_path_writable;  /*  unused  */
  gchar                 *default_brush;
  gchar                 *default_pattern;
  gchar                 *default_palette;
  gchar                 *default_gradient;
  gchar                 *default_font;
  gboolean               global_brush;
  gboolean               global_pattern;
  gboolean               global_palette;
  gboolean               global_gradient;
  gboolean               global_font;
  GimpTemplate          *default_image;
  GimpGrid              *default_grid;
  gint                   levels_of_undo;
  guint64                undo_size;
  GimpViewSize           undo_preview_size;
  gint                   plug_in_history_size;
  gchar                 *plug_in_rc_path;
  gboolean               layer_previews;
  GimpViewSize           layer_preview_size;
  GimpThumbnailSize      thumbnail_size;
  guint64                thumbnail_filesize_limit;
  gboolean               install_cmap;
  gint                   min_colors;
  GimpColorConfig       *color_management;
  gboolean               save_document_history;
};
</STRUCT>
<STRUCT>
<NAME>GimpCoreConfigClass</NAME>
struct _GimpCoreConfigClass
{
  GimpBaseConfigClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_core_config_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_CONFIG_DEFAULT_IMAGE_TITLE_FORMAT</NAME>
#define GIMP_CONFIG_DEFAULT_IMAGE_TITLE_FORMAT  "%D*%f-%p.%i (%t, %L) %wx%h"
</MACRO>
<MACRO>
<NAME>GIMP_CONFIG_DEFAULT_IMAGE_STATUS_FORMAT</NAME>
#define GIMP_CONFIG_DEFAULT_IMAGE_STATUS_FORMAT "%n (%m)"
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_DISPLAY_CONFIG</NAME>
#define GIMP_TYPE_DISPLAY_CONFIG            (gimp_display_config_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_CONFIG</NAME>
#define GIMP_DISPLAY_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DISPLAY_CONFIG, GimpDisplayConfig))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_CONFIG_CLASS</NAME>
#define GIMP_DISPLAY_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DISPLAY_CONFIG, GimpDisplayConfigClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_CONFIG</NAME>
#define GIMP_IS_DISPLAY_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DISPLAY_CONFIG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_CONFIG_CLASS</NAME>
#define GIMP_IS_DISPLAY_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DISPLAY_CONFIG))
</MACRO>
<STRUCT>
<NAME>GimpDisplayConfigClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplayConfig</NAME>
struct _GimpDisplayConfig
{
  GimpCoreConfig      parent_instance;

  GimpCheckSize       transparency_size;
  GimpCheckType       transparency_type;
  gint                snap_distance;
  gint                marching_ants_speed;
  gboolean            resize_windows_on_zoom;
  gboolean            resize_windows_on_resize;
  gboolean            default_dot_for_dot;
  gboolean            initial_zoom_to_fit;
  gboolean            perfect_mouse;
  GimpCursorMode      cursor_mode;
  gboolean            cursor_updating;
  gboolean            show_brush_outline;
  gboolean            show_paint_tool_cursor;
  gchar              *image_title_format;
  gchar              *image_status_format;
  gboolean            confirm_on_close;
  gdouble             monitor_xres;
  gdouble             monitor_yres;
  gboolean            monitor_res_from_gdk;
  GimpViewSize        nav_preview_size;
  GimpDisplayOptions *default_view;
  GimpDisplayOptions *default_fullscreen_view;
  gboolean            activate_on_focus;
};
</STRUCT>
<STRUCT>
<NAME>GimpDisplayConfigClass</NAME>
struct _GimpDisplayConfigClass
{
  GimpCoreConfigClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_display_config_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_GUI_CONFIG</NAME>
#define GIMP_TYPE_GUI_CONFIG            (gimp_gui_config_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_GUI_CONFIG</NAME>
#define GIMP_GUI_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GUI_CONFIG, GimpGuiConfig))
</MACRO>
<MACRO>
<NAME>GIMP_GUI_CONFIG_CLASS</NAME>
#define GIMP_GUI_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GUI_CONFIG, GimpGuiConfigClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GUI_CONFIG</NAME>
#define GIMP_IS_GUI_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GUI_CONFIG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GUI_CONFIG_CLASS</NAME>
#define GIMP_IS_GUI_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GUI_CONFIG))
</MACRO>
<STRUCT>
<NAME>GimpGuiConfigClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGuiConfig</NAME>
struct _GimpGuiConfig
{
  GimpDisplayConfig    parent_instance;

  gint                 default_threshold;
  gboolean             move_tool_changes_active;
  gboolean             trust_dirty_flag;
  gboolean             save_device_status;
  gboolean             save_session_info;
  gboolean             restore_session;
  gboolean             save_tool_options;
  gboolean             show_tips;
  gboolean             show_tooltips;
  gboolean             tearoff_menus;
  gboolean             can_change_accels;
  gboolean             save_accels;
  gboolean             restore_accels;
  gboolean             menu_mnemonics;
  gint                 last_opened_size;
  guint64              max_new_image_size;
  gboolean             toolbox_color_area;
  gboolean             toolbox_foo_area;
  gboolean             toolbox_image_area;
  gchar               *theme_path;
  gchar               *theme;
  gboolean             use_help;
  gboolean             show_help_button;
  gchar               *help_locales;
  GimpHelpBrowserType  help_browser;
  gchar               *web_browser;
  GimpWindowHint       toolbox_window_hint;
  GimpWindowHint       dock_window_hint;
  gboolean             transient_docks;
  GimpCursorFormat     cursor_format;

  gint                 last_tip;  /* saved in sessionrc */
};
</STRUCT>
<STRUCT>
<NAME>GimpGuiConfigClass</NAME>
struct _GimpGuiConfigClass
{
  GimpDisplayConfigClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_gui_config_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PLUGIN_CONFIG</NAME>
#define GIMP_TYPE_PLUGIN_CONFIG            (gimp_plugin_config_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PLUGIN_CONFIG</NAME>
#define GIMP_PLUGIN_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PLUGIN_CONFIG, GimpPluginConfig))
</MACRO>
<MACRO>
<NAME>GIMP_PLUGIN_CONFIG_CLASS</NAME>
#define GIMP_PLUGIN_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PLUGIN_CONFIG, GimpPluginConfigClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PLUGIN_CONFIG</NAME>
#define GIMP_IS_PLUGIN_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PLUGIN_CONFIG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PLUGIN_CONFIG_CLASS</NAME>
#define GIMP_IS_PLUGIN_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PLUGIN_CONFIG))
</MACRO>
<STRUCT>
<NAME>GimpPluginConfigClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPluginConfig</NAME>
struct _GimpPluginConfig
{
  GimpGuiConfig       parent_instance;

  gchar              *fractalexplorer_path;
  gchar              *gfig_path;
  gchar              *gflare_path;
  gchar              *gimpressionist_path;
  gchar              *script_fu_path;
};
</STRUCT>
<STRUCT>
<NAME>GimpPluginConfigClass</NAME>
struct _GimpPluginConfigClass
{
  GimpGuiConfigClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_plugin_config_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_deserialize</NAME>
<RETURNS>gboolean  </RETURNS>
GimpConfig *config,GScanner   *scanner,gint        nest_level,gpointer    data
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_serialize</NAME>
<RETURNS>gboolean  </RETURNS>
GimpConfig       *config,GimpConfigWriter *writer,gpointer          data
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpConfigForeachFunc</NAME>
<RETURNS>void </RETURNS>
const gchar *key,
                                         const gchar *value,
                                         gpointer     user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_rc_add_unknown_token</NAME>
<RETURNS>void          </RETURNS>
GimpConfig            *config,const gchar           *key,const gchar           *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_lookup_unknown_token</NAME>
<RETURNS>const gchar *</RETURNS>
GimpConfig            *config,const gchar           *key
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_foreach_unknown_token</NAME>
<RETURNS>void          </RETURNS>
GimpConfig            *config,GimpConfigForeachFunc  func,gpointer               user_data
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_RC</NAME>
#define GIMP_TYPE_RC            (gimp_rc_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_RC</NAME>
#define GIMP_RC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_RC, GimpRc))
</MACRO>
<MACRO>
<NAME>GIMP_RC_CLASS</NAME>
#define GIMP_RC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_RC, GimpRcClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_RC</NAME>
#define GIMP_IS_RC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_RC))
</MACRO>
<MACRO>
<NAME>GIMP_IS_RC_CLASS</NAME>
#define GIMP_IS_RC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_RC))
</MACRO>
<STRUCT>
<NAME>GimpRcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRc</NAME>
struct _GimpRc
{
  GimpPluginConfig  parent_instance;

  gchar            *user_gimprc;
  gchar            *system_gimprc;
  gboolean          verbose;
  gboolean          autosave;
  guint             save_idle_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpRcClass</NAME>
struct _GimpRcClass
{
  GimpPluginConfigClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_rc_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_new</NAME>
<RETURNS>GimpRc  *</RETURNS>
const gchar *system_gimprc,const gchar *user_gimprc,gboolean     verbose
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_set_autosave</NAME>
<RETURNS>void      </RETURNS>
GimpRc      *gimprc,gboolean     autosave
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_save</NAME>
<RETURNS>void      </RETURNS>
GimpRc      *gimprc
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_query</NAME>
<RETURNS>gchar   *</RETURNS>
GimpRc      *rc,const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>gimp_rc_set_unknown_token</NAME>
<RETURNS>void      </RETURNS>
GimpRc      *rc,const gchar *token,const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_xml_parser_new</NAME>
<RETURNS>GimpXmlParser *</RETURNS>
const GMarkupParser *markup_parser,gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_xml_parser_parse_file</NAME>
<RETURNS>gboolean        </RETURNS>
GimpXmlParser       *parser,const gchar         *filename,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_xml_parser_parse_fd</NAME>
<RETURNS>gboolean        </RETURNS>
GimpXmlParser       *parser,gint                 fd,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_xml_parser_parse_io_channel</NAME>
<RETURNS>gboolean        </RETURNS>
GimpXmlParser       *parser,GIOChannel          *io,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_xml_parser_parse_buffer</NAME>
<RETURNS>gboolean        </RETURNS>
GimpXmlParser       *parser,const gchar         *buffer,gssize               len,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_xml_parser_free</NAME>
<RETURNS>void            </RETURNS>
GimpXmlParser       *parser
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_POLICY</NAME>
#define GIMP_TYPE_CONTAINER_POLICY (gimp_container_policy_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_container_policy_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpContainerPolicy</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_CONTAINER_POLICY_STRONG,
  GIMP_CONTAINER_POLICY_WEAK
} GimpContainerPolicy;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CONVERT_DITHER_TYPE</NAME>
#define GIMP_TYPE_CONVERT_DITHER_TYPE (gimp_convert_dither_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_convert_dither_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpConvertDitherType</NAME>
typedef enum
{
  GIMP_NO_DITHER,         /*< desc="None"                                     >*/
  GIMP_FS_DITHER,         /*< desc="Floyd-Steinberg (normal)"                 >*/
  GIMP_FSLOWBLEED_DITHER, /*< desc="Floyd-Steinberg (reduced color bleeding)" >*/
  GIMP_FIXED_DITHER,      /*< desc="Positioned"                               >*/
  GIMP_NODESTRUCT_DITHER  /*< pdb-skip, skip >*/
} GimpConvertDitherType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CONVERT_PALETTE_TYPE</NAME>
#define GIMP_TYPE_CONVERT_PALETTE_TYPE (gimp_convert_palette_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_convert_palette_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpConvertPaletteType</NAME>
typedef enum
{
  GIMP_MAKE_PALETTE,    /*< desc="Generate optimum palette"            >*/
  GIMP_REUSE_PALETTE,   /*< skip >*/
  GIMP_WEB_PALETTE,     /*< desc="Use web-optimized palette"           >*/
  GIMP_MONO_PALETTE,    /*< desc="Use black and white (1-bit) palette" >*/
  GIMP_CUSTOM_PALETTE   /*< desc="Use custom palette"                  >*/
} GimpConvertPaletteType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_GRAVITY_TYPE</NAME>
#define GIMP_TYPE_GRAVITY_TYPE (gimp_gravity_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_gravity_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpGravityType</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_GRAVITY_NONE,
  GIMP_GRAVITY_NORTH_WEST,
  GIMP_GRAVITY_NORTH,
  GIMP_GRAVITY_NORTH_EAST,
  GIMP_GRAVITY_WEST,
  GIMP_GRAVITY_CENTER,
  GIMP_GRAVITY_EAST,
  GIMP_GRAVITY_SOUTH_WEST,
  GIMP_GRAVITY_SOUTH,
  GIMP_GRAVITY_SOUTH_EAST
} GimpGravityType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_ALIGNMENT</NAME>
#define GIMP_TYPE_ALIGNMENT (gimp_alignment_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_alignment_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpAlignmentType</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_ALIGN_LEFT,
  GIMP_ALIGN_CENTER,
  GIMP_ALIGN_RIGHT,
  GIMP_ALIGN_TOP,
  GIMP_ALIGN_MIDDLE,
  GIMP_ALIGN_BOTTOM
} GimpAlignmentType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_FILL_TYPE</NAME>
#define GIMP_TYPE_FILL_TYPE (gimp_fill_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_fill_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpFillType</NAME>
typedef enum
{
  GIMP_FOREGROUND_FILL,   /*< desc="Foreground color" >*/
  GIMP_BACKGROUND_FILL,   /*< desc="Background color" >*/
  GIMP_WHITE_FILL,        /*< desc="White"            >*/
  GIMP_TRANSPARENT_FILL,  /*< desc="Transparency"     >*/
  GIMP_PATTERN_FILL,      /*< desc="Pattern"          >*/
  GIMP_NO_FILL            /*< desc="None",   pdb-skip >*/
} GimpFillType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_STROKE_METHOD</NAME>
#define GIMP_TYPE_STROKE_METHOD (gimp_stroke_method_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_stroke_method_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpStrokeMethod</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_STROKE_METHOD_LIBART,     /*< desc="Stroke line"              >*/
  GIMP_STROKE_METHOD_PAINT_CORE  /*< desc="Stroke with a paint tool" >*/
} GimpStrokeMethod;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_STROKE_STYLE</NAME>
#define GIMP_TYPE_STROKE_STYLE (gimp_stroke_style_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_stroke_style_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpStrokeStyle</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_STROKE_STYLE_SOLID,  /*< desc="Solid"   >*/
  GIMP_STROKE_STYLE_PATTERN /*< desc="Pattern" >*/
} GimpStrokeStyle;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_JOIN_STYLE</NAME>
#define GIMP_TYPE_JOIN_STYLE (gimp_join_style_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_join_style_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpJoinStyle</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_JOIN_MITER,  /*< desc="Miter" >*/
  GIMP_JOIN_ROUND,  /*< desc="Round" >*/
  GIMP_JOIN_BEVEL   /*< desc="Bevel" >*/
} GimpJoinStyle;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CAP_STYLE</NAME>
#define GIMP_TYPE_CAP_STYLE (gimp_cap_style_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_cap_style_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCapStyle</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_CAP_BUTT,   /*< desc="Butt"   >*/
  GIMP_CAP_ROUND,  /*< desc="Round"  >*/
  GIMP_CAP_SQUARE  /*< desc="Square" >*/
} GimpCapStyle;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_DASH_PRESET</NAME>
#define GIMP_TYPE_DASH_PRESET (gimp_dash_preset_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_dash_preset_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpDashPreset</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_DASH_CUSTOM,       /*< desc="Custom"         >*/
  GIMP_DASH_LINE,         /*< desc="Line"           >*/
  GIMP_DASH_LONG_DASH,    /*< desc="Long dashes"    >*/
  GIMP_DASH_MEDIUM_DASH,  /*< desc="Medium dashes"  >*/
  GIMP_DASH_SHORT_DASH,   /*< desc="Short dashes"   >*/
  GIMP_DASH_SPARSE_DOTS,  /*< desc="Sparse dots"    >*/
  GIMP_DASH_NORMAL_DOTS,  /*< desc="Normal dots"    >*/
  GIMP_DASH_DENSE_DOTS,   /*< desc="Dense dots"     >*/
  GIMP_DASH_STIPPLES,     /*< desc="Stipples"       >*/
  GIMP_DASH_DASH_DOT,     /*< desc="Dash, dot"      >*/
  GIMP_DASH_DASH_DOT_DOT  /*< desc="Dash, dot, dot" >*/
} GimpDashPreset;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_GENERATED_SHAPE</NAME>
#define GIMP_TYPE_BRUSH_GENERATED_SHAPE (gimp_brush_generated_shape_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_brush_generated_shape_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpBrushGeneratedShape</NAME>
typedef enum
{
  GIMP_BRUSH_GENERATED_CIRCLE,  /*< desc="Circle"  >*/
  GIMP_BRUSH_GENERATED_SQUARE,  /*< desc="Square"  >*/
  GIMP_BRUSH_GENERATED_DIAMOND  /*< desc="Diamond" >*/
} GimpBrushGeneratedShape;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_ORIENTATION_TYPE</NAME>
#define GIMP_TYPE_ORIENTATION_TYPE (gimp_orientation_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_orientation_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpOrientationType</NAME>
typedef enum
{
  GIMP_ORIENTATION_HORIZONTAL, /*< desc="Horizontal" >*/
  GIMP_ORIENTATION_VERTICAL,   /*< desc="Vertical"   >*/
  GIMP_ORIENTATION_UNKNOWN     /*< desc="Unknown"    >*/
} GimpOrientationType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_RESIZE_LAYERS</NAME>
#define GIMP_TYPE_IMAGE_RESIZE_LAYERS (gimp_image_resize_layers_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_image_resize_layers_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpImageResizeLayers</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_IMAGE_RESIZE_LAYERS_NONE,     /*< desc="None"               >*/
  GIMP_IMAGE_RESIZE_LAYERS_MATCHING, /*< desc="Image-sized layers" >*/
  GIMP_IMAGE_RESIZE_LAYERS_VISIBLE,  /*< desc="All visible layers" >*/
  GIMP_IMAGE_RESIZE_LAYERS_LINKED,   /*< desc="All linked layers"  >*/
  GIMP_IMAGE_RESIZE_LAYERS_ALL       /*< desc="All layers"         >*/
} GimpImageResizeLayers;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_ROTATION_TYPE</NAME>
#define GIMP_TYPE_ROTATION_TYPE (gimp_rotation_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_rotation_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpRotationType</NAME>
typedef enum
{
  GIMP_ROTATE_90,
  GIMP_ROTATE_180,
  GIMP_ROTATE_270
} GimpRotationType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_VIEW_SIZE</NAME>
#define GIMP_TYPE_VIEW_SIZE (gimp_view_size_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_view_size_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpViewSize</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_VIEW_SIZE_TINY        = 12,   /*< desc="Tiny"        >*/
  GIMP_VIEW_SIZE_EXTRA_SMALL = 16,   /*< desc="Very small"  >*/
  GIMP_VIEW_SIZE_SMALL       = 24,   /*< desc="Small"       >*/
  GIMP_VIEW_SIZE_MEDIUM      = 32,   /*< desc="Medium"      >*/
  GIMP_VIEW_SIZE_LARGE       = 48,   /*< desc="Large"       >*/
  GIMP_VIEW_SIZE_EXTRA_LARGE = 64,   /*< desc="Very large"  >*/
  GIMP_VIEW_SIZE_HUGE        = 96,   /*< desc="Huge"        >*/
  GIMP_VIEW_SIZE_ENORMOUS    = 128,  /*< desc="Enormous"    >*/
  GIMP_VIEW_SIZE_GIGANTIC    = 192   /*< desc="Gigantic"    >*/
} GimpViewSize;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_VIEW_TYPE</NAME>
#define GIMP_TYPE_VIEW_TYPE (gimp_view_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_view_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpViewType</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_VIEW_TYPE_LIST,  /*< desc="View as list" >*/
  GIMP_VIEW_TYPE_GRID   /*< desc="View as grid" >*/
} GimpViewType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_SELECTION_CONTROL</NAME>
#define GIMP_TYPE_SELECTION_CONTROL (gimp_selection_control_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_selection_control_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpSelectionControl</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_SELECTION_OFF,
  GIMP_SELECTION_LAYER_OFF,
  GIMP_SELECTION_ON,
  GIMP_SELECTION_PAUSE,
  GIMP_SELECTION_RESUME
} GimpSelectionControl;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_THUMBNAIL_SIZE</NAME>
#define GIMP_TYPE_THUMBNAIL_SIZE (gimp_thumbnail_size_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_thumbnail_size_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpThumbnailSize</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_THUMBNAIL_SIZE_NONE    = 0,    /*< desc="No thumbnails"    >*/
  GIMP_THUMBNAIL_SIZE_NORMAL  = 128,  /*< desc="Normal (128x128)" >*/
  GIMP_THUMBNAIL_SIZE_LARGE   = 256   /*< desc="Large (256x256)"  >*/
} GimpThumbnailSize;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_UNDO_MODE</NAME>
#define GIMP_TYPE_UNDO_MODE (gimp_undo_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_undo_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpUndoMode</NAME>
typedef enum /*< pdb-skip >*/
{
  GIMP_UNDO_MODE_UNDO,
  GIMP_UNDO_MODE_REDO
} GimpUndoMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_UNDO_EVENT</NAME>
#define GIMP_TYPE_UNDO_EVENT (gimp_undo_event_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_undo_event_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpUndoEvent</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_UNDO_EVENT_UNDO_PUSHED,  /* a new undo has been added to the undo stack */
  GIMP_UNDO_EVENT_UNDO_EXPIRED, /* an undo has been freed from the undo stack  */
  GIMP_UNDO_EVENT_REDO_EXPIRED, /* a redo has been freed from the redo stack   */
  GIMP_UNDO_EVENT_UNDO,         /* an undo has been executed                   */
  GIMP_UNDO_EVENT_REDO,         /* a redo has been executed                    */
  GIMP_UNDO_EVENT_UNDO_FREE,    /* all undo and redo info has been cleared     */
  GIMP_UNDO_EVENT_UNDO_FREEZE,  /* undo has been frozen                        */
  GIMP_UNDO_EVENT_UNDO_THAW     /* undo has been thawn                         */
} GimpUndoEvent;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_UNDO_TYPE</NAME>
#define GIMP_TYPE_UNDO_TYPE (gimp_undo_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_undo_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpUndoType</NAME>
typedef enum /*< pdb-skip >*/
{
  /* Type NO_UNDO_GROUP (0) is special - in the gimpimage structure it
   * means there is no undo group currently being added to.
   */
  GIMP_UNDO_GROUP_NONE = 0,           /*< desc="<<invalid>>"                 >*/

  GIMP_UNDO_GROUP_FIRST = GIMP_UNDO_GROUP_NONE, /*< skip >*/

  GIMP_UNDO_GROUP_IMAGE_SCALE,        /*< desc="Scale image"                 >*/
  GIMP_UNDO_GROUP_IMAGE_RESIZE,       /*< desc="Resize image"                >*/
  GIMP_UNDO_GROUP_IMAGE_FLIP,         /*< desc="Flip image"                  >*/
  GIMP_UNDO_GROUP_IMAGE_ROTATE,       /*< desc="Rotate image"                >*/
  GIMP_UNDO_GROUP_IMAGE_CROP,         /*< desc="Crop image"                  >*/
  GIMP_UNDO_GROUP_IMAGE_CONVERT,      /*< desc="Convert image"               >*/
  GIMP_UNDO_GROUP_IMAGE_ITEM_REMOVE,  /*< desc="Remove item"                 >*/
  GIMP_UNDO_GROUP_IMAGE_LAYERS_MERGE, /*< desc="Merge layers"                >*/
  GIMP_UNDO_GROUP_IMAGE_VECTORS_MERGE,/*< desc="Merge paths"                 >*/
  GIMP_UNDO_GROUP_IMAGE_QUICK_MASK,   /*< desc="Quick Mask"                  >*/
  GIMP_UNDO_GROUP_IMAGE_GUIDE,        /*< desc="Guide"                       >*/
  GIMP_UNDO_GROUP_IMAGE_GRID,         /*< desc="Grid"                        >*/
  GIMP_UNDO_GROUP_IMAGE_SAMPLE_POINT, /*< desc="Sample Point"                >*/
  GIMP_UNDO_GROUP_DRAWABLE,           /*< desc="Layer/Channel"               >*/
  GIMP_UNDO_GROUP_DRAWABLE_MOD,       /*< desc="Layer/Channel modification"  >*/
  GIMP_UNDO_GROUP_MASK,               /*< desc="Selection mask"              >*/
  GIMP_UNDO_GROUP_ITEM_VISIBILITY,    /*< desc="Item visibility"             >*/
  GIMP_UNDO_GROUP_ITEM_LINKED,        /*< desc="Link/Unlink item"            >*/
  GIMP_UNDO_GROUP_ITEM_PROPERTIES,    /*< desc="Item properties"             >*/
  GIMP_UNDO_GROUP_ITEM_DISPLACE,      /*< desc="Move item"                   >*/
  GIMP_UNDO_GROUP_ITEM_SCALE,         /*< desc="Scale item"                  >*/
  GIMP_UNDO_GROUP_ITEM_RESIZE,        /*< desc="Resize item"                 >*/
  GIMP_UNDO_GROUP_LAYER_ADD_MASK,     /*< desc="Add layer mask"              >*/
  GIMP_UNDO_GROUP_LAYER_APPLY_MASK,   /*< desc="Apply layer mask"            >*/
  GIMP_UNDO_GROUP_FS_TO_LAYER,        /*< desc="Floating selection to layer" >*/
  GIMP_UNDO_GROUP_FS_FLOAT,           /*< desc="Float selection"             >*/
  GIMP_UNDO_GROUP_FS_ANCHOR,          /*< desc="Anchor floating selection"   >*/
  GIMP_UNDO_GROUP_FS_REMOVE,          /*< desc="Remove floating selection"   >*/
  GIMP_UNDO_GROUP_EDIT_PASTE,         /*< desc="Paste"                       >*/
  GIMP_UNDO_GROUP_EDIT_CUT,           /*< desc="Cut"                         >*/
  GIMP_UNDO_GROUP_TEXT,               /*< desc="Text"                        >*/
  GIMP_UNDO_GROUP_TRANSFORM,          /*< desc="Transform"                   >*/
  GIMP_UNDO_GROUP_PAINT,              /*< desc="Paint"                       >*/
  GIMP_UNDO_GROUP_PARASITE_ATTACH,    /*< desc="Attach parasite"             >*/
  GIMP_UNDO_GROUP_PARASITE_REMOVE,    /*< desc="Remove parasite"             >*/
  GIMP_UNDO_GROUP_VECTORS_IMPORT,     /*< desc="Import paths"                >*/
  GIMP_UNDO_GROUP_MISC,               /*< desc="Plug-In"                     >*/

  GIMP_UNDO_GROUP_LAST = GIMP_UNDO_GROUP_MISC, /*< skip >*/

  /*  Undo types which actually do something  */

  GIMP_UNDO_IMAGE_TYPE,               /*< desc="Image type"                  >*/
  GIMP_UNDO_IMAGE_SIZE,               /*< desc="Image size"                  >*/
  GIMP_UNDO_IMAGE_RESOLUTION,         /*< desc="Image resolution change"     >*/
  GIMP_UNDO_IMAGE_GUIDE,              /*< desc="Guide"                       >*/
  GIMP_UNDO_IMAGE_GRID,               /*< desc="Grid"                        >*/
  GIMP_UNDO_IMAGE_SAMPLE_POINT,       /*< desc="Sample Point"                >*/
  GIMP_UNDO_IMAGE_COLORMAP,           /*< desc="Change indexed palette"      >*/
  GIMP_UNDO_DRAWABLE,                 /*< desc="Layer/Channel"               >*/
  GIMP_UNDO_DRAWABLE_MOD,             /*< desc="Layer/Channel modification"  >*/
  GIMP_UNDO_MASK,                     /*< desc="Selection mask"              >*/
  GIMP_UNDO_ITEM_RENAME,              /*< desc="Rename item"                 >*/
  GIMP_UNDO_ITEM_DISPLACE,            /*< desc="Move item"                   >*/
  GIMP_UNDO_ITEM_VISIBILITY,          /*< desc="Item visibility"             >*/
  GIMP_UNDO_ITEM_LINKED,              /*< desc="Link/Unlink item"            >*/
  GIMP_UNDO_LAYER_ADD,                /*< desc="New layer"                   >*/
  GIMP_UNDO_LAYER_REMOVE,             /*< desc="Delete layer"                >*/
  GIMP_UNDO_LAYER_REPOSITION,         /*< desc="Reposition layer"            >*/
  GIMP_UNDO_LAYER_MODE,               /*< desc="Set layer mode"              >*/
  GIMP_UNDO_LAYER_OPACITY,            /*< desc="Set layer opacity"           >*/
  GIMP_UNDO_LAYER_LOCK_ALPHA,         /*< desc="Lock/Unlock alpha channel"   >*/
  GIMP_UNDO_TEXT_LAYER,               /*< desc="Text layer"                  >*/
  GIMP_UNDO_TEXT_LAYER_MODIFIED,      /*< desc="Text layer modification"     >*/
  GIMP_UNDO_LAYER_MASK_ADD,           /*< desc="Add layer mask"              >*/
  GIMP_UNDO_LAYER_MASK_REMOVE,        /*< desc="Delete layer mask"           >*/
  GIMP_UNDO_LAYER_MASK_APPLY,         /*< desc="Apply layer mask"            >*/
  GIMP_UNDO_LAYER_MASK_SHOW,          /*< desc="Show layer mask"             >*/
  GIMP_UNDO_CHANNEL_ADD,              /*< desc="New channel"                 >*/
  GIMP_UNDO_CHANNEL_REMOVE,           /*< desc="Delete channel"              >*/
  GIMP_UNDO_CHANNEL_REPOSITION,       /*< desc="Reposition channel"          >*/
  GIMP_UNDO_CHANNEL_COLOR,            /*< desc="Channel color"               >*/
  GIMP_UNDO_VECTORS_ADD,              /*< desc="New path"                    >*/
  GIMP_UNDO_VECTORS_REMOVE,           /*< desc="Delete path"                 >*/
  GIMP_UNDO_VECTORS_MOD,              /*< desc="Path modification"           >*/
  GIMP_UNDO_VECTORS_REPOSITION,       /*< desc="Reposition path"             >*/
  GIMP_UNDO_FS_TO_LAYER,              /*< desc="Floating selection to layer" >*/
  GIMP_UNDO_FS_RIGOR,                 /*< desc="FS rigor"                    >*/
  GIMP_UNDO_FS_RELAX,                 /*< desc="FS relax"                    >*/
  GIMP_UNDO_TRANSFORM,                /*< desc="Transform"                   >*/
  GIMP_UNDO_PAINT,                    /*< desc="Paint"                       >*/
  GIMP_UNDO_INK,                      /*< desc="Ink"                         >*/
  GIMP_UNDO_FOREGROUND_SELECT,        /*< desc="Select foreground"           >*/
  GIMP_UNDO_PARASITE_ATTACH,          /*< desc="Attach parasite"             >*/
  GIMP_UNDO_PARASITE_REMOVE,          /*< desc="Remove parasite"             >*/

  GIMP_UNDO_CANT                      /*< desc="EEK: can't undo"             >*/
} GimpUndoType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_DIRTY_MASK</NAME>
#define GIMP_TYPE_DIRTY_MASK (gimp_dirty_mask_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_dirty_mask_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpDirtyMask</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_DIRTY_NONE            = 0,

  GIMP_DIRTY_IMAGE           = 1 << 0,
  GIMP_DIRTY_IMAGE_SIZE      = 1 << 1,
  GIMP_DIRTY_IMAGE_META      = 1 << 2,
  GIMP_DIRTY_IMAGE_STRUCTURE = 1 << 3,
  GIMP_DIRTY_ITEM            = 1 << 4,
  GIMP_DIRTY_ITEM_META       = 1 << 5,
  GIMP_DIRTY_DRAWABLE        = 1 << 6,
  GIMP_DIRTY_VECTORS         = 1 << 7,
  GIMP_DIRTY_SELECTION       = 1 << 8,

  GIMP_DIRTY_ALL             = 0xffff
} GimpDirtyMask;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_OFFSET_TYPE</NAME>
#define GIMP_TYPE_OFFSET_TYPE (gimp_offset_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_offset_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpOffsetType</NAME>
typedef enum
{
  GIMP_OFFSET_BACKGROUND,
  GIMP_OFFSET_TRANSPARENT
} GimpOffsetType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_GRADIENT_SEGMENT_TYPE</NAME>
#define GIMP_TYPE_GRADIENT_SEGMENT_TYPE (gimp_gradient_segment_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_gradient_segment_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpGradientSegmentType</NAME>
typedef enum
{
  GIMP_GRADIENT_SEGMENT_LINEAR,
  GIMP_GRADIENT_SEGMENT_CURVED,
  GIMP_GRADIENT_SEGMENT_SINE,
  GIMP_GRADIENT_SEGMENT_SPHERE_INCREASING,
  GIMP_GRADIENT_SEGMENT_SPHERE_DECREASING
} GimpGradientSegmentType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_GRADIENT_SEGMENT_COLOR</NAME>
#define GIMP_TYPE_GRADIENT_SEGMENT_COLOR (gimp_gradient_segment_color_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_gradient_segment_color_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpGradientSegmentColor</NAME>
typedef enum
{
  GIMP_GRADIENT_SEGMENT_RGB,      /* normal RGB           */
  GIMP_GRADIENT_SEGMENT_HSV_CCW,  /* counterclockwise hue */
  GIMP_GRADIENT_SEGMENT_HSV_CW    /* clockwise hue        */
} GimpGradientSegmentColor;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_MASK_APPLY_MODE</NAME>
#define GIMP_TYPE_MASK_APPLY_MODE (gimp_mask_apply_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_mask_apply_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpMaskApplyMode</NAME>
typedef enum
{
  GIMP_MASK_APPLY,
  GIMP_MASK_DISCARD
} GimpMaskApplyMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_MERGE_TYPE</NAME>
#define GIMP_TYPE_MERGE_TYPE (gimp_merge_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_merge_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpMergeType</NAME>
typedef enum
{
  GIMP_EXPAND_AS_NECESSARY,
  GIMP_CLIP_TO_IMAGE,
  GIMP_CLIP_TO_BOTTOM_LAYER,
  GIMP_FLATTEN_IMAGE
} GimpMergeType;
</ENUM>
<ENUM>
<NAME>GimpContextPropType</NAME>
typedef enum  /*< pdb-skip, skip >*/
{
  GIMP_CONTEXT_FIRST_PROP      =  2,

  GIMP_CONTEXT_PROP_IMAGE      =  GIMP_CONTEXT_FIRST_PROP,
  GIMP_CONTEXT_PROP_DISPLAY    =  3,
  GIMP_CONTEXT_PROP_TOOL       =  4,
  GIMP_CONTEXT_PROP_PAINT_INFO =  5,
  GIMP_CONTEXT_PROP_FOREGROUND =  6,
  GIMP_CONTEXT_PROP_BACKGROUND =  7,
  GIMP_CONTEXT_PROP_OPACITY    =  8,
  GIMP_CONTEXT_PROP_PAINT_MODE =  9,
  GIMP_CONTEXT_PROP_BRUSH      = 10,
  GIMP_CONTEXT_PROP_PATTERN    = 11,
  GIMP_CONTEXT_PROP_GRADIENT   = 12,
  GIMP_CONTEXT_PROP_PALETTE    = 13,
  GIMP_CONTEXT_PROP_FONT       = 14,
  GIMP_CONTEXT_PROP_BUFFER     = 15,
  GIMP_CONTEXT_PROP_IMAGEFILE  = 16,
  GIMP_CONTEXT_PROP_TEMPLATE   = 17,

  GIMP_CONTEXT_LAST_PROP       = GIMP_CONTEXT_PROP_TEMPLATE
} GimpContextPropType;
</ENUM>
<ENUM>
<NAME>GimpContextPropMask</NAME>
typedef enum  /*< pdb-skip, skip >*/
{
  GIMP_CONTEXT_IMAGE_MASK      = 1 <<  2,
  GIMP_CONTEXT_DISPLAY_MASK    = 1 <<  3,
  GIMP_CONTEXT_TOOL_MASK       = 1 <<  4,
  GIMP_CONTEXT_PAINT_INFO_MASK = 1 <<  5,
  GIMP_CONTEXT_FOREGROUND_MASK = 1 <<  6,
  GIMP_CONTEXT_BACKGROUND_MASK = 1 <<  7,
  GIMP_CONTEXT_OPACITY_MASK    = 1 <<  8,
  GIMP_CONTEXT_PAINT_MODE_MASK = 1 <<  9,
  GIMP_CONTEXT_BRUSH_MASK      = 1 << 10,
  GIMP_CONTEXT_PATTERN_MASK    = 1 << 11,
  GIMP_CONTEXT_GRADIENT_MASK   = 1 << 12,
  GIMP_CONTEXT_PALETTE_MASK    = 1 << 13,
  GIMP_CONTEXT_FONT_MASK       = 1 << 14,
  GIMP_CONTEXT_BUFFER_MASK     = 1 << 15,
  GIMP_CONTEXT_IMAGEFILE_MASK  = 1 << 16,
  GIMP_CONTEXT_TEMPLATE_MASK   = 1 << 17,

  /*  aliases  */
  GIMP_CONTEXT_PAINT_PROPS_MASK = (GIMP_CONTEXT_FOREGROUND_MASK |
                                   GIMP_CONTEXT_BACKGROUND_MASK |
                                   GIMP_CONTEXT_OPACITY_MASK    |
                                   GIMP_CONTEXT_PAINT_MODE_MASK |
                                   GIMP_CONTEXT_BRUSH_MASK      |
                                   GIMP_CONTEXT_PATTERN_MASK    |
                                   GIMP_CONTEXT_GRADIENT_MASK),
  GIMP_CONTEXT_ALL_PROPS_MASK   = (GIMP_CONTEXT_IMAGE_MASK      |
                                   GIMP_CONTEXT_DISPLAY_MASK    |
                                   GIMP_CONTEXT_TOOL_MASK       |
                                   GIMP_CONTEXT_PAINT_INFO_MASK |
                                   GIMP_CONTEXT_PALETTE_MASK    |
                                   GIMP_CONTEXT_FONT_MASK       |
                                   GIMP_CONTEXT_BUFFER_MASK     |
                                   GIMP_CONTEXT_IMAGEFILE_MASK  |
                                   GIMP_CONTEXT_TEMPLATE_MASK   |
                                   GIMP_CONTEXT_PAINT_PROPS_MASK)
} GimpContextPropMask;
</ENUM>
<ENUM>
<NAME>GimpImageScaleCheckType</NAME>
typedef enum  /*< pdb-skip, skip >*/
{
  GIMP_IMAGE_SCALE_OK,
  GIMP_IMAGE_SCALE_TOO_SMALL,
  GIMP_IMAGE_SCALE_TOO_BIG
} GimpImageScaleCheckType;
</ENUM>
<MACRO>
<NAME>GIMP_OPACITY_TRANSPARENT</NAME>
#define GIMP_OPACITY_TRANSPARENT      0.0
</MACRO>
<MACRO>
<NAME>GIMP_OPACITY_OPAQUE</NAME>
#define GIMP_OPACITY_OPAQUE           1.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_MIN_PRESSURE</NAME>
#define GIMP_COORDS_MIN_PRESSURE      0.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_MAX_PRESSURE</NAME>
#define GIMP_COORDS_MAX_PRESSURE      1.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_DEFAULT_PRESSURE</NAME>
#define GIMP_COORDS_DEFAULT_PRESSURE  1.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_MIN_TILT</NAME>
#define GIMP_COORDS_MIN_TILT         -1.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_MAX_TILT</NAME>
#define GIMP_COORDS_MAX_TILT          1.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_DEFAULT_TILT</NAME>
#define GIMP_COORDS_DEFAULT_TILT      0.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_MIN_WHEEL</NAME>
#define GIMP_COORDS_MIN_WHEEL         0.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_MAX_WHEEL</NAME>
#define GIMP_COORDS_MAX_WHEEL         1.0
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_DEFAULT_WHEEL</NAME>
#define GIMP_COORDS_DEFAULT_WHEEL     0.5
</MACRO>
<MACRO>
<NAME>GIMP_COORDS_DEFAULT_VALUES</NAME>
#define GIMP_COORDS_DEFAULT_VALUES  { 0.0, 0.0, \
                                      GIMP_COORDS_DEFAULT_PRESSURE, \
                                      GIMP_COORDS_DEFAULT_TILT,     \
                                      GIMP_COORDS_DEFAULT_TILT,     \
                                      GIMP_COORDS_DEFAULT_WHEEL }
</MACRO>
<STRUCT>
<NAME>GimpObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpItem</NAME>
</STRUCT>
<STRUCT>
<NAME>Gimp</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImage</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpList</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDocumentList</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStrokeOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpData</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrush</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushGenerated</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushPipe</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradient</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPattern</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPalette</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDrawable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpChannel</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSelection</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLayerMask</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpItemUndo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndoStack</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndoAccumulator</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEnvironTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImagefile</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageMap</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpInterpreterDB</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParasiteList</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPdbProgress</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProjection</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStrokeDesc</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPickable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProgress</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpArea</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCoords</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradientSegment</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGuide</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSamplePoint</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpTattoo</NAME>
typedef         guint32             GimpTattoo;
</TYPEDEF>
<STRUCT>
<NAME>GimpPaletteEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPlugInDebug</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpScanConvert</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GimpInitStatusFunc</NAME>
<RETURNS>void </RETURNS>
const gchar         *text1,
                                             const gchar         *text2,
                                             gdouble              percentage
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpObjectFilterFunc</NAME>
<RETURNS>gboolean </RETURNS>
const GimpObject    *object,
                                             gpointer             user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpUndoPopFunc</NAME>
<RETURNS>gboolean </RETURNS>
GimpUndo            *undo,
                                             GimpUndoMode         undo_mode,
                                             GimpUndoAccumulator *accum
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpUndoFreeFunc</NAME>
<RETURNS>void </RETURNS>
GimpUndo            *undo,
                                             GimpUndoMode         undo_mode
</USER_FUNCTION>
<STRUCT>
<NAME>GimpCoords</NAME>
struct _GimpCoords
{
  gdouble x;
  gdouble y;
  gdouble pressure;
  gdouble xtilt;
  gdouble ytilt;
  gdouble wheel;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_documents_load</NAME>
<RETURNS>void  </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_documents_save</NAME>
<RETURNS>void  </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_cut</NAME>
<RETURNS>const GimpBuffer *</RETURNS>
GimpImage    *image,GimpDrawable *drawable,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_copy</NAME>
<RETURNS>const GimpBuffer *</RETURNS>
GimpImage    *image,GimpDrawable *drawable,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_copy_visible</NAME>
<RETURNS>const GimpBuffer *</RETURNS>
GimpImage    *image,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_paste</NAME>
<RETURNS>GimpLayer        *</RETURNS>
GimpImage    *image,GimpDrawable *drawable,GimpBuffer   *paste,gboolean      paste_into,gint          viewport_x,gint          viewport_y,gint          viewport_width,gint          viewport_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_paste_as_new</NAME>
<RETURNS>GimpImage        *</RETURNS>
Gimp         *gimp,GimpImage    *image,GimpBuffer   *paste
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_named_cut</NAME>
<RETURNS>const gchar      *</RETURNS>
GimpImage    *image,const gchar  *name,GimpDrawable *drawable,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_named_copy</NAME>
<RETURNS>const gchar      *</RETURNS>
GimpImage    *image,const gchar  *name,GimpDrawable *drawable,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_named_copy_visible</NAME>
<RETURNS>const gchar      *</RETURNS>
GimpImage    *image,const gchar  *name,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_clear</NAME>
<RETURNS>gboolean           </RETURNS>
GimpImage    *image,GimpDrawable *drawable,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_fill</NAME>
<RETURNS>gboolean           </RETURNS>
GimpImage    *image,GimpDrawable *drawable,GimpContext  *context,GimpFillType  fill_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradients_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<STRUCT>
<NAME>GimpGui</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGui</NAME>
struct _GimpGui
{
  void           (* threads_enter)       (Gimp                *gimp);
  void           (* threads_leave)       (Gimp                *gimp);

  void           (* set_busy)            (Gimp                *gimp);
  void           (* unset_busy)          (Gimp                *gimp);

  void           (* message)             (Gimp                *gimp,
                                          const gchar         *domain,
                                          const gchar         *message);
  void           (* help)                (Gimp                *gimp,
                                          const gchar         *help_domain,
                                          const gchar         *help_id);

  const gchar  * (* get_program_class)   (Gimp                *gimp);
  gchar        * (* get_display_name)    (Gimp                *gimp,
                                          gint                 display_ID,
                                          gint                *monitor_number);
  const gchar  * (* get_theme_dir)       (Gimp                *gimp);

  GimpObject   * (* display_get_by_id)   (Gimp                *gimp,
                                          gint                 ID);
  gint           (* display_get_id)      (GimpObject          *display);
  guint32        (* display_get_window)  (GimpObject          *display);
  GimpObject   * (* display_create)      (GimpImage           *image,
                                          GimpUnit             unit,
                                          gdouble              scale);
  void           (* display_delete)      (GimpObject          *display);
  void           (* displays_reconnect)  (Gimp                *gimp,
                                          GimpImage           *old_image,
                                          GimpImage           *new_image);

  void           (* menus_init)          (Gimp                *gimp,
                                          GSList              *plug_in_defs,
                                          const gchar         *std_domain);
  void           (* menus_create_item)   (Gimp                *gimp,
                                          GimpPlugInProcedure *proc,
                                          const gchar         *menu_path);
  void           (* menus_delete_item)   (Gimp                *gimp,
                                          GimpPlugInProcedure *proc);
  void           (* menus_create_branch) (Gimp                *gimp,
                                          const gchar         *progname,
                                          const gchar         *menu_path,
                                          const gchar         *menu_label);

  GimpProgress * (* progress_new)        (Gimp                *gimp,
                                          GimpObject          *display);
  void           (* progress_free)       (Gimp                *gimp,
                                          GimpProgress        *progress);

  gboolean       (* pdb_dialog_new)      (Gimp                *gimp,
                                          GimpContext         *context,
                                          GimpContainer       *container,
                                          const gchar         *title,
                                          const gchar         *callback_name,
                                          const gchar         *object_name,
                                          va_list              args);
  gboolean       (* pdb_dialog_set)      (Gimp                *gimp,
                                          GimpContainer       *container,
                                          const gchar         *callback_name,
                                          const gchar         *object_name,
                                          va_list              args);
  gboolean       (* pdb_dialog_close)    (Gimp                *gimp,
                                          GimpContainer       *container,
                                          const gchar         *callback_name);
  void           (* pdb_dialogs_check)   (Gimp                *gimp);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_gui_init</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_threads_enter</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_threads_leave</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_display_by_ID</NAME>
<RETURNS>GimpObject   *</RETURNS>
Gimp                *gimp,gint                 ID
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_display_ID</NAME>
<RETURNS>gint           </RETURNS>
Gimp                *gimp,GimpObject          *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_display_window</NAME>
<RETURNS>guint32        </RETURNS>
Gimp                *gimp,GimpObject          *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_create_display</NAME>
<RETURNS>GimpObject   *</RETURNS>
Gimp                *gimp,GimpImage           *image,GimpUnit             unit,gdouble              scale
</FUNCTION>
<FUNCTION>
<NAME>gimp_delete_display</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GimpObject          *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_reconnect_displays</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GimpImage           *old_image,GimpImage           *new_image
</FUNCTION>
<FUNCTION>
<NAME>gimp_set_busy</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_set_busy_until_idle</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_unset_busy</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_message</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,const gchar         *domain,const gchar         *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_help</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,const gchar         *help_domain,const gchar         *help_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_menus_init</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GSList              *plug_in_defs,const gchar         *std_plugins_domain
</FUNCTION>
<FUNCTION>
<NAME>gimp_menus_create_item</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GimpPlugInProcedure *proc,const gchar         *menu_path
</FUNCTION>
<FUNCTION>
<NAME>gimp_menus_delete_item</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_menus_create_branch</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,const gchar         *progname,const gchar         *menu_path,const gchar         *menu_label
</FUNCTION>
<FUNCTION>
<NAME>gimp_new_progress</NAME>
<RETURNS>GimpProgress *</RETURNS>
Gimp                *gimp,GimpObject          *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_free_progress</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GimpProgress        *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_program_class</NAME>
<RETURNS>const gchar  *</RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_display_name</NAME>
<RETURNS>gchar        *</RETURNS>
Gimp                *gimp,gint                 display_ID,gint                *monitor_number
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_theme_dir</NAME>
<RETURNS>const gchar  *</RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialog_new</NAME>
<RETURNS>gboolean       </RETURNS>
Gimp                *gimp,GimpContext         *context,GimpContainer       *container,const gchar         *title,const gchar         *callback_name,const gchar         *object_name,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialog_set</NAME>
<RETURNS>gboolean       </RETURNS>
Gimp                *gimp,GimpContainer       *container,const gchar         *callback_name,const gchar         *object_name,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialog_close</NAME>
<RETURNS>gboolean       </RETURNS>
Gimp                *gimp,GimpContainer       *container,const gchar         *callback_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialogs_check</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_modules_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_modules_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_modules_load</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_modules_unload</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_modules_refresh</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_attach</NAME>
<RETURNS>void                  </RETURNS>
Gimp               *gimp,const GimpParasite *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_detach</NAME>
<RETURNS>void                  </RETURNS>
Gimp               *gimp,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_find</NAME>
<RETURNS>const GimpParasite  *</RETURNS>
Gimp               *gimp,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list</NAME>
<RETURNS>gchar              **</RETURNS>
Gimp               *gimp,gint               *count
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_shift_parent</NAME>
<RETURNS>void                  </RETURNS>
GimpParasite       *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasiterc_load</NAME>
<RETURNS>void                  </RETURNS>
Gimp               *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasiterc_save</NAME>
<RETURNS>void                  </RETURNS>
Gimp               *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_templates_load</NAME>
<RETURNS>void  </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_templates_save</NAME>
<RETURNS>void  </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_templates_migrate</NAME>
<RETURNS>void  </RETURNS>
const gchar *olddir
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_flip</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,GimpOrientationType  flip_type,gdouble              axis
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_flip_free</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,gint                 x,gint                 y,gint                 width,gint                 height,gdouble              x1,gdouble              y1,gdouble              x2,gdouble              y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_rotate</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,GimpRotationType     rotate_type,gdouble              center_x,gdouble              center_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_rotate_rect</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,gint                 x,gint                 y,gint                 width,gint                 height,gdouble              angle
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_rotate_center</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,gdouble              center_x,gdouble              center_y,gdouble              angle
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_scale</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,gint                 x,gint                 y,gint                 width,gint                 height,gdouble              t_x,gdouble              t_y,gdouble              t_width,gdouble              t_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_shear</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,gint                 x,gint                 y,gint                 width,gint                 height,GimpOrientationType  orientation,gdouble              amount
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_matrix_perspective</NAME>
<RETURNS>void   </RETURNS>
GimpMatrix3         *matrix,gint                 x,gint                 y,gint                 width,gint                 height,gdouble              t_x1,gdouble              t_y1,gdouble              t_x2,gdouble              t_y2,gdouble              t_x3,gdouble              t_y3,gdouble              t_x4,gdouble              t_y4
</FUNCTION>
<FUNCTION>
<NAME>gimp_units_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_units_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_unitrc_load</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_unitrc_save</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_intersect</NAME>
<RETURNS>gboolean      </RETURNS>
gint           x1,gint           y1,gint           width1,gint           height1,gint           x2,gint           y2,gint           width2,gint           height2,gint          *dest_x,gint          *dest_y,gint          *dest_width,gint          *dest_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_type_instance_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GTypeInstance *instance
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_object_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GObject       *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_hash_table_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GHashTable    *hash
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_slist_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GSList        *slist,gint64         data_size
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_list_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GList         *list,gint64         data_size
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_value_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GValue        *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_g_param_spec_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GParamSpec    *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_default_language</NAME>
<RETURNS>gchar       *</RETURNS>
const gchar   *category
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_default_unit</NAME>
<RETURNS>GimpUnit      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_boolean_handled_accum</NAME>
<RETURNS>gboolean      </RETURNS>
GSignalInvocationHint *ihint,GValue        *return_accu,const GValue  *handler_return,gpointer       dummy
</FUNCTION>
<FUNCTION>
<NAME>gimp_parameters_append</NAME>
<RETURNS>GParameter  *</RETURNS>
GType          object_type,GParameter    *params,gint          *n_params,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_parameters_append_valist</NAME>
<RETURNS>GParameter  *</RETURNS>
GType          object_type,GParameter    *params,gint          *n_params,va_list        args
</FUNCTION>
<FUNCTION>
<NAME>gimp_parameters_free</NAME>
<RETURNS>void          </RETURNS>
GParameter    *params,gint           n_params
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_array_truncate</NAME>
<RETURNS>void          </RETURNS>
GValueArray   *args,gint           n_values
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_temp_filename</NAME>
<RETURNS>gchar       *</RETURNS>
Gimp          *gimp,const gchar   *extension
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_GIMP</NAME>
#define GIMP_TYPE_GIMP            (gimp_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP</NAME>
#define GIMP(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GIMP, Gimp))
</MACRO>
<MACRO>
<NAME>GIMP_CLASS</NAME>
#define GIMP_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GIMP, GimpClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GIMP</NAME>
#define GIMP_IS_GIMP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GIMP))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GIMP_CLASS</NAME>
#define GIMP_IS_GIMP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GIMP))
</MACRO>
<STRUCT>
<NAME>GimpClass</NAME>
</STRUCT>
<STRUCT>
<NAME>Gimp</NAME>
struct _Gimp
{
  GimpObject              parent_instance;

  GimpCoreConfig         *config;
  GimpCoreConfig         *edit_config; /* don't use this one, it's just
                                        * for the preferences dialog
                                        */
  gchar                  *session_name;

  gboolean                be_verbose;
  gboolean                no_data;
  gboolean                no_fonts;
  gboolean                no_interface;
  gboolean                use_shm;
  GimpMessageHandlerType  message_handler;
  gboolean                console_messages;
  GimpStackTraceMode      stack_trace_mode;
  GimpPDBCompatMode       pdb_compat_mode;

  GimpGui                 gui; /* gui vtable */

  gint                    busy;
  guint                   busy_idle_id;

  GList                  *user_units;
  gint                    n_user_units;

  GimpParasiteList       *parasites;

  GimpContainer          *paint_info_list;
  GimpPaintInfo          *standard_paint_info;

  GimpModuleDB           *module_db;
  gboolean                write_modulerc;

  GSList                 *plug_in_defs;
  gboolean                write_pluginrc;

  GSList                 *plug_in_procedures;
  GSList                 *plug_in_menu_branches;
  GSList                 *plug_in_locale_domains;
  GSList                 *plug_in_help_domains;

  PlugIn                 *current_plug_in;
  GSList                 *open_plug_ins;
  GSList                 *plug_in_stack;
  GSList                 *last_plug_ins;

  PlugInShm              *plug_in_shm;
  GimpInterpreterDB      *interpreter_db;
  GimpEnvironTable       *environ_table;
  GimpPlugInDebug        *plug_in_debug;
  GList                  *plug_in_data_list;

  GimpContainer          *images;
  gint                    next_image_ID;
  guint32                 next_guide_ID;
  guint32                 next_sample_point_ID;
  GHashTable             *image_table;

  gint                    next_item_ID;
  GHashTable             *item_table;

  GimpContainer          *displays;
  gint                    next_display_ID;

  GimpBuffer             *global_buffer;
  GimpContainer          *named_buffers;

  GimpContainer          *fonts;

  GimpDataFactory        *brush_factory;
  GimpDataFactory        *pattern_factory;
  GimpDataFactory        *gradient_factory;
  GimpDataFactory        *palette_factory;

  GHashTable             *procedural_ht;
  GHashTable             *procedural_compat_ht;

  GSList                 *load_procs;
  GSList                 *save_procs;

  GimpContainer          *tool_info_list;
  GimpToolInfo           *standard_tool_info;

  /*  the opened and saved images in MRU order  */
  GimpContainer          *documents;

  /*  image_new values  */
  GimpContainer          *templates;
  GimpTemplate           *image_new_last_template;

  /*  the list of all contexts  */
  GList                  *context_list;

  /*  the default context which is initialized from gimprc  */
  GimpContext            *default_context;

  /*  the context used by the interface  */
  GimpContext            *user_context;
};
</STRUCT>
<STRUCT>
<NAME>GimpClass</NAME>
struct _GimpClass
{
  GimpObjectClass  parent_class;

  void     (* initialize)            (Gimp               *gimp,
                                      GimpInitStatusFunc  status_callback);
  void     (* restore)               (Gimp               *gimp,
                                      GimpInitStatusFunc  status_callback);
  gboolean (* exit)                  (Gimp               *gimp,
                                      gboolean            force);

  void     (* buffer_changed)        (Gimp               *gimp);
  void     (* last_plug_ins_changed) (Gimp               *gimp);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_new</NAME>
<RETURNS>Gimp        *</RETURNS>
const gchar         *name,const gchar         *session_name,gboolean             be_verbose,gboolean             no_data,gboolean             no_fonts,gboolean             no_interface,gboolean             use_shm,gboolean             console_messages,GimpStackTraceMode   stack_trace_mode,GimpPDBCompatMode    pdb_compat_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_load_config</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,const gchar         *alternate_system_gimprc,const gchar         *alternate_gimprc
</FUNCTION>
<FUNCTION>
<NAME>gimp_initialize</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,GimpInitStatusFunc   status_callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_restore</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,GimpInitStatusFunc   status_callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_exit</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,gboolean             force
</FUNCTION>
<FUNCTION>
<NAME>gimp_set_global_buffer</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,GimpBuffer          *buffer
</FUNCTION>
<FUNCTION>
<NAME>gimp_set_last_plug_in</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,GimpPlugInProcedure *procedure
</FUNCTION>
<FUNCTION>
<NAME>gimp_create_image</NAME>
<RETURNS>GimpImage   *</RETURNS>
Gimp                *gimp,gint                 width,gint                 height,GimpImageBaseType    type,gboolean             attach_comment
</FUNCTION>
<FUNCTION>
<NAME>gimp_set_default_context</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,GimpContext         *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_default_context</NAME>
<RETURNS>GimpContext *</RETURNS>
Gimp                *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_set_user_context</NAME>
<RETURNS>void          </RETURNS>
Gimp                *gimp,GimpContext         *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_user_context</NAME>
<RETURNS>GimpContext *</RETURNS>
Gimp                *gimp
</FUNCTION>
<STRUCT>
<NAME>GimpArea</NAME>
struct _GimpArea
{
  gint x1, y1, x2, y2;   /*  area bounds  */
};
</STRUCT>
<FUNCTION>
<NAME>gimp_area_new</NAME>
<RETURNS>GimpArea *</RETURNS>
gint      x1,gint      y1,gint      x2,gint      y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_area_list_process</NAME>
<RETURNS>GSList   *</RETURNS>
GSList   *list,GimpArea *area
</FUNCTION>
<FUNCTION>
<NAME>gimp_area_list_free</NAME>
<RETURNS>GSList   *</RETURNS>
GSList   *list
</FUNCTION>
<MACRO>
<NAME>GBRUSH_FILE_VERSION</NAME>
#define GBRUSH_FILE_VERSION    2
</MACRO>
<MACRO>
<NAME>GBRUSH_MAGIC</NAME>
#define GBRUSH_MAGIC    (('G' << 24) + ('I' << 16) + ('M' << 8) + ('P' << 0))
</MACRO>
<STRUCT>
<NAME>BrushHeader</NAME>
</STRUCT>
<STRUCT>
<NAME>BrushHeader</NAME>
struct _BrushHeader
{
  guint32   header_size;  /*  header_size = sizeof (BrushHeader) + brush name  */
  guint32   version;      /*  brush file version #  */
  guint32   width;        /*  width of brush  */
  guint32   height;       /*  height of brush  */
  guint32   bytes;        /*  depth of brush in bytes--always 1 */
  guint32   magic_number; /*  GIMP brush magic number  */
  guint32   spacing;      /*  brush spacing  */
};
</STRUCT>
<MACRO>
<NAME>GIMP_BRUSH_FILE_EXTENSION</NAME>
#define GIMP_BRUSH_FILE_EXTENSION        ".gbr"
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_PIXMAP_FILE_EXTENSION</NAME>
#define GIMP_BRUSH_PIXMAP_FILE_EXTENSION ".gpb"
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_PS_FILE_EXTENSION</NAME>
#define GIMP_BRUSH_PS_FILE_EXTENSION     ".abr"
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_PSP_FILE_EXTENSION</NAME>
#define GIMP_BRUSH_PSP_FILE_EXTENSION    ".jbr"
</MACRO>
<FUNCTION>
<NAME>gimp_brush_load</NAME>
<RETURNS>GList     *</RETURNS>
const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_load_brush</NAME>
<RETURNS>GimpBrush *</RETURNS>
gint          fd,const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_load_abr</NAME>
<RETURNS>GList     *</RETURNS>
const gchar  *filename,GError      **error
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BRUSH</NAME>
#define GIMP_TYPE_BRUSH            (gimp_brush_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH</NAME>
#define GIMP_BRUSH(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH, GimpBrush))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_CLASS</NAME>
#define GIMP_BRUSH_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH, GimpBrushClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH</NAME>
#define GIMP_IS_BRUSH(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_CLASS</NAME>
#define GIMP_IS_BRUSH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_GET_CLASS</NAME>
#define GIMP_BRUSH_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH, GimpBrushClass))
</MACRO>
<STRUCT>
<NAME>GimpBrushClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrush</NAME>
struct _GimpBrush
{
  GimpData      parent_instance;

  TempBuf      *mask;       /*  the actual mask                */
  TempBuf      *pixmap;     /*  optional pixmap data           */

  gint          spacing;    /*  brush's spacing                */
  GimpVector2   x_axis;     /*  for calculating brush spacing  */
  GimpVector2   y_axis;     /*  for calculating brush spacing  */
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushClass</NAME>
struct _GimpBrushClass
{
  GimpDataClass parent_class;

  /*  virtual functions  */
  GimpBrush * (* select_brush)     (GimpBrush  *brush,
                                    GimpCoords *last_coords,
                                    GimpCoords *cur_coords);
  gboolean    (* want_null_motion) (GimpBrush  *brush,
                                    GimpCoords *last_coords,
                                    GimpCoords *cur_coords);

  /*  signals  */
  void        (* spacing_changed)  (GimpBrush  *brush);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_new</NAME>
<RETURNS>GimpData  *</RETURNS>
const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_get_standard</NAME>
<RETURNS>GimpData  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_select_brush</NAME>
<RETURNS>GimpBrush *</RETURNS>
GimpBrush        *brush,GimpCoords       *last_coords,GimpCoords       *cur_coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_want_null_motion</NAME>
<RETURNS>gboolean    </RETURNS>
GimpBrush        *brush,GimpCoords       *last_coords,GimpCoords       *cur_coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_get_mask</NAME>
<RETURNS>TempBuf   *</RETURNS>
const GimpBrush  *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_get_pixmap</NAME>
<RETURNS>TempBuf   *</RETURNS>
const GimpBrush  *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_get_spacing</NAME>
<RETURNS>gint        </RETURNS>
const GimpBrush  *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_set_spacing</NAME>
<RETURNS>void        </RETURNS>
GimpBrush        *brush,gint              spacing
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_spacing_changed</NAME>
<RETURNS>void        </RETURNS>
GimpBrush        *brush
</FUNCTION>
<MACRO>
<NAME>GIMP_BRUSH_GENERATED_FILE_EXTENSION</NAME>
#define GIMP_BRUSH_GENERATED_FILE_EXTENSION ".vbr"
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_GENERATED</NAME>
#define GIMP_TYPE_BRUSH_GENERATED            (gimp_brush_generated_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_GENERATED</NAME>
#define GIMP_BRUSH_GENERATED(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH_GENERATED, GimpBrushGenerated))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_GENERATED_CLASS</NAME>
#define GIMP_BRUSH_GENERATED_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH_GENERATED, GimpBrushGeneratedClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_GENERATED</NAME>
#define GIMP_IS_BRUSH_GENERATED(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH_GENERATED))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_GENERATED_CLASS</NAME>
#define GIMP_IS_BRUSH_GENERATED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH_GENERATED))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_GENERATED_GET_CLASS</NAME>
#define GIMP_BRUSH_GENERATED_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH_GENERATED, GimpBrushGeneratedClass))
</MACRO>
<STRUCT>
<NAME>GimpBrushGeneratedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushGenerated</NAME>
struct _GimpBrushGenerated
{
  GimpBrush               parent_instance;

  GimpBrushGeneratedShape shape;
  gfloat                  radius;
  gint                    spikes;       /* 2 - 20     */
  gfloat                  hardness;     /* 0.0 - 1.0  */
  gfloat                  aspect_ratio; /* y/x        */
  gfloat                  angle;        /* in degrees */
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushGeneratedClass</NAME>
struct _GimpBrushGeneratedClass
{
  GimpBrushClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_generated_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_new</NAME>
<RETURNS>GimpData  *</RETURNS>
const gchar *name,GimpBrushGeneratedShape  shape,gfloat       radius,gint         spikes,gfloat       hardness,gfloat       aspect_ratio,gfloat       angle
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_load</NAME>
<RETURNS>GList     *</RETURNS>
const gchar *file_name,GError     **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_set_shape</NAME>
<RETURNS>GimpBrushGeneratedShape</RETURNS>
GimpBrushGenerated      *brush,GimpBrushGeneratedShape  shape
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_set_radius</NAME>
<RETURNS>gfloat  </RETURNS>
GimpBrushGenerated      *brush,gfloat                   radius
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_set_spikes</NAME>
<RETURNS>gint    </RETURNS>
GimpBrushGenerated      *brush,gint                     spikes
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_set_hardness</NAME>
<RETURNS>gfloat  </RETURNS>
GimpBrushGenerated      *brush,gfloat                   hardness
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_set_aspect_ratio</NAME>
<RETURNS>gfloat  </RETURNS>
GimpBrushGenerated      *brush,gfloat                   ratio
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_set_angle</NAME>
<RETURNS>gfloat  </RETURNS>
GimpBrushGenerated      *brush,gfloat                   angle
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_get_shape</NAME>
<RETURNS>GimpBrushGeneratedShape</RETURNS>
const GimpBrushGenerated *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_get_radius</NAME>
<RETURNS>gfloat  </RETURNS>
const GimpBrushGenerated *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_get_spikes</NAME>
<RETURNS>gint    </RETURNS>
const GimpBrushGenerated *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_get_hardness</NAME>
<RETURNS>gfloat  </RETURNS>
const GimpBrushGenerated *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_get_aspect_ratio</NAME>
<RETURNS>gfloat  </RETURNS>
const GimpBrushGenerated *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_generated_get_angle</NAME>
<RETURNS>gfloat  </RETURNS>
const GimpBrushGenerated *brush
</FUNCTION>
<MACRO>
<NAME>GIMP_BRUSH_PIPE_FILE_EXTENSION</NAME>
#define GIMP_BRUSH_PIPE_FILE_EXTENSION ".gih"
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_PIPE</NAME>
#define GIMP_TYPE_BRUSH_PIPE            (gimp_brush_pipe_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_PIPE</NAME>
#define GIMP_BRUSH_PIPE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH_PIPE, GimpBrushPipe))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_PIPE_CLASS</NAME>
#define GIMP_BRUSH_PIPE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH_PIPE, GimpBrushPipeClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_PIPE</NAME>
#define GIMP_IS_BRUSH_PIPE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH_PIPE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_PIPE_CLASS</NAME>
#define GIMP_IS_BRUSH_PIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH_PIPE))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_PIPE_GET_CLASS</NAME>
#define GIMP_BRUSH_PIPE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH_PIPE, GimpBrushPipeClass))
</MACRO>
<ENUM>
<NAME>PipeSelectModes</NAME>
typedef enum
{
  PIPE_SELECT_CONSTANT,
  PIPE_SELECT_INCREMENTAL,
  PIPE_SELECT_ANGULAR,
  PIPE_SELECT_VELOCITY,
  PIPE_SELECT_RANDOM,
  PIPE_SELECT_PRESSURE,
  PIPE_SELECT_TILT_X,
  PIPE_SELECT_TILT_Y
} PipeSelectModes;
</ENUM>
<STRUCT>
<NAME>GimpBrushPipeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushPipe</NAME>
struct _GimpBrushPipe
{
  GimpBrush         parent_instance;

  gint              dimension;
  gint             *rank;        /* Size in each dimension */
  gint             *stride;        /* Aux for indexing */
  PipeSelectModes  *select;        /* One mode per dimension */

  gint             *index;        /* Current index for incremental dimensions */

  gint              nbrushes;        /* Might be less than the product of the
                                 * ranks in some odd special case */
  GimpBrush       **brushes;
  GimpBrush        *current;    /* Currently selected brush */
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushPipeClass</NAME>
struct _GimpBrushPipeClass
{
  GimpBrushClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_pipe_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_pipe_load</NAME>
<RETURNS>GList  *</RETURNS>
const gchar  *filename,GError      **error
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BUFFER</NAME>
#define GIMP_TYPE_BUFFER            (gimp_buffer_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BUFFER</NAME>
#define GIMP_BUFFER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BUFFER, GimpBuffer))
</MACRO>
<MACRO>
<NAME>GIMP_BUFFER_CLASS</NAME>
#define GIMP_BUFFER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BUFFER, GimpBufferClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUFFER</NAME>
#define GIMP_IS_BUFFER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BUFFER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUFFER_CLASS</NAME>
#define GIMP_IS_BUFFER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BUFFER))
</MACRO>
<MACRO>
<NAME>GIMP_BUFFER_GET_CLASS</NAME>
#define GIMP_BUFFER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BUFFER, GimpBufferClass))
</MACRO>
<STRUCT>
<NAME>GimpBufferClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBuffer</NAME>
struct _GimpBuffer
{
  GimpViewable  parent_instance;

  TileManager  *tiles;
};
</STRUCT>
<STRUCT>
<NAME>GimpBufferClass</NAME>
struct _GimpBufferClass
{
  GimpViewableClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_buffer_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_new</NAME>
<RETURNS>GimpBuffer    *</RETURNS>
TileManager      *tiles,const gchar      *name,gboolean          copy_pixels
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_new_from_pixbuf</NAME>
<RETURNS>GimpBuffer    *</RETURNS>
GdkPixbuf        *pixbuf,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_get_width</NAME>
<RETURNS>gint            </RETURNS>
const GimpBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_get_height</NAME>
<RETURNS>gint            </RETURNS>
const GimpBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_get_bytes</NAME>
<RETURNS>gint            </RETURNS>
const GimpBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_get_image_type</NAME>
<RETURNS>GimpImageType   </RETURNS>
const GimpBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_add_segment</NAME>
<RETURNS>void   </RETURNS>
GimpChannel    *mask,gint            x,gint            y,gint            width,gint            value
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_sub_segment</NAME>
<RETURNS>void   </RETURNS>
GimpChannel    *mask,gint            x,gint            y,gint            width,gint            value
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_combine_rect</NAME>
<RETURNS>void   </RETURNS>
GimpChannel    *mask,GimpChannelOps  op,gint            x,gint            y,gint            w,gint            h
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_combine_ellipse</NAME>
<RETURNS>void   </RETURNS>
GimpChannel    *mask,GimpChannelOps  op,gint            x,gint            y,gint            w,gint            h,gboolean        antialias
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_combine_mask</NAME>
<RETURNS>void   </RETURNS>
GimpChannel    *mask,GimpChannel    *add_on,GimpChannelOps  op,gint            off_x,gint            off_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_rectangle</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,gint             x,gint             y,gint             w,gint             h,GimpChannelOps   op,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_ellipse</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,gint             x,gint             y,gint             w,gint             h,GimpChannelOps   op,gboolean         antialias,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_scan_convert</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,const gchar     *undo_desc,GimpScanConvert *scan_convert,gint             offset_x,gint             offset_y,GimpChannelOps   op,gboolean         antialias,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_polygon</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,const gchar     *undo_desc,gint             n_points,GimpVector2     *points,GimpChannelOps   op,gboolean         antialias,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_vectors</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,const gchar     *undo_desc,GimpVectors     *vectors,GimpChannelOps   op,gboolean         antialias,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_channel</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,const gchar     *undo_desc,GimpChannel     *add_on,gint             offset_x,gint             offset_y,GimpChannelOps   op,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_alpha</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,GimpDrawable    *drawable,GimpChannelOps   op,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_component</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,GimpChannelType  component,GimpChannelOps   op,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_fuzzy</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,GimpDrawable    *drawable,gboolean         sample_merged,gint             x,gint             y,gint             threshold,gboolean         select_transparent,GimpChannelOps   op,gboolean         antialias,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_select_by_color</NAME>
<RETURNS>void   </RETURNS>
GimpChannel     *channel,GimpDrawable    *drawable,gboolean         sample_merged,const GimpRGB   *color,gint             threshold,gboolean         select_transparent,GimpChannelOps   op,gboolean         antialias,gboolean         feather,gdouble          feather_radius_x,gdouble          feather_radius_y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CHANNEL</NAME>
#define GIMP_TYPE_CHANNEL            (gimp_channel_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CHANNEL</NAME>
#define GIMP_CHANNEL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CHANNEL, GimpChannel))
</MACRO>
<MACRO>
<NAME>GIMP_CHANNEL_CLASS</NAME>
#define GIMP_CHANNEL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CHANNEL, GimpChannelClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CHANNEL</NAME>
#define GIMP_IS_CHANNEL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CHANNEL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CHANNEL_CLASS</NAME>
#define GIMP_IS_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CHANNEL))
</MACRO>
<MACRO>
<NAME>GIMP_CHANNEL_GET_CLASS</NAME>
#define GIMP_CHANNEL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CHANNEL, GimpChannelClass))
</MACRO>
<STRUCT>
<NAME>GimpChannelClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpChannel</NAME>
struct _GimpChannel
{
  GimpDrawable  parent_instance;

  GimpRGB       color;             /*  Also stores the opacity        */
  gboolean      show_masked;       /*  Show masked areas--as          */
                                   /*  opposed to selected areas      */

  /*  Selection mask variables  */
  gboolean      boundary_known;    /*  is the current boundary valid  */
  BoundSeg     *segs_in;           /*  outline of selected region     */
  BoundSeg     *segs_out;          /*  outline of selected region     */
  gint          num_segs_in;       /*  number of lines in boundary    */
  gint          num_segs_out;      /*  number of lines in boundary    */
  gboolean      empty;             /*  is the region empty?           */
  gboolean      bounds_known;      /*  recalculate the bounds?        */
  gint          x1, y1;            /*  coordinates for bounding box   */
  gint          x2, y2;            /*  lower right hand coordinate    */
};
</STRUCT>
<STRUCT>
<NAME>GimpChannelClass</NAME>
struct _GimpChannelClass
{
  GimpDrawableClass  parent_class;

  /*  signals  */
  void     (* color_changed) (GimpChannel     *channel);

  /*  virtual functions  */
  gboolean (* boundary)      (GimpChannel     *channel,
                              const BoundSeg **segs_in,
                              const BoundSeg **segs_out,
                              gint            *num_segs_in,
                              gint            *num_segs_out,
                              gint             x1,
                              gint             y1,
                              gint             x2,
                              gint             y2);
  gboolean (* bounds)        (GimpChannel     *channel,
                              gint            *x1,
                              gint            *y1,
                              gint            *x2,
                              gint            *y2);
  gboolean (* is_empty)      (GimpChannel     *channel);

  void     (* feather)       (GimpChannel     *channel,
                              gdouble          radius_x,
                              gdouble          radius_y,
                              gboolean         push_undo);
  void     (* sharpen)       (GimpChannel     *channel,
                              gboolean         push_undo);
  void     (* clear)         (GimpChannel     *channel,
                              const gchar     *undo_desc,
                              gboolean         push_undo);
  void     (* all)           (GimpChannel     *channel,
                              gboolean         push_undo);
  void     (* invert)        (GimpChannel     *channel,
                              gboolean         push_undo);
  void     (* border)        (GimpChannel     *channel,
                              gint             radius_x,
                              gint             radius_y,
                              gboolean         push_undo);
  void     (* grow)          (GimpChannel     *channel,
                              gint             radius_x,
                              gint             radius_y,
                              gboolean         push_undo);
  void     (* shrink)        (GimpChannel     *channel,
                              gint             radius_x,
                              gint             radius_y,
                              gboolean         edge_lock,
                              gboolean         push_undo);

  const gchar *feather_desc;
  const gchar *sharpen_desc;
  const gchar *clear_desc;
  const gchar *all_desc;
  const gchar *invert_desc;
  const gchar *border_desc;
  const gchar *grow_desc;
  const gchar *shrink_desc;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_channel_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_new</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage         *image,gint               width,gint               height,const gchar       *name,const GimpRGB     *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_new_from_alpha</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage         *image,GimpDrawable      *drawable,const gchar       *name,const GimpRGB     *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_new_from_component</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage         *image,GimpChannelType    type,const gchar       *name,const GimpRGB     *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_get_opacity</NAME>
<RETURNS>gdouble       </RETURNS>
const GimpChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_set_opacity</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *channel,gdouble            opacity,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_get_color</NAME>
<RETURNS>void          </RETURNS>
const GimpChannel *channel,GimpRGB           *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_set_color</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *channel,const GimpRGB     *color,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_get_show_masked</NAME>
<RETURNS>gboolean      </RETURNS>
GimpChannel       *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_set_show_masked</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *channel,gboolean           show_masked
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_push_undo</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *mask,const gchar       *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_new_mask</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage         *image,gint               width,gint               height
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_boundary</NAME>
<RETURNS>gboolean      </RETURNS>
GimpChannel       *mask,const BoundSeg   **segs_in,const BoundSeg   **segs_out,gint              *num_segs_in,gint              *num_segs_out,gint               x1,gint               y1,gint               x2,gint               y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_bounds</NAME>
<RETURNS>gboolean      </RETURNS>
GimpChannel       *mask,gint              *x1,gint              *y1,gint              *x2,gint              *y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_is_empty</NAME>
<RETURNS>gboolean      </RETURNS>
GimpChannel       *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_feather</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *mask,gdouble            radius_x,gdouble            radius_y,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_sharpen</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *mask,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_clear</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *mask,const gchar       *undo_desc,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_all</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *mask,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_invert</NAME>
<RETURNS>void          </RETURNS>
GimpChannel       *mask,gboolean           push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_border</NAME>
<RETURNS>void          </RETURNS>
GimpChannel      *mask,gint              radius_x,gint              radius_y,gboolean          push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_grow</NAME>
<RETURNS>void          </RETURNS>
GimpChannel      *mask,gint              radius_x,gint              radius_y,gboolean          push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_channel_shrink</NAME>
<RETURNS>void          </RETURNS>
GimpChannel      *mask,gint              radius_x,gint              radius_y,gboolean          edge_lock,gboolean          push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_filter</NAME>
<RETURNS>GimpContainer *</RETURNS>
const GimpContainer  *container,GimpObjectFilterFunc  filter,gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_filter_by_name</NAME>
<RETURNS>GimpContainer *</RETURNS>
const GimpContainer  *container,const gchar          *regexp,GError              **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_get_filtered_name_array</NAME>
<RETURNS>gchar         **</RETURNS>
const GimpContainer  *container,const gchar          *regexp,gint                 *length
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER</NAME>
#define GIMP_TYPE_CONTAINER            (gimp_container_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER</NAME>
#define GIMP_CONTAINER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER, GimpContainer))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_CLASS</NAME>
#define GIMP_CONTAINER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER, GimpContainerClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER</NAME>
#define GIMP_IS_CONTAINER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_CLASS</NAME>
#define GIMP_IS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_GET_CLASS</NAME>
#define GIMP_CONTAINER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER, GimpContainerClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainer</NAME>
struct _GimpContainer
{
  GimpObject           parent_instance;

  /*  public, read-only  */
  GType                children_type;
  GimpContainerPolicy  policy;
  gint                 num_children;

  /*  private  */
  GList               *handlers;
  gint                 freeze_count;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerClass</NAME>
struct _GimpContainerClass
{
  GimpObjectClass  parent_class;

  /*  signals  */
  void         (* add)                (GimpContainer       *container,
                                       GimpObject          *object);
  void         (* remove)             (GimpContainer       *container,
                                       GimpObject          *object);
  void         (* reorder)            (GimpContainer       *container,
                                       GimpObject          *object,
                                       gint                 new_index);
  void         (* freeze)             (GimpContainer       *container);
  void         (* thaw)               (GimpContainer       *container);

  /*  virtual functions  */
  void         (* clear)              (GimpContainer       *container);
  gboolean     (* have)               (const GimpContainer *container,
                                       const GimpObject    *object);
  void         (* foreach)            (const GimpContainer *container,
                                       GFunc                func,
                                       gpointer             user_data);
  GimpObject * (* get_child_by_name)  (const GimpContainer *container,
                                       const gchar         *name);
  GimpObject * (* get_child_by_index) (const GimpContainer *container,
                                       gint                 index);
  gint         (* get_child_index)    (const GimpContainer *container,
                                       const GimpObject    *object);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_children_type</NAME>
<RETURNS>GType        </RETURNS>
const GimpContainer *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_policy</NAME>
<RETURNS>GimpContainerPolicy </RETURNS>
const GimpContainer *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_num_children</NAME>
<RETURNS>gint         </RETURNS>
const GimpContainer *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_add</NAME>
<RETURNS>gboolean     </RETURNS>
GimpContainer       *container,GimpObject          *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_remove</NAME>
<RETURNS>gboolean     </RETURNS>
GimpContainer       *container,GimpObject          *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_insert</NAME>
<RETURNS>gboolean     </RETURNS>
GimpContainer       *container,GimpObject          *object,gint                 new_index
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_reorder</NAME>
<RETURNS>gboolean     </RETURNS>
GimpContainer       *container,GimpObject          *object,gint                 new_index
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_freeze</NAME>
<RETURNS>void         </RETURNS>
GimpContainer       *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_thaw</NAME>
<RETURNS>void         </RETURNS>
GimpContainer       *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_frozen</NAME>
<RETURNS>gboolean     </RETURNS>
GimpContainer       *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_clear</NAME>
<RETURNS>void         </RETURNS>
GimpContainer       *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_is_empty</NAME>
<RETURNS>gboolean     </RETURNS>
const GimpContainer *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_have</NAME>
<RETURNS>gboolean     </RETURNS>
const GimpContainer *container,GimpObject          *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_foreach</NAME>
<RETURNS>void         </RETURNS>
const GimpContainer *container,GFunc                func,gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_get_child_by_name</NAME>
<RETURNS>GimpObject *</RETURNS>
const GimpContainer *container,const gchar         *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_get_child_by_index</NAME>
<RETURNS>GimpObject *</RETURNS>
const GimpContainer *container,gint                 index
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_get_child_index</NAME>
<RETURNS>gint         </RETURNS>
const GimpContainer *container,const GimpObject    *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_get_name_array</NAME>
<RETURNS>gchar     **</RETURNS>
const GimpContainer *container,gint                *length
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_add_handler</NAME>
<RETURNS>GQuark       </RETURNS>
GimpContainer       *container,const gchar         *signame,GCallback            callback,gpointer             callback_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_remove_handler</NAME>
<RETURNS>void         </RETURNS>
GimpContainer       *container,GQuark               id
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTEXT</NAME>
#define GIMP_TYPE_CONTEXT            (gimp_context_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTEXT</NAME>
#define GIMP_CONTEXT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTEXT, GimpContext))
</MACRO>
<MACRO>
<NAME>GIMP_CONTEXT_CLASS</NAME>
#define GIMP_CONTEXT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST (klass, GIMP_TYPE_CONTEXT, GimpContextClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTEXT</NAME>
#define GIMP_IS_CONTEXT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTEXT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTEXT_CLASS</NAME>
#define GIMP_IS_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTEXT))
</MACRO>
<MACRO>
<NAME>GIMP_CONTEXT_GET_CLASS</NAME>
#define GIMP_CONTEXT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS (obj, GIMP_TYPE_CONTEXT, GimpContextClass))
</MACRO>
<STRUCT>
<NAME>GimpContextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContext</NAME>
struct _GimpContext
{
  GimpObject            parent_instance;

  Gimp                 *gimp;

  GimpContext          *parent;

  guint32               defined_props;
  guint32               serialize_props;

  GimpImage            *image;
  gpointer              display;

  GimpToolInfo         *tool_info;
  gchar                *tool_name;

  GimpPaintInfo        *paint_info;
  gchar                *paint_name;

  GimpRGB               foreground;
  GimpRGB               background;

  gdouble               opacity;
  GimpLayerModeEffects  paint_mode;

  GimpBrush            *brush;
  gchar                *brush_name;

  GimpPattern          *pattern;
  gchar                *pattern_name;

  GimpGradient         *gradient;
  gchar                *gradient_name;

  GimpPalette          *palette;
  gchar                *palette_name;

  GimpFont             *font;
  gchar                *font_name;

  GimpBuffer           *buffer;
  gchar                *buffer_name;

  GimpImagefile        *imagefile;
  gchar                *imagefile_name;

  GimpTemplate         *template;
  gchar                *template_name;
};
</STRUCT>
<STRUCT>
<NAME>GimpContextClass</NAME>
struct _GimpContextClass
{
  GimpObjectClass  parent_class;

  void (* image_changed)      (GimpContext          *context,
                               GimpImage            *image);
  void (* display_changed)    (GimpContext          *context,
                               gpointer              display);

  void (* tool_changed)       (GimpContext          *context,
                               GimpToolInfo         *tool_info);
  void (* paint_info_changed) (GimpContext          *context,
                               GimpPaintInfo        *paint_info);

  void (* foreground_changed) (GimpContext          *context,
                               GimpRGB              *color);
  void (* background_changed) (GimpContext          *context,
                               GimpRGB              *color);
  void (* opacity_changed)    (GimpContext          *context,
                               gdouble               opacity);
  void (* paint_mode_changed) (GimpContext          *context,
                               GimpLayerModeEffects  paint_mode);
  void (* brush_changed)      (GimpContext          *context,
                               GimpBrush            *brush);
  void (* pattern_changed)    (GimpContext          *context,
                               GimpPattern          *pattern);
  void (* gradient_changed)   (GimpContext          *context,
                               GimpGradient         *gradient);
  void (* palette_changed)    (GimpContext          *context,
                               GimpPalette          *palette);
  void (* font_changed)       (GimpContext          *context,
                               GimpFont             *font);
  void (* buffer_changed)     (GimpContext          *context,
                               GimpBuffer           *buffer);
  void (* imagefile_changed)  (GimpContext          *context,
                               GimpImagefile        *imagefile);
  void (* template_changed)   (GimpContext          *context,
                               GimpTemplate         *template);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_context_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_new</NAME>
<RETURNS>GimpContext *</RETURNS>
Gimp                *gimp,const gchar         *name,GimpContext         *template
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_parent</NAME>
<RETURNS>GimpContext *</RETURNS>
const GimpContext   *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_parent</NAME>
<RETURNS>void          </RETURNS>
GimpContext         *context,GimpContext         *parent
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_define_property</NAME>
<RETURNS>void          </RETURNS>
GimpContext         *context,GimpContextPropType  prop,gboolean             defined
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_property_defined</NAME>
<RETURNS>gboolean      </RETURNS>
GimpContext         *context,GimpContextPropType  prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_define_properties</NAME>
<RETURNS>void          </RETURNS>
GimpContext         *context,GimpContextPropMask  props_mask,gboolean             defined
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_serialize_properties</NAME>
<RETURNS>void   </RETURNS>
GimpContext         *context,GimpContextPropMask  props_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_serialize_properties</NAME>
<RETURNS>GimpContextPropMask</RETURNS>
GimpContext         *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_copy_property</NAME>
<RETURNS>void          </RETURNS>
GimpContext         *src,GimpContext         *dest,GimpContextPropType  prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_copy_properties</NAME>
<RETURNS>void          </RETURNS>
GimpContext         *src,GimpContext         *dest,GimpContextPropMask  props_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_type_to_property</NAME>
<RETURNS>GimpContextPropType   </RETURNS>
GType     type
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_type_to_prop_name</NAME>
<RETURNS>const gchar         *</RETURNS>
GType     type
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_type_to_signal_name</NAME>
<RETURNS>const gchar         *</RETURNS>
GType     type
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_by_type</NAME>
<RETURNS>GimpObject    *</RETURNS>
GimpContext     *context,GType            type
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_by_type</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GType            type,GimpObject      *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_changed_by_type</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GType            type
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_image</NAME>
<RETURNS>GimpImage     *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_image</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpImage       *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_image_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_display</NAME>
<RETURNS>gpointer        </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_display</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,gpointer         display
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_display_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_tool</NAME>
<RETURNS>GimpToolInfo  *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_tool</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpToolInfo    *tool_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_tool_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_paint_info</NAME>
<RETURNS>GimpPaintInfo *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_paint_info</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpPaintInfo   *paint_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_paint_info_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_foreground</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpRGB         *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_foreground</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,const GimpRGB   *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_foreground_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_background</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpRGB         *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_background</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,const GimpRGB   *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_background_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_default_colors</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_swap_colors</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_opacity</NAME>
<RETURNS>gdouble         </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_opacity</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,gdouble          opacity
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_opacity_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_paint_mode</NAME>
<RETURNS>GimpLayerModeEffects</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_paint_mode</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpLayerModeEffects  paint_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_paint_mode_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_brush</NAME>
<RETURNS>GimpBrush     *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_brush</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpBrush       *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_brush_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_pattern</NAME>
<RETURNS>GimpPattern   *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_pattern</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpPattern     *pattern
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_pattern_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_gradient</NAME>
<RETURNS>GimpGradient  *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_gradient</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpGradient    *gradient
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_gradient_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_palette</NAME>
<RETURNS>GimpPalette   *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_palette</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpPalette     *palette
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_palette_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_font</NAME>
<RETURNS>GimpFont      *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_font</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpFont        *font
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_font_name</NAME>
<RETURNS>const gchar   *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_font_name</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_font_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_buffer</NAME>
<RETURNS>GimpBuffer    *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_buffer</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpBuffer      *palette
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_buffer_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_imagefile</NAME>
<RETURNS>GimpImagefile *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_imagefile</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpImagefile   *imagefile
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_imagefile_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_get_template</NAME>
<RETURNS>GimpTemplate  *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_set_template</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context,GimpTemplate    *template
</FUNCTION>
<FUNCTION>
<NAME>gimp_context_template_changed</NAME>
<RETURNS>void            </RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_mix</NAME>
<RETURNS>void     </RETURNS>
const gdouble     amul,const GimpCoords *a,const gdouble     bmul,const GimpCoords *b,GimpCoords       *ret_val
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_average</NAME>
<RETURNS>void     </RETURNS>
const GimpCoords *a,const GimpCoords *b,GimpCoords       *ret_average
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_add</NAME>
<RETURNS>void     </RETURNS>
const GimpCoords *a,const GimpCoords *b,GimpCoords       *ret_add
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_difference</NAME>
<RETURNS>void     </RETURNS>
const GimpCoords *a,const GimpCoords *b,GimpCoords       *difference
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_scale</NAME>
<RETURNS>void     </RETURNS>
const gdouble     f,const GimpCoords *a,GimpCoords       *ret_product
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_scalarprod</NAME>
<RETURNS>gdouble  </RETURNS>
const GimpCoords *a,const GimpCoords *b
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_length</NAME>
<RETURNS>gdouble  </RETURNS>
const GimpCoords *a
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_length_squared</NAME>
<RETURNS>gdouble  </RETURNS>
const GimpCoords *a
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_manhattan_dist</NAME>
<RETURNS>gdouble  </RETURNS>
const GimpCoords *a,const GimpCoords *b
</FUNCTION>
<FUNCTION>
<NAME>gimp_coords_equal</NAME>
<RETURNS>gboolean </RETURNS>
const GimpCoords *a,const GimpCoords *b
</FUNCTION>
<ENUM>
<NAME>GimpDataError</NAME>
typedef enum
{
  GIMP_DATA_ERROR_OPEN,   /*  opening data file failed   */
  GIMP_DATA_ERROR_READ,   /*  reading data file failed   */
  GIMP_DATA_ERROR_WRITE,  /*  writing data file failed   */
  GIMP_DATA_ERROR_DELETE  /*  deleting data file failed  */
} GimpDataError;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_DATA</NAME>
#define GIMP_TYPE_DATA            (gimp_data_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DATA</NAME>
#define GIMP_DATA(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DATA, GimpData))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_CLASS</NAME>
#define GIMP_DATA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DATA, GimpDataClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA</NAME>
#define GIMP_IS_DATA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DATA))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_CLASS</NAME>
#define GIMP_IS_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DATA))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_GET_CLASS</NAME>
#define GIMP_DATA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DATA, GimpDataClass))
</MACRO>
<STRUCT>
<NAME>GimpDataClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpData</NAME>
struct _GimpData
{
  GimpViewable  parent_instance;

  gchar        *filename;
  GQuark        mime_type;
  guint         writable  : 1;
  guint         deletable : 1;
  guint         dirty     : 1;
  guint         internal  : 1;
  gint          freeze_count;
  time_t        mtime;
};
</STRUCT>
<STRUCT>
<NAME>GimpDataClass</NAME>
struct _GimpDataClass
{
  GimpViewableClass  parent_class;

  /*  signals  */
  void       (* dirty)         (GimpData  *data);

  /*  virtual functions  */
  gboolean   (* save)          (GimpData  *data,
                                GError   **error);
  gchar    * (* get_extension) (GimpData  *data);
  GimpData * (* duplicate)     (GimpData  *data);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_data_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_save</NAME>
<RETURNS>gboolean      </RETURNS>
GimpData     *data,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_dirty</NAME>
<RETURNS>void          </RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_freeze</NAME>
<RETURNS>void          </RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_thaw</NAME>
<RETURNS>void          </RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_delete_from_disk</NAME>
<RETURNS>gboolean      </RETURNS>
GimpData     *data,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_get_extension</NAME>
<RETURNS>const gchar *</RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_set_filename</NAME>
<RETURNS>void          </RETURNS>
GimpData     *data,const gchar  *filename,gboolean      writable,gboolean      deletable
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_create_filename</NAME>
<RETURNS>void          </RETURNS>
GimpData     *data,const gchar  *dest_dir
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_get_mime_type</NAME>
<RETURNS>const gchar *</RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_duplicate</NAME>
<RETURNS>GimpData    *</RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_make_internal</NAME>
<RETURNS>void          </RETURNS>
GimpData     *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_name_compare</NAME>
<RETURNS>gint          </RETURNS>
GimpData     *data1,GimpData     *data2
</FUNCTION>
<MACRO>
<NAME>GIMP_DATA_ERROR</NAME>
#define GIMP_DATA_ERROR (gimp_data_error_quark ())
</MACRO>
<FUNCTION>
<NAME>gimp_data_error_quark</NAME>
<RETURNS>GQuark        </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDataNewFunc</NAME>
<RETURNS>GimpData *</RETURNS>
const gchar  *name
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDataLoadFunc</NAME>
<RETURNS>GList *</RETURNS>
const gchar  *filename,
                                                GError      **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDataGetStandardFunc</NAME>
<RETURNS>GimpData *</RETURNS>
void
</USER_FUNCTION>
<STRUCT>
<NAME>GimpDataFactoryLoaderEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataFactoryLoaderEntry</NAME>
struct _GimpDataFactoryLoaderEntry
{
  GimpDataLoadFunc  load_func;
  const gchar      *extension;
  gboolean          writable;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_DATA_FACTORY</NAME>
#define GIMP_TYPE_DATA_FACTORY            (gimp_data_factory_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DATA_FACTORY</NAME>
#define GIMP_DATA_FACTORY(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DATA_FACTORY, GimpDataFactory))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_FACTORY_CLASS</NAME>
#define GIMP_DATA_FACTORY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DATA_FACTORY, GimpDataFactoryClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_FACTORY</NAME>
#define GIMP_IS_DATA_FACTORY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DATA_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_FACTORY_CLASS</NAME>
#define GIMP_IS_DATA_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DATA_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_FACTORY_GET_CLASS</NAME>
#define GIMP_DATA_FACTORY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DATA_FACTORY, GimpDataFactoryClass))
</MACRO>
<STRUCT>
<NAME>GimpDataFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataFactory</NAME>
struct _GimpDataFactory
{
  GimpObject                        parent_instance;

  Gimp                             *gimp;
  GimpContainer                    *container;

  gchar                            *path_property_name;
  gchar                            *writable_property_name;

  const GimpDataFactoryLoaderEntry *loader_entries;
  gint                              n_loader_entries;

  GimpDataNewFunc                   data_new_func;
  GimpDataGetStandardFunc           data_get_standard_func;
};
</STRUCT>
<STRUCT>
<NAME>GimpDataFactoryClass</NAME>
struct _GimpDataFactoryClass
{
  GimpObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_data_factory_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_new</NAME>
<RETURNS>GimpDataFactory *</RETURNS>
Gimp                             *gimp,GType                             data_type,const gchar                      *path_property_name,const gchar                      *writable_property_name,const GimpDataFactoryLoaderEntry *loader_entries,gint                              n_loader_entries,GimpDataNewFunc                   new_func,GimpDataGetStandardFunc           standard_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_init</NAME>
<RETURNS>void       </RETURNS>
GimpDataFactory  *factory,gboolean          no_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_refresh</NAME>
<RETURNS>void       </RETURNS>
GimpDataFactory  *factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_save</NAME>
<RETURNS>void       </RETURNS>
GimpDataFactory  *factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_free</NAME>
<RETURNS>void       </RETURNS>
GimpDataFactory  *factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_new</NAME>
<RETURNS>GimpData *</RETURNS>
GimpDataFactory  *factory,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_duplicate</NAME>
<RETURNS>GimpData *</RETURNS>
GimpDataFactory  *factory,GimpData         *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_delete</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDataFactory  *factory,GimpData         *data,gboolean          delete_from_disk,GError          **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_get_standard</NAME>
<RETURNS>GimpData *</RETURNS>
GimpDataFactory  *factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_data_save_single</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDataFactory  *factory,GimpData         *data
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DOCUMENT_LIST</NAME>
#define GIMP_TYPE_DOCUMENT_LIST           (gimp_document_list_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DOCUMENT_LIST</NAME>
#define GIMP_DOCUMENT_LIST(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCUMENT_LIST, GimpDocumentList))
</MACRO>
<MACRO>
<NAME>GIMP_DOCUMENT_LIST_CLASS</NAME>
#define GIMP_DOCUMENT_LIST_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DOCUMENT_LIST, GimpDocumentListClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCUMENT_LIST</NAME>
#define GIMP_IS_DOCUMENT_LIST(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCUMENT_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCUMENT_LIST_CLASS</NAME>
#define GIMP_IS_DOCUMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DOCUMENT_LIST))
</MACRO>
<STRUCT>
<NAME>GimpDocumentListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDocumentList</NAME>
struct _GimpDocumentList
{
  GimpList  parent_instance;

  Gimp     *gimp;
};
</STRUCT>
<STRUCT>
<NAME>GimpDocumentListClass</NAME>
struct _GimpDocumentListClass
{
  GimpListClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_document_list_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_document_list_new</NAME>
<RETURNS>GimpContainer *</RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_document_list_add_uri</NAME>
<RETURNS>GimpImagefile *</RETURNS>
GimpDocumentList *document_list,const gchar      *uri,const gchar      *mime_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_blend</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable         *drawable,GimpContext          *context,GimpBlendMode         blend_mode,GimpLayerModeEffects  paint_mode,GimpGradientType      gradient_type,gdouble               opacity,gdouble               offset,GimpRepeatMode        repeat,gboolean              reverse,gboolean              supersample,gint                  max_depth,gdouble               threshold,gboolean              dither,gdouble               startx,gdouble               starty,gdouble               endx,gdouble               endy,GimpProgress         *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_bucket_fill</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable       *drawable,GimpContext        *context,GimpBucketFillMode  fill_mode,gint                paint_mode,gdouble             opacity,gboolean            do_seed_fill,gboolean            fill_transparent,gdouble             threshold,gboolean            sample_merged,gdouble             x,gdouble             y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_bucket_fill_full</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable       *drawable,GimpBucketFillMode  fill_mode,gint                paint_mode,gdouble             opacity,gboolean            do_seed_fill,gboolean            fill_transparent,gdouble             threshold,gboolean            sample_merged,gdouble             x,gdouble             y,const GimpRGB      *color,GimpPattern        *pattern
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_real_apply_region</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable         *drawable,PixelRegion          *src2PR,gboolean              push_undo,const gchar          *undo_desc,gdouble               opacity,GimpLayerModeEffects  mode,TileManager          *src1_tiles,gint                  x,gint                  y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_real_replace_region</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable         *drawable,PixelRegion          *src2PR,gboolean              push_undo,const gchar          *undo_desc,gdouble               opacity,PixelRegion          *maskPR,gint                  x,gint                  y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_convert_rgb</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable       *drawable,TileManager        *new_tiles,GimpImageBaseType   old_base_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_convert_grayscale</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable       *drawable,TileManager        *new_tiles,GimpImageBaseType   old_base_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_desaturate</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable       *drawable,GimpDesaturateMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_equalize</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable *drawable,gboolean      mask_only
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_calculate_histogram</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable  *drawable,GimpHistogram *histogram
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_invert</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_levels</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable *drawable,GimpContext  *context,gint32        channel,gint32        low_input,gint32        high_input,gdouble       gamma,gint32        low_output,gint32        high_output
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_levels_stretch</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable *drawable,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_offset</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable   *drawable,GimpContext    *context,gboolean        wrap_around,GimpOffsetType  fill_type,gint            offset_x,gint            offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_get_preview</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpViewable *viewable,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_preview_bytes</NAME>
<RETURNS>gint      </RETURNS>
GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_get_sub_preview</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpDrawable *drawable,gint          src_x,gint          src_y,gint          src_width,gint          src_height,gint          dest_width,gint          dest_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_stroke_boundary</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable      *drawable,GimpStrokeOptions *options,const BoundSeg    *bound_segs,gint               n_bound_segs,gint               offset_x,gint               offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_stroke_vectors</NAME>
<RETURNS>void   </RETURNS>
GimpDrawable      *drawable,GimpStrokeOptions *options,GimpVectors       *vectors
</FUNCTION>
<ENUM>
<NAME>GimpTransformBoundingBox</NAME>
typedef enum
{
  X0,
  Y0,
  X1,
  Y1,
  X2,
  Y2,
  X3,
  Y3
} GimpTransformBoundingBox;
</ENUM>
<FUNCTION>
<NAME>gimp_drawable_transform_tiles_affine</NAME>
<RETURNS>TileManager *</RETURNS>
GimpDrawable           *drawable,GimpContext            *context,TileManager            *orig_tiles,const GimpMatrix3      *matrix,GimpTransformDirection  direction,GimpInterpolationType   interpolation_type,gboolean                supersample,gint                    recursion_level,gboolean                clip_result,GimpProgress           *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_tiles_flip</NAME>
<RETURNS>TileManager *</RETURNS>
GimpDrawable           *drawable,GimpContext            *context,TileManager            *orig_tiles,GimpOrientationType     flip_type,gdouble                 axis,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_tiles_rotate</NAME>
<RETURNS>TileManager *</RETURNS>
GimpDrawable           *drawable,GimpContext            *context,TileManager            *orig_tiles,GimpRotationType        rotate_type,gdouble                 center_x,gdouble                 center_y,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_affine</NAME>
<RETURNS>gboolean      </RETURNS>
GimpDrawable           *drawable,GimpContext            *context,const GimpMatrix3      *matrix,GimpTransformDirection  direction,GimpInterpolationType   interpolation_type,gboolean                supersample,gint                    recursion_level,gboolean                clip_result,GimpProgress           *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_flip</NAME>
<RETURNS>gboolean      </RETURNS>
GimpDrawable           *drawable,GimpContext            *context,GimpOrientationType     flip_type,gboolean                auto_center,gdouble                 axis,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_rotate</NAME>
<RETURNS>gboolean      </RETURNS>
GimpDrawable           *drawable,GimpContext            *context,GimpRotationType        rotate_type,gboolean                auto_center,gdouble                 center_x,gdouble                 center_y,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_cut</NAME>
<RETURNS>TileManager *</RETURNS>
GimpDrawable           *drawable,GimpContext            *context,gboolean               *new_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_transform_paste</NAME>
<RETURNS>gboolean      </RETURNS>
GimpDrawable           *drawable,TileManager            *tiles,gboolean                new_layer
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DRAWABLE</NAME>
#define GIMP_TYPE_DRAWABLE            (gimp_drawable_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DRAWABLE</NAME>
#define GIMP_DRAWABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DRAWABLE, GimpDrawable))
</MACRO>
<MACRO>
<NAME>GIMP_DRAWABLE_CLASS</NAME>
#define GIMP_DRAWABLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DRAWABLE, GimpDrawableClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DRAWABLE</NAME>
#define GIMP_IS_DRAWABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DRAWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DRAWABLE_CLASS</NAME>
#define GIMP_IS_DRAWABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DRAWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_DRAWABLE_GET_CLASS</NAME>
#define GIMP_DRAWABLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DRAWABLE, GimpDrawableClass))
</MACRO>
<STRUCT>
<NAME>GimpDrawableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDrawable</NAME>
struct _GimpDrawable
{
  GimpItem       parent_instance;

  TileManager   *tiles;              /* tiles for drawable data        */

  gint           bytes;              /* bytes per pixel                */
  GimpImageType  type;               /* type of drawable               */
  gboolean       has_alpha;          /* drawable has alpha             */

  /*  Preview variables  */
  GSList        *preview_cache;      /* preview caches of the channel  */
  gboolean       preview_valid;      /* is the preview valid?          */
};
</STRUCT>
<STRUCT>
<NAME>GimpDrawableClass</NAME>
struct _GimpDrawableClass
{
  GimpItemClass  parent_class;

  /*  signals  */
  void (* update)                (GimpDrawable         *drawable,
                                  gint                  x,
                                  gint                  y,
                                  gint                  width,
                                  gint                  height);
  void (* alpha_changed)         (GimpDrawable         *drawable);

  /*  virtual functions  */
  void (* invalidate_boundary)   (GimpDrawable         *drawable);
  void (* get_active_components) (const GimpDrawable   *drawable,
                                  gboolean             *active);
  void (* apply_region)          (GimpDrawable         *drawable,
                                  PixelRegion          *src2PR,
                                  gboolean              push_undo,
                                  const gchar          *undo_desc,
                                  gdouble               opacity,
                                  GimpLayerModeEffects  mode,
                                  TileManager          *src1_tiles,
                                  gint                  x,
                                  gint                  y);
  void (* replace_region)        (GimpDrawable         *drawable,
                                  PixelRegion          *src2PR,
                                  gboolean              push_undo,
                                  const gchar          *undo_desc,
                                  gdouble               opacity,
                                  PixelRegion          *maskPR,
                                  gint                  x,
                                  gint                  y);
  void (* set_tiles)             (GimpDrawable         *drawable,
                                  gboolean              push_undo,
                                  const gchar          *undo_desc,
                                  TileManager          *tiles,
                                  GimpImageType         type,
                                  gint                  offset_x,
                                  gint                  offset_y);

  void (* push_undo)             (GimpDrawable         *drawable,
                                  const gchar          *undo_desc,
                                  TileManager          *tiles,
                                  gboolean              sparse,
                                  gint                  x,
                                  gint                  y,
                                  gint                  width,
                                  gint                  height);
  void (* swap_pixels)           (GimpDrawable         *drawable,
                                  TileManager          *tiles,
                                  gboolean              sparse,
                                  gint                  x,
                                  gint                  y,
                                  gint                  width,
                                  gint                  height);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_drawable_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_configure</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,GimpImage          *image,gint                offset_x,gint                offset_y,gint                width,gint                height,GimpImageType       type,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_update</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,gint                x,gint                y,gint                width,gint                height
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_alpha_changed</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_invalidate_boundary</NAME>
<RETURNS>void           </RETURNS>
GimpDrawable       *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_get_active_components</NAME>
<RETURNS>void         </RETURNS>
const GimpDrawable *drawable,gboolean           *active
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_apply_region</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,PixelRegion        *src2PR,gboolean            push_undo,const gchar        *undo_desc,gdouble             opacity,GimpLayerModeEffects  mode,TileManager        *src1_tiles,gint                x,gint                y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_replace_region</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,PixelRegion        *src2PR,gboolean            push_undo,const gchar        *undo_desc,gdouble             opacity,PixelRegion        *maskPR,gint                x,gint                y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_get_tiles</NAME>
<RETURNS>TileManager   *</RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_set_tiles</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,gboolean            push_undo,const gchar        *undo_desc,TileManager        *tiles
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_set_tiles_full</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,gboolean            push_undo,const gchar        *undo_desc,TileManager        *tiles,GimpImageType       type,gint                offset_x,gint                offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_swap_pixels</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,TileManager        *tiles,gboolean            sparse,gint                x,gint                y,gint                width,gint                height
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_push_undo</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,const gchar        *undo_desc,gint                x1,gint                y1,gint                x2,gint                y2,TileManager        *tiles,gboolean            sparse
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_get_shadow_tiles</NAME>
<RETURNS>TileManager   *</RETURNS>
GimpDrawable       *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_merge_shadow</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,gboolean            push_undo,const gchar        *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_fill</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,const GimpRGB      *color,const GimpPattern  *pattern
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_fill_by_type</NAME>
<RETURNS>void            </RETURNS>
GimpDrawable       *drawable,GimpContext        *context,GimpFillType        fill_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_mask_bounds</NAME>
<RETURNS>gboolean        </RETURNS>
GimpDrawable       *drawable,gint               *x1,gint               *y1,gint               *x2,gint               *y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_mask_intersect</NAME>
<RETURNS>gboolean        </RETURNS>
GimpDrawable       *drawable,gint               *x,gint               *y,gint               *width,gint               *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_has_alpha</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_type</NAME>
<RETURNS>GimpImageType   </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_type_with_alpha</NAME>
<RETURNS>GimpImageType   </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_type_without_alpha</NAME>
<RETURNS>GimpImageType   </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_is_rgb</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_is_gray</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_is_indexed</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_bytes</NAME>
<RETURNS>gint            </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_bytes_with_alpha</NAME>
<RETURNS>gint            </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_bytes_without_alpha</NAME>
<RETURNS>gint            </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_has_floating_sel</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_get_colormap</NAME>
<RETURNS>const guchar  *</RETURNS>
const GimpDrawable *drawable
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ENVIRON_TABLE</NAME>
#define GIMP_TYPE_ENVIRON_TABLE            (gimp_environ_table_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ENVIRON_TABLE</NAME>
#define GIMP_ENVIRON_TABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ENVIRON_TABLE, GimpEnvironTable))
</MACRO>
<MACRO>
<NAME>GIMP_ENVIRON_TABLE_CLASS</NAME>
#define GIMP_ENVIRON_TABLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ENVIRON_TABLE, GimpEnvironTableClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ENVIRON_TABLE</NAME>
#define GIMP_IS_ENVIRON_TABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ENVIRON_TABLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ENVIRON_TABLE_CLASS</NAME>
#define GIMP_IS_ENVIRON_TABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ENVIRON_TABLE))
</MACRO>
<MACRO>
<NAME>GIMP_ENVIRON_TABLE_GET_CLASS</NAME>
#define GIMP_ENVIRON_TABLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ENVIRON_TABLE, GimpEnvironTableClass))
</MACRO>
<STRUCT>
<NAME>GimpEnvironTableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEnvironTable</NAME>
struct _GimpEnvironTable
{
  GObject      parent_instance;

  GHashTable  *vars;
  GHashTable  *internal;

  gchar      **envp;
};
</STRUCT>
<STRUCT>
<NAME>GimpEnvironTableClass</NAME>
struct _GimpEnvironTableClass
{
  GObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_environ_table_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_new</NAME>
<RETURNS>GimpEnvironTable  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_load</NAME>
<RETURNS>void                </RETURNS>
GimpEnvironTable *environ_table,const gchar      *env_path
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_add</NAME>
<RETURNS>void                </RETURNS>
GimpEnvironTable *environ_table,const gchar      *name,const gchar      *value,const gchar      *separator
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_remove</NAME>
<RETURNS>void                </RETURNS>
GimpEnvironTable *environ_table,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_clear</NAME>
<RETURNS>void                </RETURNS>
GimpEnvironTable *environ_table
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_clear_all</NAME>
<RETURNS>void                </RETURNS>
GimpEnvironTable *environ_table
</FUNCTION>
<FUNCTION>
<NAME>gimp_environ_table_get_envp</NAME>
<RETURNS>gchar            **</RETURNS>
GimpEnvironTable *environ_table
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_load</NAME>
<RETURNS>GList  *</RETURNS>
const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_load_svg</NAME>
<RETURNS>GList  *</RETURNS>
const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_save</NAME>
<RETURNS>gboolean   </RETURNS>
GimpData      *data,GError       **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_save_as_pov</NAME>
<RETURNS>gboolean   </RETURNS>
GimpGradient  *gradient,const gchar   *filename,GError       **error
</FUNCTION>
<MACRO>
<NAME>GIMP_GRADIENT_FILE_EXTENSION</NAME>
#define GIMP_GRADIENT_FILE_EXTENSION       ".ggr"
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_SVG_FILE_EXTENSION</NAME>
#define GIMP_GRADIENT_SVG_FILE_EXTENSION   ".svg"
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_DEFAULT_SAMPLE_SIZE</NAME>
#define GIMP_GRADIENT_DEFAULT_SAMPLE_SIZE  40
</MACRO>
<STRUCT>
<NAME>GimpGradientSegment</NAME>
struct _GimpGradientSegment
{
  gdouble                  left, middle, right;
  GimpRGB                  left_color;
  GimpRGB                  right_color;
  GimpGradientSegmentType  type;          /*  Segment's blending function  */
  GimpGradientSegmentColor color;         /*  Segment's coloring type      */

  GimpGradientSegment     *prev;
  GimpGradientSegment     *next;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_GRADIENT</NAME>
#define GIMP_TYPE_GRADIENT            (gimp_gradient_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT</NAME>
#define GIMP_GRADIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GRADIENT, GimpGradient))
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_CLASS</NAME>
#define GIMP_GRADIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GRADIENT, GimpGradientClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRADIENT</NAME>
#define GIMP_IS_GRADIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GRADIENT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRADIENT_CLASS</NAME>
#define GIMP_IS_GRADIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GRADIENT))
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_GET_CLASS</NAME>
#define GIMP_GRADIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_GRADIENT, GimpGradientClass))
</MACRO>
<STRUCT>
<NAME>GimpGradientClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradient</NAME>
struct _GimpGradient
{
  GimpData             parent_instance;

  GimpGradientSegment *segments;
};
</STRUCT>
<STRUCT>
<NAME>GimpGradientClass</NAME>
struct _GimpGradientClass
{
  GimpDataClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_gradient_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_new</NAME>
<RETURNS>GimpData            *</RETURNS>
const gchar   *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_get_standard</NAME>
<RETURNS>GimpData            *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_get_color_at</NAME>
<RETURNS>GimpGradientSegment *</RETURNS>
GimpGradient        *gradient,GimpGradientSegment *seg,gdouble              pos,gboolean             reverse,GimpRGB             *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_get_segment_at</NAME>
<RETURNS>GimpGradientSegment *</RETURNS>
GimpGradient  *grad,gdouble        pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_new</NAME>
<RETURNS>GimpGradientSegment *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_last</NAME>
<RETURNS>GimpGradientSegment *</RETURNS>
GimpGradientSegment *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_first</NAME>
<RETURNS>GimpGradientSegment *</RETURNS>
GimpGradientSegment *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_nth</NAME>
<RETURNS>GimpGradientSegment *</RETURNS>
GimpGradientSegment *seg,gint                 index
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_free</NAME>
<RETURNS>void                  </RETURNS>
GimpGradientSegment *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segments_free</NAME>
<RETURNS>void                  </RETURNS>
GimpGradientSegment *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_split_midpoint</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *lseg,GimpGradientSegment **newl,GimpGradientSegment **newr
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_split_uniform</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *lseg,gint                  parts,GimpGradientSegment **newl,GimpGradientSegment **newr
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_left_color</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,GimpRGB              *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_set_left_color</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,const GimpRGB        *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_right_color</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,GimpRGB              *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_set_right_color</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,const GimpRGB        *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_left_pos</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_set_left_pos</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,gdouble               pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_right_pos</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_set_right_pos</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,gdouble               pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_middle_pos</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_set_middle_pos</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg,gdouble               pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_blending_function</NAME>
<RETURNS>GimpGradientSegmentType</RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_get_coloring_type</NAME>
<RETURNS>GimpGradientSegmentColor</RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_compress</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *range_l,GimpGradientSegment  *range_r,gdouble               new_l,gdouble               new_r
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_blend</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *lseg,GimpGradientSegment  *rseg,const GimpRGB        *rgb1,const GimpRGB        *rgb2,gboolean              blend_colors,gboolean              blend_opacity
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_set_blending_function</NAME>
<RETURNS>void  </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,GimpGradientSegmentType new_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_set_coloring_type</NAME>
<RETURNS>void  </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,GimpGradientSegmentColor new_color
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_flip</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,GimpGradientSegment **final_start_seg,GimpGradientSegment **final_end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_replicate</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,gint                  replicate_times,GimpGradientSegment **final_start_seg,GimpGradientSegment **final_end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_split_midpoint</NAME>
<RETURNS>void  </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,GimpGradientSegment **final_start_seg,GimpGradientSegment **final_end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_split_uniform</NAME>
<RETURNS>void  </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,gint                  parts,GimpGradientSegment **final_start_seg,GimpGradientSegment **final_end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_delete</NAME>
<RETURNS>void    </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg,GimpGradientSegment **final_start_seg,GimpGradientSegment **final_end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_recenter_handles</NAME>
<RETURNS>void  </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_redistribute_handles</NAME>
<RETURNS>void  </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *start_seg,GimpGradientSegment  *end_seg
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_segment_range_move</NAME>
<RETURNS>gdouble </RETURNS>
GimpGradient         *gradient,GimpGradientSegment  *range_l,GimpGradientSegment  *range_r,gdouble               delta,gboolean              control_compress
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_GRID</NAME>
#define GIMP_TYPE_GRID            (gimp_grid_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_GRID</NAME>
#define GIMP_GRID(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GRID, GimpGrid))
</MACRO>
<MACRO>
<NAME>GIMP_GRID_CLASS</NAME>
#define GIMP_GRID_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GRID, GimpGridClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRID</NAME>
#define GIMP_IS_GRID(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GRID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRID_CLASS</NAME>
#define GIMP_IS_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GRID))
</MACRO>
<MACRO>
<NAME>GIMP_GRID_GET_CLASS</NAME>
#define GIMP_GRID_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_GRID, GimpGridClass))
</MACRO>
<STRUCT>
<NAME>GimpGridClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGrid</NAME>
struct _GimpGrid
{
  GimpObject     parent_instance;

  GimpGridStyle  style;
  GimpRGB        fgcolor;
  GimpRGB        bgcolor;
  gdouble        xspacing;
  gdouble        yspacing;
  GimpUnit       spacing_unit;
  gdouble        xoffset;
  gdouble        yoffset;
  GimpUnit       offset_unit;
};
</STRUCT>
<STRUCT>
<NAME>GimpGridClass</NAME>
struct _GimpGridClass
{
  GimpObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_grid_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_grid_parasite_name</NAME>
<RETURNS>const gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_grid_to_parasite</NAME>
<RETURNS>GimpParasite *</RETURNS>
const GimpGrid     *grid
</FUNCTION>
<FUNCTION>
<NAME>gimp_grid_from_parasite</NAME>
<RETURNS>GimpGrid     *</RETURNS>
const GimpParasite *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_color_hash_init</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_color_hash_exit</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_color_hash_invalidate</NAME>
<RETURNS>void   </RETURNS>
GimpImage       *image,gint             index
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_color_hash_rgb_to_indexed</NAME>
<RETURNS>gint   </RETURNS>
const GimpImage *image,gint             r,gint             g,gint             b
</FUNCTION>
<MACRO>
<NAME>GIMP_IMAGE_COLORMAP_SIZE</NAME>
#define GIMP_IMAGE_COLORMAP_SIZE 768
</MACRO>
<FUNCTION>
<NAME>gimp_image_get_colormap</NAME>
<RETURNS>const guchar *</RETURNS>
const GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_colormap_size</NAME>
<RETURNS>gint           </RETURNS>
const GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_colormap</NAME>
<RETURNS>void           </RETURNS>
GimpImage       *image,const guchar    *cmap,gint             n_colors,gboolean         push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_colormap_entry</NAME>
<RETURNS>void           </RETURNS>
GimpImage       *image,gint             color_index,GimpRGB         *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_colormap_entry</NAME>
<RETURNS>void           </RETURNS>
GimpImage       *image,gint             color_index,const GimpRGB   *color,gboolean         push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_colormap_entry</NAME>
<RETURNS>void           </RETURNS>
GimpImage       *image,const GimpRGB   *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_contiguous_region_by_seed</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage     *image,GimpDrawable  *drawable,gboolean       sample_merged,gboolean       antialias,gint           threshold,gboolean       select_transparent,gint           x,gint           y
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_contiguous_region_by_color</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage     *image,GimpDrawable  *drawable,gboolean       sample_merged,gboolean       antialias,gint           threshold,gboolean       select_transparent,const GimpRGB *color
</FUNCTION>
<MACRO>
<NAME>MAXNUMCOLORS</NAME>
#define MAXNUMCOLORS 256
</MACRO>
<FUNCTION>
<NAME>gimp_image_convert</NAME>
<RETURNS>void   </RETURNS>
GimpImage              *image,GimpImageBaseType       new_type,gint                    num_cols,GimpConvertDitherType   dither,gboolean                alpha_dither,gboolean                remove_dups,GimpConvertPaletteType  palette_type,GimpPalette            *custom_palette,GimpProgress           *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_crop</NAME>
<RETURNS>void       </RETURNS>
GimpImage   *image,GimpContext *context,gint         x1,gint         y1,gint         x2,gint         y2,gboolean     active_layer_only,gboolean     crop_layers
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_crop_auto_shrink</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage   *image,gint         x1,gint         y1,gint         x2,gint         y2,gboolean     active_drawable_only,gint        *shrunk_x1,gint        *shrunk_y1,gint        *shrunk_x2,gint        *shrunk_y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_duplicate</NAME>
<RETURNS>GimpImage *</RETURNS>
GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_flip</NAME>
<RETURNS>void   </RETURNS>
GimpImage           *image,GimpContext         *context,GimpOrientationType  flip_type,GimpProgress        *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_grid</NAME>
<RETURNS>GimpGrid *</RETURNS>
GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_grid</NAME>
<RETURNS>void       </RETURNS>
GimpImage *image,GimpGrid  *grid,gboolean   push_undo
</FUNCTION>
<STRUCT>
<NAME>GimpGuide</NAME>
struct _GimpGuide
{
  gint                 ref_count;
  gint                 position;
  GimpOrientationType  orientation;
  guint32              guide_ID;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_add_hguide</NAME>
<RETURNS>GimpGuide *</RETURNS>
GimpImage *image,gint       position,gboolean   push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_vguide</NAME>
<RETURNS>GimpGuide *</RETURNS>
GimpImage *image,gint       position,gboolean   push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_guide_ref</NAME>
<RETURNS>GimpGuide *</RETURNS>
GimpGuide *guide
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_guide_unref</NAME>
<RETURNS>void        </RETURNS>
GimpGuide *guide
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_guide</NAME>
<RETURNS>void        </RETURNS>
GimpImage *image,GimpGuide *guide,gint       position
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_remove_guide</NAME>
<RETURNS>void        </RETURNS>
GimpImage *image,GimpGuide *guide,gboolean   push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_move_guide</NAME>
<RETURNS>void        </RETURNS>
GimpImage *image,GimpGuide *guide,gint       position,gboolean   push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_guide</NAME>
<RETURNS>GimpGuide *</RETURNS>
GimpImage *image,guint32    id
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_next_guide</NAME>
<RETURNS>GimpGuide *</RETURNS>
GimpImage *image,guint32    id,gboolean  *guide_found
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_find_guide</NAME>
<RETURNS>GimpGuide *</RETURNS>
GimpImage *image,gdouble    x,gdouble    y,gdouble    epsilon_x,gdouble    epsilon_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_merge_visible_layers</NAME>
<RETURNS>GimpLayer   *</RETURNS>
GimpImage     *image,GimpContext   *context,GimpMergeType  merge_type,gboolean       discard_invisible
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_merge_down</NAME>
<RETURNS>GimpLayer   *</RETURNS>
GimpImage     *image,GimpLayer     *current_layer,GimpContext   *context,GimpMergeType  merge_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_flatten</NAME>
<RETURNS>GimpLayer   *</RETURNS>
GimpImage     *image,GimpContext   *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_merge_layers</NAME>
<RETURNS>GimpLayer   *</RETURNS>
GimpImage     *image,GSList        *merge_list,GimpContext   *context,GimpMergeType  merge_type,const gchar   *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_merge_visible_vectors</NAME>
<RETURNS>GimpVectors *</RETURNS>
GimpImage     *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_new_get_last_template</NAME>
<RETURNS>GimpTemplate *</RETURNS>
Gimp         *gimp,GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_new_set_last_template</NAME>
<RETURNS>void           </RETURNS>
Gimp         *gimp,GimpTemplate *template
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_pick_color</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage     *image,GimpDrawable  *drawable,gint           x,gint           y,gboolean       sample_merged,gboolean       sample_average,gdouble        average_radius,GimpImageType *sample_type,GimpRGB       *color,gint          *color_index
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_preview_size</NAME>
<RETURNS>void      </RETURNS>
GimpViewable *viewable,gint          size,gboolean      is_popup,gboolean      dot_for_dot,gint         *width,gint         *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_popup_size</NAME>
<RETURNS>gboolean  </RETURNS>
GimpViewable *viewable,gint          width,gint          height,gboolean      dot_for_dot,gint         *popup_width,gint         *popup_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_preview</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpViewable *viewable,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_new_preview</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_resize</NAME>
<RETURNS>void   </RETURNS>
GimpImage             *image,GimpContext           *context,gint                   new_width,gint                   new_height,gint                   offset_x,gint                   offset_y,GimpProgress          *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_resize_with_layers</NAME>
<RETURNS>void   </RETURNS>
GimpImage             *image,GimpContext           *context,gint                   new_width,gint                   new_height,gint                   offset_x,gint                   offset_y,GimpImageResizeLayers  resize_layers,GimpProgress          *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_resize_to_layers</NAME>
<RETURNS>void   </RETURNS>
GimpImage             *image,GimpContext           *context,GimpProgress          *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_rotate</NAME>
<RETURNS>void   </RETURNS>
GimpImage        *image,GimpContext      *context,GimpRotationType  rotate_type,GimpProgress     *progress
</FUNCTION>
<MACRO>
<NAME>GIMP_SAMPLE_POINT_DRAW_SIZE</NAME>
#define GIMP_SAMPLE_POINT_DRAW_SIZE 10
</MACRO>
<STRUCT>
<NAME>GimpSamplePoint</NAME>
struct _GimpSamplePoint
{
  gint                 ref_count;
  gint                 x;
  gint                 y;
  guint32              sample_point_ID;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_add_sample_point_at_pos</NAME>
<RETURNS>GimpSamplePoint *</RETURNS>
GimpImage        *image,gint              x,gint              y,gboolean          push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_sample_point_ref</NAME>
<RETURNS>GimpSamplePoint *</RETURNS>
GimpSamplePoint *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_sample_point_unref</NAME>
<RETURNS>void              </RETURNS>
GimpSamplePoint *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_sample_point</NAME>
<RETURNS>void              </RETURNS>
GimpImage       *image,GimpSamplePoint *sample_point,gint             x,gint             y
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_remove_sample_point</NAME>
<RETURNS>void              </RETURNS>
GimpImage       *image,GimpSamplePoint *sample_point,gboolean         push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_move_sample_point</NAME>
<RETURNS>void              </RETURNS>
GimpImage       *image,GimpSamplePoint *sample_point,gint             x,gint             y,gboolean         push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_find_sample_point</NAME>
<RETURNS>GimpSamplePoint *</RETURNS>
GimpImage       *image,gdouble          x,gdouble          y,gdouble          epsilon_x,gdouble          epsilon_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_scale</NAME>
<RETURNS>void   </RETURNS>
GimpImage             *image,gint                   new_width,gint                   new_height,GimpInterpolationType  interpolation_type,GimpProgress          *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_scale_check</NAME>
<RETURNS>GimpImageScaleCheckType</RETURNS>
const GimpImage       *image,gint                   new_width,gint                   new_height,gint64                 max_memsize,gint64                *new_memsize
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_snap_x</NAME>
<RETURNS>gboolean    </RETURNS>
GimpImage *image,gdouble    x,gdouble   *tx,gdouble    epsilon_x,gboolean   snap_to_guides,gboolean   snap_to_grid,gboolean   snap_to_canvas
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_snap_y</NAME>
<RETURNS>gboolean    </RETURNS>
GimpImage *image,gdouble    y,gdouble   *ty,gdouble    epsilon_y,gboolean   snap_to_guides,gboolean   snap_to_grid,gboolean   snap_to_canvas
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_snap_point</NAME>
<RETURNS>gboolean    </RETURNS>
GimpImage *image,gdouble    x,gdouble    y,gdouble   *tx,gdouble   *ty,gdouble    epsilon_x,gdouble    epsilon_y,gboolean   snap_to_guides,gboolean   snap_to_grid,gboolean   snap_to_canvas,gboolean   snap_to_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_snap_rectangle</NAME>
<RETURNS>gboolean    </RETURNS>
GimpImage *image,gdouble    x1,gdouble    y1,gdouble    x2,gdouble    y2,gdouble   *tx1,gdouble   *ty1,gdouble    epsilon_x,gdouble    epsilon_y,gboolean   snap_to_guides,gboolean   snap_to_grid,gboolean   snap_to_canvas,gboolean   snap_to_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_type</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_size</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_resolution</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_guide</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpGuide     *guide
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_grid</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpGrid      *grid
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_sample_point</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpSamplePoint *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_colormap</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_drawable</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpDrawable  *drawable,TileManager   *tiles,gboolean       sparse,gint           x,gint           y,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_drawable_mod</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpDrawable  *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_mask</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpChannel   *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_item_rename</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpItem      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_item_displace</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpItem      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_item_visibility</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpItem      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_item_linked</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpItem      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_add</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer,gint           prev_position,GimpLayer     *prev_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_remove</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer,gint           prev_position,GimpLayer     *prev_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_reposition</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_mode</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_opacity</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_lock_alpha</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_text_layer</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpTextLayer *layer,const GParamSpec *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_text_layer_modified</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpTextLayer *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_mask_add</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer,GimpLayerMask *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_mask_remove</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *layer,GimpLayerMask *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_mask_apply</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayerMask *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_layer_mask_show</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayerMask *mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_channel_add</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpChannel   *channel,gint           prev_position,GimpChannel   *prev_channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_channel_remove</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpChannel   *channel,gint           prev_position,GimpChannel   *prev_channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_channel_reposition</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_channel_color</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpChannel   *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_vectors_add</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpVectors   *vectors,gint           prev_position,GimpVectors   *prev_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_vectors_remove</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpVectors   *channel,gint           prev_position,GimpVectors   *prev_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_vectors_mod</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpVectors   *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_vectors_reposition</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpVectors   *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_fs_to_layer</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *floating_layer,GimpDrawable  *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_fs_rigor</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *floating_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_fs_relax</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpLayer     *floating_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_parasite</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,const GimpParasite *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_image_parasite_remove</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,const gchar   *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_item_parasite</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpItem      *item,const GimpParasite *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_item_parasite_remove</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc,GimpItem      *item,const gchar   *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push_cantundo</NAME>
<RETURNS>gboolean </RETURNS>
GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_redo</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_free</NAME>
<RETURNS>void       </RETURNS>
GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_group_start</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage        *image,GimpUndoType      undo_type,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_group_end</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_push</NAME>
<RETURNS>GimpUndo *</RETURNS>
GimpImage        *image,GType             object_type,gint64            size,gsize             struct_size,GimpUndoType      undo_type,const gchar      *name,GimpDirtyMask     dirty_mask,GimpUndoPopFunc   pop_func,GimpUndoFreeFunc  free_func,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_can_compress</NAME>
<RETURNS>GimpUndo *</RETURNS>
GimpImage        *image,GType             object_type,GimpUndoType      undo_type
</FUNCTION>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_IS_RGB</NAME>
#define GIMP_IMAGE_TYPE_IS_RGB(t)          ((t) == GIMP_RGB_IMAGE ||         \
                                            (t) == GIMP_RGBA_IMAGE)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_IS_GRAY</NAME>
#define GIMP_IMAGE_TYPE_IS_GRAY(t)         ((t) == GIMP_GRAY_IMAGE ||        \
                                            (t) == GIMP_GRAYA_IMAGE)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_IS_INDEXED</NAME>
#define GIMP_IMAGE_TYPE_IS_INDEXED(t)      ((t) == GIMP_INDEXED_IMAGE ||     \
                                            (t) == GIMP_INDEXEDA_IMAGE)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_HAS_ALPHA</NAME>
#define GIMP_IMAGE_TYPE_HAS_ALPHA(t)       ((t) == GIMP_RGBA_IMAGE  ||       \
                                            (t) == GIMP_GRAYA_IMAGE ||       \
                                            (t) == GIMP_INDEXEDA_IMAGE)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_WITH_ALPHA</NAME>
#define GIMP_IMAGE_TYPE_WITH_ALPHA(t)     (((t) == GIMP_RGB_IMAGE ||         \
                                            (t) == GIMP_RGBA_IMAGE) ?        \
                                           GIMP_RGBA_IMAGE :                 \
                                           ((t) == GIMP_GRAY_IMAGE ||        \
                                            (t) == GIMP_GRAYA_IMAGE) ?       \
                                           GIMP_GRAYA_IMAGE :                \
                                           ((t) == GIMP_INDEXED_IMAGE ||     \
                                            (t) == GIMP_INDEXEDA_IMAGE) ?    \
                                           GIMP_INDEXEDA_IMAGE : -1)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_WITHOUT_ALPHA</NAME>
#define GIMP_IMAGE_TYPE_WITHOUT_ALPHA(t)  (((t) == GIMP_RGB_IMAGE ||         \
                                            (t) == GIMP_RGBA_IMAGE) ?        \
                                           GIMP_RGB_IMAGE :                  \
                                           ((t) == GIMP_GRAY_IMAGE ||        \
                                            (t) == GIMP_GRAYA_IMAGE) ?       \
                                           GIMP_GRAY_IMAGE :                 \
                                           ((t) == GIMP_INDEXED_IMAGE ||     \
                                            (t) == GIMP_INDEXEDA_IMAGE) ?    \
                                           GIMP_INDEXED_IMAGE : -1)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_BYTES</NAME>
#define GIMP_IMAGE_TYPE_BYTES(t)           ((t) == GIMP_RGBA_IMAGE     ? 4 : \
                                            (t) == GIMP_RGB_IMAGE      ? 3 : \
                                            (t) == GIMP_GRAYA_IMAGE    ? 2 : \
                                            (t) == GIMP_GRAY_IMAGE     ? 1 : \
                                            (t) == GIMP_INDEXEDA_IMAGE ? 2 : \
                                            (t) == GIMP_INDEXED_IMAGE  ? 1 : -1)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_BASE_TYPE</NAME>
#define GIMP_IMAGE_TYPE_BASE_TYPE(t)      (((t) == GIMP_RGB_IMAGE ||         \
                                            (t) == GIMP_RGBA_IMAGE) ?        \
                                           GIMP_RGB :                        \
                                           ((t) == GIMP_GRAY_IMAGE ||        \
                                            (t) == GIMP_GRAYA_IMAGE) ?       \
                                           GIMP_GRAY :                       \
                                           ((t) == GIMP_INDEXED_IMAGE ||     \
                                            (t) == GIMP_INDEXEDA_IMAGE) ?    \
                                           GIMP_INDEXED : -1)
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_TYPE_FROM_BASE_TYPE</NAME>
#define GIMP_IMAGE_TYPE_FROM_BASE_TYPE(b)  ((b) == GIMP_RGB ?                \
                                            GIMP_RGB_IMAGE :                 \
                                            (b) == GIMP_GRAY ?               \
                                            GIMP_GRAY_IMAGE :                \
                                            (b) == GIMP_INDEXED ?            \
                                            GIMP_INDEXED_IMAGE : -1)
</MACRO>
<STRUCT>
<NAME>GimpImageFlushAccumulator</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageFlushAccumulator</NAME>
struct _GimpImageFlushAccumulator
{
  gboolean alpha_changed;
  gboolean mask_changed;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_IMAGE</NAME>
#define GIMP_TYPE_IMAGE            (gimp_image_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE</NAME>
#define GIMP_IMAGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE, GimpImage))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_CLASS</NAME>
#define GIMP_IMAGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE, GimpImageClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE</NAME>
#define GIMP_IS_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_CLASS</NAME>
#define GIMP_IS_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_GET_CLASS</NAME>
#define GIMP_IMAGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE, GimpImageClass))
</MACRO>
<STRUCT>
<NAME>GimpImageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImage</NAME>
struct _GimpImage
{
  GimpViewable       parent_instance;

  Gimp              *gimp;                  /*  the GIMP the image belongs to*/

  gint               ID;                    /*  provides a unique ID         */

  GimpPlugInProcedure *save_proc;           /*  last PDB save proc used      */

  gint               width, height;         /*  width and height attributes  */
  gdouble            xresolution;           /*  image x-res, in dpi          */
  gdouble            yresolution;           /*  image y-res, in dpi          */
  GimpUnit           resolution_unit;       /*  resolution unit              */
  GimpImageBaseType  base_type;             /*  base gimp_image type         */

  guchar            *cmap;                  /*  colormap--for indexed        */
  gint               num_cols;              /*  number of cols--for indexed  */

  gint               dirty;                 /*  dirty flag -- # of ops       */
  guint              dirty_time;            /*  time when image became dirty */
  gint               undo_freeze_count;     /*  counts the _freeze's         */

  gint               instance_count;        /*  number of instances          */
  gint               disp_count;            /*  number of displays           */

  GimpTattoo         tattoo_state;          /*  the next unique tattoo to use*/

  TileManager       *shadow;                /*  shadow buffer tiles          */

  GimpProjection    *projection;            /*  projection layers & channels */

  GList             *guides;                /*  guides                       */
  GimpGrid          *grid;                  /*  grid                         */
  GList             *sample_points;         /*  color sample points          */

  /*  Layer/Channel attributes  */
  GimpContainer     *layers;                /*  the list of layers           */
  GimpContainer     *channels;              /*  the list of masks            */
  GimpContainer     *vectors;               /*  the list of vectors          */
  GSList            *layer_stack;           /*  the layers in MRU order      */

  GQuark             layer_update_handler;
  GQuark             layer_visible_handler;
  GQuark             layer_alpha_handler;
  GQuark             channel_update_handler;
  GQuark             channel_visible_handler;
  GQuark             channel_name_changed_handler;
  GQuark             channel_color_changed_handler;

  GimpLayer         *active_layer;          /*  the active layer             */
  GimpChannel       *active_channel;        /*  the active channel           */
  GimpVectors       *active_vectors;        /*  the active vectors           */

  GimpLayer         *floating_sel;          /*  the FS layer                 */
  GimpChannel       *selection_mask;        /*  the selection mask channel   */

  GimpParasiteList  *parasites;             /*  Plug-in parasite data        */

  gboolean           visible[MAX_CHANNELS]; /*  visible channels             */
  gboolean           active[MAX_CHANNELS];  /*  active channels              */

  gboolean           quick_mask_state;      /*  TRUE if quick mask is on       */
  gboolean           quick_mask_inverted;   /*  TRUE if quick mask is inverted */
  GimpRGB            quick_mask_color;      /*  rgba triplet of the color      */

  /*  Undo apparatus  */
  GimpUndoStack     *undo_stack;            /*  stack for undo operations    */
  GimpUndoStack     *redo_stack;            /*  stack for redo operations    */
  gint               group_count;           /*  nested undo groups           */
  GimpUndoType       pushing_undo_group;    /*  undo group status flag       */

  /*  Composite preview  */
  TempBuf           *comp_preview;          /*  the composite preview        */
  gboolean           comp_preview_valid;    /*  preview valid-1/channel      */

  /*  Signal emmision accumulator  */
  GimpImageFlushAccumulator  flush_accum;
};
</STRUCT>
<STRUCT>
<NAME>GimpImageClass</NAME>
struct _GimpImageClass
{
  GimpViewableClass  parent_class;

  /*  signals  */
  void (* mode_changed)                 (GimpImage            *image);
  void (* alpha_changed)                (GimpImage            *image);
  void (* floating_selection_changed)   (GimpImage            *image);
  void (* active_layer_changed)         (GimpImage            *image);
  void (* active_channel_changed)       (GimpImage            *image);
  void (* active_vectors_changed)       (GimpImage            *image);
  void (* component_visibility_changed) (GimpImage            *image,
                                         GimpChannelType       channel);
  void (* component_active_changed)     (GimpImage            *image,
                                         GimpChannelType       channel);
  void (* mask_changed)                 (GimpImage            *image);
  void (* resolution_changed)           (GimpImage            *image);
  void (* unit_changed)                 (GimpImage            *image);
  void (* quick_mask_changed)           (GimpImage            *image);
  void (* selection_control)            (GimpImage            *image,
                                         GimpSelectionControl  control);

  void (* clean)                        (GimpImage            *image,
                                         GimpDirtyMask         dirty_mask);
  void (* dirty)                        (GimpImage            *image,
                                         GimpDirtyMask         dirty_mask);
  void (* update)                       (GimpImage            *image,
                                         gint                  x,
                                         gint                  y,
                                         gint                  width,
                                         gint                  height);
  void (* update_guide)                 (GimpImage            *image,
                                         GimpGuide            *guide);
  void (* update_sample_point)          (GimpImage            *image,
                                         GimpSamplePoint      *sample_point);
  void (* sample_point_added)           (GimpImage            *image,
                                         GimpSamplePoint      *sample_point);
  void (* sample_point_removed)         (GimpImage            *image,
                                         GimpSamplePoint      *sample_point);
  void (* colormap_changed)             (GimpImage            *image,
                                         gint                  color_index);
  void (* undo_event)                   (GimpImage            *image,
                                         GimpUndoEvent         event,
                                         GimpUndo             *undo);

  void (* flush)                        (GimpImage            *image);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_new</NAME>
<RETURNS>GimpImage     *</RETURNS>
Gimp               *gimp,gint                width,gint                height,GimpImageBaseType   base_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_base_type</NAME>
<RETURNS>GimpImageBaseType  </RETURNS>
const GimpImage  *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_base_type_with_alpha</NAME>
<RETURNS>GimpImageType           </RETURNS>
const GimpImage  *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_combination_mode</NAME>
<RETURNS>CombinationMode    </RETURNS>
GimpImageType     dest_type,gint              src_bytes
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_ID</NAME>
<RETURNS>gint            </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_by_ID</NAME>
<RETURNS>GimpImage     *</RETURNS>
Gimp               *gimp,gint                id
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_uri</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,const gchar        *uri
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_uri</NAME>
<RETURNS>const gchar   *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_filename</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,const gchar        *filename
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_filename</NAME>
<RETURNS>gchar         *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_save_proc</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_save_proc</NAME>
<RETURNS>GimpPlugInProcedure *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_resolution</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,gdouble             xres,gdouble             yres
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_resolution</NAME>
<RETURNS>void            </RETURNS>
const GimpImage    *image,gdouble            *xres,gdouble            *yres
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_resolution_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_unit</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpUnit            unit
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_unit</NAME>
<RETURNS>GimpUnit        </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_unit_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_width</NAME>
<RETURNS>gint                </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_height</NAME>
<RETURNS>gint                </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_has_alpha</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_is_empty</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_floating_sel</NAME>
<RETURNS>GimpLayer     *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_floating_selection_changed</NAME>
<RETURNS>void       </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_mask</NAME>
<RETURNS>GimpChannel   *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_mask_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_component_index</NAME>
<RETURNS>gint            </RETURNS>
const GimpImage    *image,GimpChannelType     channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_component_active</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpChannelType     type,gboolean            active
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_component_active</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpImage    *image,GimpChannelType     type
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_component_visible</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpChannelType     type,gboolean            visible
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_component_visible</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpImage    *image,GimpChannelType     type
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_mode_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_alpha_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_update</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,gint                x,gint                y,gint                width,gint                height
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_update_guide</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpGuide          *guide
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_update_sample_point</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpSamplePoint    *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_sample_point_added</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpSamplePoint    *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_sample_point_removed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpSamplePoint    *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_colormap_changed</NAME>
<RETURNS>void                </RETURNS>
GimpImage          *image,gint                col
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_selection_control</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpSelectionControl  control
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_quick_mask_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_is_enabled</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_enable</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_disable</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_freeze</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_thaw</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_undo_event</NAME>
<RETURNS>void                </RETURNS>
GimpImage          *image,GimpUndoEvent       event,GimpUndo           *undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_dirty</NAME>
<RETURNS>gint            </RETURNS>
GimpImage          *image,GimpDirtyMask       dirty_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_clean</NAME>
<RETURNS>gint            </RETURNS>
GimpImage          *image,GimpDirtyMask       dirty_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_clean_all</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_flush</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_foreground</NAME>
<RETURNS>void            </RETURNS>
const GimpImage    *image,const GimpDrawable *drawable,GimpContext        *context,guchar             *fg
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_background</NAME>
<RETURNS>void            </RETURNS>
const GimpImage    *image,const GimpDrawable *drawable,GimpContext        *context,guchar             *bg
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_color</NAME>
<RETURNS>void            </RETURNS>
const GimpImage    *src_image,GimpImageType       src_type,const guchar       *src,guchar             *rgba
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_transform_rgb</NAME>
<RETURNS>void            </RETURNS>
const GimpImage    *dest_image,const GimpDrawable *dest_drawable,const GimpRGB      *rgb,guchar             *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_transform_color</NAME>
<RETURNS>void            </RETURNS>
const GimpImage    *dest_image,const GimpDrawable *dest_drawable,guchar             *dest,GimpImageBaseType   src_type,const guchar       *src
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_transform_temp_buf</NAME>
<RETURNS>TempBuf       *</RETURNS>
const GimpImage    *dest_image,const GimpDrawable *dest_drawable,TempBuf            *temp_buf,gboolean           *new_buf
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_shadow_tiles</NAME>
<RETURNS>TileManager   *</RETURNS>
GimpImage          *image,gint                width,gint                height,gint                bpp
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_free_shadow_tiles</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_parasite_find</NAME>
<RETURNS>const GimpParasite *</RETURNS>
const GimpImage    *image,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_parasite_list</NAME>
<RETURNS>gchar        **</RETURNS>
const GimpImage    *image,gint               *count
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_parasite_attach</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,const GimpParasite *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_parasite_detach</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_new_tattoo</NAME>
<RETURNS>GimpTattoo      </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_tattoo_state</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpTattoo          val
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_tattoo_state</NAME>
<RETURNS>GimpTattoo      </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_layers</NAME>
<RETURNS>GimpContainer *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_channels</NAME>
<RETURNS>GimpContainer *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_vectors</NAME>
<RETURNS>GimpContainer *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_active_drawable</NAME>
<RETURNS>GimpDrawable  *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_active_layer</NAME>
<RETURNS>GimpLayer     *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_active_channel</NAME>
<RETURNS>GimpChannel   *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_active_vectors</NAME>
<RETURNS>GimpVectors   *</RETURNS>
const GimpImage    *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_active_layer</NAME>
<RETURNS>GimpLayer     *</RETURNS>
GimpImage          *image,GimpLayer          *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_active_channel</NAME>
<RETURNS>GimpChannel   *</RETURNS>
GimpImage          *image,GimpChannel        *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_unset_active_channel</NAME>
<RETURNS>GimpChannel   *</RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_active_vectors</NAME>
<RETURNS>GimpVectors   *</RETURNS>
GimpImage          *image,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_active_layer_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage         *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_active_channel_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage         *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_active_vectors_changed</NAME>
<RETURNS>void            </RETURNS>
GimpImage         *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_layer_index</NAME>
<RETURNS>gint            </RETURNS>
const GimpImage    *image,const GimpLayer    *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_channel_index</NAME>
<RETURNS>gint            </RETURNS>
const GimpImage    *image,const GimpChannel  *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_vectors_index</NAME>
<RETURNS>gint            </RETURNS>
const GimpImage    *image,const GimpVectors  *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_layer_by_tattoo</NAME>
<RETURNS>GimpLayer     *</RETURNS>
const GimpImage    *image,GimpTattoo          tatoo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_channel_by_tattoo</NAME>
<RETURNS>GimpChannel   *</RETURNS>
const GimpImage    *image,GimpTattoo          tatoo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_vectors_by_tattoo</NAME>
<RETURNS>GimpVectors   *</RETURNS>
const GimpImage    *image,GimpTattoo          tatoo
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_layer_by_name</NAME>
<RETURNS>GimpLayer     *</RETURNS>
const GimpImage    *image,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_channel_by_name</NAME>
<RETURNS>GimpChannel   *</RETURNS>
const GimpImage    *image,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_vectors_by_name</NAME>
<RETURNS>GimpVectors   *</RETURNS>
const GimpImage    *image,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_layer</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpLayer          *layer,gint                position
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_remove_layer</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpLayer          *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_raise_layer</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpLayer          *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_lower_layer</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpLayer          *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_raise_layer_to_top</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpLayer          *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_lower_layer_to_bottom</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpLayer          *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_position_layer</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpLayer          *layer,gint                new_index,gboolean            push_undo,const gchar        *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_channel</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpChannel        *channel,gint                position
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_remove_channel</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpChannel        *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_raise_channel</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpChannel        *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_raise_channel_to_top</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpChannel        *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_lower_channel</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpChannel        *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_lower_channel_to_bottom</NAME>
<RETURNS>gboolean      </RETURNS>
GimpImage          *image,GimpChannel        *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_position_channel</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpChannel        *channel,gint                new_index,gboolean            push_undo,const gchar        *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_add_vectors</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpVectors        *vectors,gint                position
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_remove_vectors</NAME>
<RETURNS>void            </RETURNS>
GimpImage          *image,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_raise_vectors</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_raise_vectors_to_top</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_lower_vectors</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_lower_vectors_to_bottom</NAME>
<RETURNS>gboolean      </RETURNS>
GimpImage          *image,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_position_vectors</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImage          *image,GimpVectors        *vectors,gint                new_index,gboolean            push_undo,const gchar        *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_layer_boundary</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpImage    *image,BoundSeg          **segs,gint               *n_segs
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_pick_correlate_layer</NAME>
<RETURNS>GimpLayer     *</RETURNS>
const GimpImage    *image,gint                x,gint                y
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_coords_in_active_drawable</NAME>
<RETURNS>gboolean    </RETURNS>
GimpImage          *image,const GimpCoords   *coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_invalidate_layer_previews</NAME>
<RETURNS>void        </RETURNS>
GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_invalidate_channel_previews</NAME>
<RETURNS>void      </RETURNS>
GimpImage          *image
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGEFILE</NAME>
#define GIMP_TYPE_IMAGEFILE            (gimp_imagefile_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGEFILE</NAME>
#define GIMP_IMAGEFILE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGEFILE, GimpImagefile))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGEFILE_CLASS</NAME>
#define GIMP_IMAGEFILE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGEFILE, GimpImagefileClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGEFILE</NAME>
#define GIMP_IS_IMAGEFILE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGEFILE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGEFILE_CLASS</NAME>
#define GIMP_IS_IMAGEFILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGEFILE))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGEFILE_GET_CLASS</NAME>
#define GIMP_IMAGEFILE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGEFILE, GimpImagefileClass))
</MACRO>
<STRUCT>
<NAME>GimpImagefileClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImagefile</NAME>
struct _GimpImagefile
{
  GimpViewable        parent_instance;

  Gimp               *gimp;
  GimpThumbnail      *thumbnail;
  gchar              *mime_type;
  gchar              *description;
  gboolean            static_desc;
};
</STRUCT>
<STRUCT>
<NAME>GimpImagefileClass</NAME>
struct _GimpImagefileClass
{
  GimpViewableClass   parent_class;

  void (* info_changed) (GimpImagefile *imagefile);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_imagefile_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_new</NAME>
<RETURNS>GimpImagefile *</RETURNS>
Gimp          *gimp,const gchar   *uri
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_update</NAME>
<RETURNS>void            </RETURNS>
GimpImagefile *imagefile
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_create_thumbnail</NAME>
<RETURNS>void            </RETURNS>
GimpImagefile *imagefile,GimpContext   *context,GimpProgress  *progress,gint           size,gboolean       replace
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_create_thumbnail_weak</NAME>
<RETURNS>void            </RETURNS>
GimpImagefile *imagefile,GimpContext   *context,GimpProgress  *progress,gint           size,gboolean       replace
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_check_thumbnail</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImagefile *imagefile
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_save_thumbnail</NAME>
<RETURNS>gboolean        </RETURNS>
GimpImagefile *imagefile,const gchar   *mime_type,GimpImage     *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_imagefile_get_desc_string</NAME>
<RETURNS>const gchar   *</RETURNS>
GimpImagefile *imagefile
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpImageMapApplyFunc</NAME>
<RETURNS>void </RETURNS>
gpointer     data,
                                        PixelRegion *srcPR,
                                        PixelRegion *destPR
</USER_FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_MAP</NAME>
#define GIMP_TYPE_IMAGE_MAP            (gimp_image_map_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP</NAME>
#define GIMP_IMAGE_MAP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_MAP, GimpImageMap))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_CLASS</NAME>
#define GIMP_IMAGE_MAP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_MAP, GimpImageMapClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_MAP</NAME>
#define GIMP_IS_IMAGE_MAP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_MAP))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_MAP_CLASS</NAME>
#define GIMP_IS_IMAGE_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_MAP))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_GET_CLASS</NAME>
#define GIMP_IMAGE_MAP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_MAP, GimpImageMapClass))
</MACRO>
<STRUCT>
<NAME>GimpImageMapClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageMapClass</NAME>
struct _GimpImageMapClass
{
  GimpObjectClass  parent_class;

  void (* flush) (GimpImageMap *image_map);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_map_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_map_new</NAME>
<RETURNS>GimpImageMap *</RETURNS>
GimpDrawable          *drawable,const gchar           *undo_desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_map_apply</NAME>
<RETURNS>void           </RETURNS>
GimpImageMap          *image_map,GimpImageMapApplyFunc  apply_func,gpointer               apply_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_map_commit</NAME>
<RETURNS>void           </RETURNS>
GimpImageMap          *image_map
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_map_clear</NAME>
<RETURNS>void           </RETURNS>
GimpImageMap          *image_map
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_map_abort</NAME>
<RETURNS>void           </RETURNS>
GimpImageMap          *image_map
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INTERPRETER_DB</NAME>
#define GIMP_TYPE_INTERPRETER_DB            (gimp_interpreter_db_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_INTERPRETER_DB</NAME>
#define GIMP_INTERPRETER_DB(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_INTERPRETER_DB, GimpInterpreterDB))
</MACRO>
<MACRO>
<NAME>GIMP_INTERPRETER_DB_CLASS</NAME>
#define GIMP_INTERPRETER_DB_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_INTERPRETER_DB, GimpInterpreterDBClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INTERPRETER_DB</NAME>
#define GIMP_IS_INTERPRETER_DB(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_INTERPRETER_DB))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INTERPRETER_DB_CLASS</NAME>
#define GIMP_IS_INTERPRETER_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_INTERPRETER_DB))
</MACRO>
<MACRO>
<NAME>GIMP_INTERPRETER_DB_GET_CLASS</NAME>
#define GIMP_INTERPRETER_DB_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_INTERPRETER_DB, GimpInterpreterDBClass))
</MACRO>
<STRUCT>
<NAME>GimpInterpreterDBClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpInterpreterDB</NAME>
struct _GimpInterpreterDB
{
  GObject     parent_instance;

  GHashTable *programs;

  GSList     *magics;
  GHashTable *magic_names;

  GHashTable *extensions;
  GHashTable *extension_names;
};
</STRUCT>
<STRUCT>
<NAME>GimpInterpreterDBClass</NAME>
struct _GimpInterpreterDBClass
{
  GObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_interpreter_db_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_interpreter_db_new</NAME>
<RETURNS>GimpInterpreterDB *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_interpreter_db_load</NAME>
<RETURNS>void                </RETURNS>
GimpInterpreterDB  *db,const gchar        *interp_path
</FUNCTION>
<FUNCTION>
<NAME>gimp_interpreter_db_clear</NAME>
<RETURNS>void                </RETURNS>
GimpInterpreterDB  *db
</FUNCTION>
<FUNCTION>
<NAME>gimp_interpreter_db_resolve</NAME>
<RETURNS>gchar             *</RETURNS>
GimpInterpreterDB  *db,const gchar        *program_path,gchar             **interp_arg
</FUNCTION>
<ENUM>
<NAME>GimpItemLinkedMask</NAME>
typedef enum
{
  GIMP_ITEM_LINKED_LAYERS   = 1 << 0,
  GIMP_ITEM_LINKED_CHANNELS = 1 << 1,
  GIMP_ITEM_LINKED_VECTORS  = 1 << 2,

  GIMP_ITEM_LINKED_ALL      = (GIMP_ITEM_LINKED_LAYERS   |
                               GIMP_ITEM_LINKED_CHANNELS |
                               GIMP_ITEM_LINKED_VECTORS)
} GimpItemLinkedMask;
</ENUM>
<FUNCTION>
<NAME>gimp_item_linked_translate</NAME>
<RETURNS>void   </RETURNS>
GimpItem               *item,gint                    offset_x,gint                    offset_y,gboolean                push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_linked_flip</NAME>
<RETURNS>void   </RETURNS>
GimpItem               *item,GimpContext            *context,GimpOrientationType     flip_type,gdouble                 axis,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_linked_rotate</NAME>
<RETURNS>void   </RETURNS>
GimpItem               *item,GimpContext            *context,GimpRotationType        rotate_type,gdouble                 center_x,gdouble                 center_y,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_linked_transform</NAME>
<RETURNS>void   </RETURNS>
GimpItem               *item,GimpContext            *context,const GimpMatrix3      *matrix,GimpTransformDirection  direction,GimpInterpolationType   interpolation_type,gboolean                supersample,gint                    recursion_level,gboolean                clip_result,GimpProgress           *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_linked_get_list</NAME>
<RETURNS>GList *</RETURNS>
GimpItem               *item,GimpItemLinkedMask      which
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_preview_size</NAME>
<RETURNS>void      </RETURNS>
GimpViewable *viewable,gint          size,gboolean      is_popup,gboolean      dot_for_dot,gint         *width,gint         *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_popup_size</NAME>
<RETURNS>gboolean  </RETURNS>
GimpViewable *viewable,gint          width,gint          height,gboolean      dot_for_dot,gint         *popup_width,gint         *popup_height
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ITEM</NAME>
#define GIMP_TYPE_ITEM            (gimp_item_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ITEM</NAME>
#define GIMP_ITEM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ITEM, GimpItem))
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_CLASS</NAME>
#define GIMP_ITEM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ITEM, GimpItemClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ITEM</NAME>
#define GIMP_IS_ITEM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ITEM))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ITEM_CLASS</NAME>
#define GIMP_IS_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ITEM))
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_GET_CLASS</NAME>
#define GIMP_ITEM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ITEM, GimpItemClass))
</MACRO>
<STRUCT>
<NAME>GimpItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpItem</NAME>
struct _GimpItem
{
  GimpViewable      parent_instance;

  gint              ID;                 /*  provides a unique ID     */
  guint32           tattoo;             /*  provides a permanent ID  */

  GimpImage        *image;              /*  item owner               */

  GimpParasiteList *parasites;          /*  Plug-in parasite data    */

  gint              width, height;      /*  size in pixels           */
  gint              offset_x, offset_y; /*  pixel offset in image    */

  gboolean          visible;            /*  control visibility       */
  gboolean          linked;             /*  control linkage          */

  gboolean          floating;           /*  added to an image?       */
  gboolean          removed;            /*  removed from the image?  */
};
</STRUCT>
<STRUCT>
<NAME>GimpItemClass</NAME>
struct _GimpItemClass
{
  GimpViewableClass  parent_class;

  /*  signals  */
  void       (* removed)            (GimpItem      *item);
  void       (* visibility_changed) (GimpItem      *item);
  void       (* linked_changed)     (GimpItem      *item);

  /*  virtual functions  */
  gboolean   (* is_attached)  (GimpItem               *item);
  GimpItem * (* duplicate)    (GimpItem               *item,
                               GType                   new_type,
                               gboolean                add_alpha);
  void       (* convert)      (GimpItem               *item,
                               GimpImage              *dest_image);
  gboolean   (* rename)       (GimpItem               *item,
                               const gchar            *new_name,
                               const gchar            *undo_desc);
  void       (* translate)    (GimpItem               *item,
                               gint                    offset_x,
                               gint                    offset_y,
                               gboolean                push_undo);
  void       (* scale)        (GimpItem               *item,
                               gint                    new_width,
                               gint                    new_height,
                               gint                    new_offset_x,
                               gint                    new_offset_y,
                               GimpInterpolationType   interpolation_type,
                               GimpProgress           *progress);
  void       (* resize)       (GimpItem               *item,
                               GimpContext            *context,
                               gint                    new_width,
                               gint                    new_height,
                               gint                    offset_x,
                               gint                    offset_y);
  void       (* flip)         (GimpItem               *item,
                               GimpContext            *context,
                               GimpOrientationType     flip_type,
                               gdouble                 axis,
                               gboolean                clip_result);
  void       (* rotate)       (GimpItem               *item,
                               GimpContext            *context,
                               GimpRotationType        rotate_type,
                               gdouble                 center_x,
                               gdouble                 center_y,
                               gboolean                clip_result);
  void       (* transform)    (GimpItem               *item,
                               GimpContext            *context,
                               const GimpMatrix3      *matrix,
                               GimpTransformDirection  direction,
                               GimpInterpolationType   interpolation_type,
                               gboolean                supersample,
                               gint                    recursion_level,
                               gboolean                clip_result,
                               GimpProgress           *progress);
  gboolean   (* stroke)       (GimpItem               *item,
                               GimpDrawable           *drawable,
                               GimpStrokeDesc         *stroke_desc);

  const gchar *default_name;
  const gchar *rename_desc;
  const gchar *translate_desc;
  const gchar *scale_desc;
  const gchar *resize_desc;
  const gchar *flip_desc;
  const gchar *rotate_desc;
  const gchar *transform_desc;
  const gchar *stroke_desc;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_item_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_is_floating</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_sink</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_removed</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_is_removed</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_is_attached</NAME>
<RETURNS>gboolean        </RETURNS>
GimpItem           *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_configure</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpImage          *image,gint                offset_x,gint                offset_y,gint                width,gint                height,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_duplicate</NAME>
<RETURNS>GimpItem      *</RETURNS>
GimpItem           *item,GType               new_type,gboolean            add_alpha
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_convert</NAME>
<RETURNS>GimpItem      *</RETURNS>
GimpItem           *item,GimpImage          *dest_image,GType               new_type,gboolean            add_alpha
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_rename</NAME>
<RETURNS>gboolean        </RETURNS>
GimpItem           *item,const gchar        *new_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_width</NAME>
<RETURNS>gint            </RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_height</NAME>
<RETURNS>gint            </RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_offsets</NAME>
<RETURNS>void            </RETURNS>
const GimpItem     *item,gint               *offset_x,gint               *offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_translate</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,gint                offset_x,gint                offset_y,gboolean            push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_check_scaling</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpItem     *item,gint                new_width,gint                new_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_scale</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,gint                new_width,gint                new_height,gint                new_offset_x,gint                new_offset_y,GimpInterpolationType interpolation,GimpProgress       *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_scale_by_factors</NAME>
<RETURNS>gboolean        </RETURNS>
GimpItem           *item,gdouble             w_factor,gdouble             h_factor,GimpInterpolationType interpolation,GimpProgress       *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_scale_by_origin</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,gint                new_width,gint                new_height,GimpInterpolationType interpolation,GimpProgress       *progress,gboolean            local_origin
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_resize</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpContext        *context,gint                new_width,gint                new_height,gint                offset_x,gint                offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_resize_to_image</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_flip</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpContext        *context,GimpOrientationType flip_type,gdouble             axis,gboolean            flip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_rotate</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpContext        *context,GimpRotationType    rotate_type,gdouble             center_x,gdouble             center_y,gboolean            flip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_transform</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpContext        *context,const GimpMatrix3  *matrix,GimpTransformDirection direction,GimpInterpolationType interpolation_type,gboolean            supersample,gint                recursion_level,gboolean            clip_result,GimpProgress       *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_stroke</NAME>
<RETURNS>gboolean        </RETURNS>
GimpItem           *item,GimpDrawable       *drawable,GimpContext        *context,GimpStrokeDesc     *stroke_desc,gboolean            use_default_values
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_ID</NAME>
<RETURNS>gint            </RETURNS>
GimpItem           *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_by_ID</NAME>
<RETURNS>GimpItem      *</RETURNS>
Gimp               *gimp,gint                id
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_tattoo</NAME>
<RETURNS>GimpTattoo      </RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_set_tattoo</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpTattoo          tattoo
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_image</NAME>
<RETURNS>GimpImage     *</RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_set_image</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,GimpImage          *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_parasite_attach</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,const GimpParasite *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_parasite_detach</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_parasite_find</NAME>
<RETURNS>const GimpParasite *</RETURNS>
const GimpItem     *item,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_parasite_list</NAME>
<RETURNS>gchar        **</RETURNS>
const GimpItem     *item,gint               *count
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_visible</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpItem     *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_set_visible</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,gboolean            visible,gboolean            push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_set_linked</NAME>
<RETURNS>void            </RETURNS>
GimpItem           *item,gboolean            linked,gboolean            push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_get_linked</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpItem     *item
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ITEM_UNDO</NAME>
#define GIMP_TYPE_ITEM_UNDO            (gimp_item_undo_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_UNDO</NAME>
#define GIMP_ITEM_UNDO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ITEM_UNDO, GimpItemUndo))
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_UNDO_CLASS</NAME>
#define GIMP_ITEM_UNDO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ITEM_UNDO, GimpItemUndoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ITEM_UNDO</NAME>
#define GIMP_IS_ITEM_UNDO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ITEM_UNDO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ITEM_UNDO_CLASS</NAME>
#define GIMP_IS_ITEM_UNDO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ITEM_UNDO))
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_UNDO_GET_CLASS</NAME>
#define GIMP_ITEM_UNDO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ITEM_UNDO, GimpItemUndoClass))
</MACRO>
<STRUCT>
<NAME>GimpItemUndoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpItemUndo</NAME>
struct _GimpItemUndo
{
  GimpUndo  parent_instance;

  GimpItem *item;  /* the item this undo is for */
};
</STRUCT>
<STRUCT>
<NAME>GimpItemUndoClass</NAME>
struct _GimpItemUndoClass
{
  GimpUndoClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_item_undo_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_attach</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer,GimpDrawable *drawable
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_remove</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_anchor</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_activate_drawable</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_to_layer</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_store</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer,gint          x,gint          y,gint          w,gint          h
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_restore</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer,gint          x,gint          y,gint          w,gint          h
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_rigor</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer,gboolean      push_undo
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_relax</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer,gboolean      push_undo
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_composite</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer,gint          x,gint          y,gint          w,gint          h,gboolean      push_undo
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_boundary</NAME>
<RETURNS>const BoundSeg *</RETURNS>
GimpLayer    *layer,gint         *n_segs
</FUNCTION>
<FUNCTION>
<NAME>floating_sel_invalidate</NAME>
<RETURNS>void             </RETURNS>
GimpLayer    *layer
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LAYER</NAME>
#define GIMP_TYPE_LAYER            (gimp_layer_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_LAYER</NAME>
#define GIMP_LAYER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_LAYER, GimpLayer))
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_CLASS</NAME>
#define GIMP_LAYER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_LAYER, GimpLayerClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LAYER</NAME>
#define GIMP_IS_LAYER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LAYER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LAYER_CLASS</NAME>
#define GIMP_IS_LAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_LAYER))
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_GET_CLASS</NAME>
#define GIMP_LAYER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_LAYER, GimpLayerClass))
</MACRO>
<STRUCT>
<NAME>GimpLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLayer</NAME>
struct _GimpLayer
{
  GimpDrawable          parent_instance;

  gdouble               opacity;          /*  layer opacity              */
  GimpLayerModeEffects  mode;             /*  layer combination mode     */
  gboolean              lock_alpha;       /*  lock the alpha channel     */

  GimpLayerMask        *mask;             /*  possible layer mask        */

  /*  Floating selections  */
  struct
  {
    TileManager  *backing_store;      /*  for obscured regions           */
    GimpDrawable *drawable;           /*  floating sel is attached to    */
    gboolean      initial;            /*  is fs composited yet?          */

    gboolean      boundary_known;     /*  is the current boundary valid  */
    BoundSeg     *segs;               /*  boundary of floating sel       */
    gint          num_segs;           /*  number of segs in boundary     */
  } fs;
};
</STRUCT>
<STRUCT>
<NAME>GimpLayerClass</NAME>
struct _GimpLayerClass
{
  GimpDrawableClass  parent_class;

  void (* opacity_changed)    (GimpLayer *layer);
  void (* mode_changed)       (GimpLayer *layer);
  void (* lock_alpha_changed) (GimpLayer *layer);
  void (* mask_changed)       (GimpLayer *layer);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_layer_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_new</NAME>
<RETURNS>GimpLayer     *</RETURNS>
GimpImage            *image,gint                  width,gint                  height,GimpImageType         type,const gchar          *name,gdouble               opacity,GimpLayerModeEffects  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_new_from_tiles</NAME>
<RETURNS>GimpLayer     *</RETURNS>
TileManager          *tiles,GimpImage            *dest_image,GimpImageType         type,const gchar          *name,gdouble               opacity,GimpLayerModeEffects  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_new_from_pixbuf</NAME>
<RETURNS>GimpLayer     *</RETURNS>
GdkPixbuf            *pixbuf,GimpImage            *dest_image,GimpImageType         type,const gchar          *name,gdouble               opacity,GimpLayerModeEffects  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_new_from_region</NAME>
<RETURNS>GimpLayer     *</RETURNS>
PixelRegion          *region,GimpImage            *dest_image,GimpImageType         type,const gchar          *name,gdouble               opacity,GimpLayerModeEffects  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_create_mask</NAME>
<RETURNS>GimpLayerMask *</RETURNS>
const GimpLayer      *layer,GimpAddMaskType       mask_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_add_mask</NAME>
<RETURNS>GimpLayerMask *</RETURNS>
GimpLayer            *layer,GimpLayerMask        *mask,gboolean              push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_apply_mask</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer,GimpMaskApplyMode     mode,gboolean              push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_add_alpha</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_flatten</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer,GimpContext          *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_resize_to_image</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer,GimpContext          *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_boundary</NAME>
<RETURNS>BoundSeg      *</RETURNS>
GimpLayer            *layer,gint                 *num_segs
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_get_mask</NAME>
<RETURNS>GimpLayerMask *</RETURNS>
const GimpLayer      *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_is_floating_sel</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpLayer      *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_set_opacity</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer,gdouble               opacity,gboolean              push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_get_opacity</NAME>
<RETURNS>gdouble         </RETURNS>
const GimpLayer      *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_set_mode</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer,GimpLayerModeEffects  mode,gboolean              push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_get_mode</NAME>
<RETURNS>GimpLayerModeEffects </RETURNS>
const GimpLayer      *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_set_lock_alpha</NAME>
<RETURNS>void            </RETURNS>
GimpLayer            *layer,gboolean              lock_alpha,gboolean              push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_get_lock_alpha</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpLayer      *layer
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LAYER_MASK</NAME>
#define GIMP_TYPE_LAYER_MASK            (gimp_layer_mask_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_MASK</NAME>
#define GIMP_LAYER_MASK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_LAYER_MASK, GimpLayerMask))
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_MASK_CLASS</NAME>
#define GIMP_LAYER_MASK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_LAYER_MASK, GimpLayerMaskClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LAYER_MASK</NAME>
#define GIMP_IS_LAYER_MASK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LAYER_MASK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LAYER_MASK_CLASS</NAME>
#define GIMP_IS_LAYER_MASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_LAYER_MASK))
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_MASK_GET_CLASS</NAME>
#define GIMP_LAYER_MASK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_LAYER_MASK, GimpLayerMaskClass))
</MACRO>
<STRUCT>
<NAME>GimpLayerMaskClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLayerMask</NAME>
struct _GimpLayerMask
{
  GimpChannel  parent_instance;

  GimpLayer   *layer;

  gboolean     apply_mask;    /*  controls mask application  */
  gboolean     edit_mask;     /*  edit mask or layer?        */
  gboolean     show_mask;     /*  show mask or layer?        */
};
</STRUCT>
<STRUCT>
<NAME>GimpLayerMaskClass</NAME>
struct _GimpLayerMaskClass
{
  GimpChannelClass  parent_class;

  void (* apply_changed) (GimpLayerMask *layer_mask);
  void (* edit_changed)  (GimpLayerMask *layer_mask);
  void (* show_changed)  (GimpLayerMask *layer_mask);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_layer_mask_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_new</NAME>
<RETURNS>GimpLayerMask *</RETURNS>
GimpImage           *image,gint                 width,gint                 height,const gchar         *name,const GimpRGB       *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_set_layer</NAME>
<RETURNS>void            </RETURNS>
GimpLayerMask       *layer_mask,GimpLayer           *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_get_layer</NAME>
<RETURNS>GimpLayer     *</RETURNS>
const GimpLayerMask *layer_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_set_apply</NAME>
<RETURNS>void            </RETURNS>
GimpLayerMask       *layer_mask,gboolean             apply,gboolean             push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_get_apply</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpLayerMask *layer_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_set_edit</NAME>
<RETURNS>void            </RETURNS>
GimpLayerMask       *layer_mask,gboolean             edit
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_get_edit</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpLayerMask *layer_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_set_show</NAME>
<RETURNS>void            </RETURNS>
GimpLayerMask       *layer_mask,gboolean             show,gboolean             push_undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_layer_mask_get_show</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpLayerMask *layer_mask
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LIST</NAME>
#define GIMP_TYPE_LIST            (gimp_list_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_LIST</NAME>
#define GIMP_LIST(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_LIST, GimpList))
</MACRO>
<MACRO>
<NAME>GIMP_LIST_CLASS</NAME>
#define GIMP_LIST_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_LIST, GimpListClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LIST</NAME>
#define GIMP_IS_LIST(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LIST_CLASS</NAME>
#define GIMP_IS_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_LIST_GET_CLASS</NAME>
#define GIMP_LIST_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_LIST, GimpListClass))
</MACRO>
<STRUCT>
<NAME>GimpListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpList</NAME>
struct _GimpList
{
  GimpContainer  parent_instance;

  GList         *list;
  gboolean       unique_names;
  GCompareFunc   sort_func;
};
</STRUCT>
<STRUCT>
<NAME>GimpListClass</NAME>
struct _GimpListClass
{
  GimpContainerClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_list_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_list_new</NAME>
<RETURNS>GimpContainer *</RETURNS>
GType                children_type,gboolean             unique_names
</FUNCTION>
<FUNCTION>
<NAME>gimp_list_new_weak</NAME>
<RETURNS>GimpContainer *</RETURNS>
GType                children_type,gboolean             unique_names
</FUNCTION>
<FUNCTION>
<NAME>gimp_list_reverse</NAME>
<RETURNS>void            </RETURNS>
GimpList            *list
</FUNCTION>
<FUNCTION>
<NAME>gimp_list_set_sort_func</NAME>
<RETURNS>void            </RETURNS>
GimpList            *list,GCompareFunc         sort_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_list_sort</NAME>
<RETURNS>void            </RETURNS>
GimpList            *list,GCompareFunc         sort_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_list_sort_by_name</NAME>
<RETURNS>void            </RETURNS>
GimpList            *list
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_OBJECT</NAME>
#define GIMP_TYPE_OBJECT            (gimp_object_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_OBJECT</NAME>
#define GIMP_OBJECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_OBJECT, GimpObject))
</MACRO>
<MACRO>
<NAME>GIMP_OBJECT_CLASS</NAME>
#define GIMP_OBJECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_OBJECT, GimpObjectClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_OBJECT</NAME>
#define GIMP_IS_OBJECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_OBJECT_CLASS</NAME>
#define GIMP_IS_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>GIMP_OBJECT_GET_CLASS</NAME>
#define GIMP_OBJECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_OBJECT, GimpObjectClass))
</MACRO>
<STRUCT>
<NAME>GimpObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpObject</NAME>
struct _GimpObject
{
  GObject  parent_instance;

  gchar   *name;

  /*<  private  >*/
  gchar   *normalized;
  guint    static_name  : 1;
  guint    disconnected : 1;
};
</STRUCT>
<STRUCT>
<NAME>GimpObjectClass</NAME>
struct _GimpObjectClass
{
  GObjectClass  parent_class;

  /*  signals  */
  void    (* disconnect)   (GimpObject *object);
  void    (* name_changed) (GimpObject *object);

  /*  virtual functions  */
  gint64  (* get_memsize)  (GimpObject *object,
                            gint64     *gui_size);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_object_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_set_name</NAME>
<RETURNS>void          </RETURNS>
GimpObject       *object,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_set_name_safe</NAME>
<RETURNS>void          </RETURNS>
GimpObject       *object,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_set_static_name</NAME>
<RETURNS>void          </RETURNS>
GimpObject       *object,const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_take_name</NAME>
<RETURNS>void          </RETURNS>
GimpObject       *object,gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
const GimpObject *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_name_changed</NAME>
<RETURNS>void          </RETURNS>
GimpObject       *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_name_free</NAME>
<RETURNS>void          </RETURNS>
GimpObject       *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_name_collate</NAME>
<RETURNS>gint          </RETURNS>
GimpObject       *object1,GimpObject       *object2
</FUNCTION>
<FUNCTION>
<NAME>gimp_object_get_memsize</NAME>
<RETURNS>gint64        </RETURNS>
GimpObject       *object,gint64           *gui_size
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PAINT_INFO</NAME>
#define GIMP_TYPE_PAINT_INFO            (gimp_paint_info_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_INFO</NAME>
#define GIMP_PAINT_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINT_INFO, GimpPaintInfo))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_INFO_CLASS</NAME>
#define GIMP_PAINT_INFO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PAINT_INFO, GimpPaintInfoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_INFO</NAME>
#define GIMP_IS_PAINT_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PAINT_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_INFO_CLASS</NAME>
#define GIMP_IS_PAINT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PAINT_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_INFO_GET_CLASS</NAME>
#define GIMP_PAINT_INFO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PAINT_INFO, GimpPaintInfoClass))
</MACRO>
<STRUCT>
<NAME>GimpPaintInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintInfo</NAME>
struct _GimpPaintInfo
{
  GimpViewable      parent_instance;

  Gimp             *gimp;

  GType             paint_type;
  GType             paint_options_type;

  gchar            *blurb;

  GimpPaintOptions *paint_options;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaintInfoClass</NAME>
struct _GimpPaintInfoClass
{
  GimpViewableClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_paint_info_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_info_new</NAME>
<RETURNS>GimpPaintInfo *</RETURNS>
Gimp          *gimp,GType          paint_type,GType          paint_options_type,const gchar   *identifier,const gchar   *blurb,const gchar   *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_info_set_standard</NAME>
<RETURNS>void            </RETURNS>
Gimp          *gimp,GimpPaintInfo *paint_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_info_get_standard</NAME>
<RETURNS>GimpPaintInfo *</RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_import_from_gradient</NAME>
<RETURNS>GimpPalette *</RETURNS>
GimpGradient *gradient,gboolean      reverse,const gchar  *palette_name,gint          n_colors
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_import_from_image</NAME>
<RETURNS>GimpPalette *</RETURNS>
GimpImage    *image,const gchar  *palette_name,gint          n_colors,gint          treshold
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_import_from_indexed_image</NAME>
<RETURNS>GimpPalette *</RETURNS>
GimpImage    *image,const gchar  *palette_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_import_from_drawable</NAME>
<RETURNS>GimpPalette *</RETURNS>
GimpDrawable *drawable,const gchar  *palette_name,gint          n_colors,gint          threshold
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_import_from_file</NAME>
<RETURNS>GimpPalette *</RETURNS>
const gchar  *filename,const gchar  *palette_name,GError      **error
</FUNCTION>
<MACRO>
<NAME>GIMP_PALETTE_FILE_EXTENSION</NAME>
#define GIMP_PALETTE_FILE_EXTENSION ".gpl"
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_PALETTE</NAME>
#define GIMP_TYPE_PALETTE            (gimp_palette_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE</NAME>
#define GIMP_PALETTE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PALETTE, GimpPalette))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_CLASS</NAME>
#define GIMP_PALETTE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PALETTE, GimpPaletteClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE</NAME>
#define GIMP_IS_PALETTE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PALETTE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_CLASS</NAME>
#define GIMP_IS_PALETTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PALETTE))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_GET_CLASS</NAME>
#define GIMP_PALETTE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PALETTE, GimpPaletteClass))
</MACRO>
<STRUCT>
<NAME>GimpPaletteEntry</NAME>
struct _GimpPaletteEntry
{
  GimpRGB  color;
  gchar   *name;

  /* EEK */
  gint     position;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaletteClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPalette</NAME>
struct _GimpPalette
{
  GimpData  parent_instance;

  GList    *colors;
  gint      n_colors;

  gint      n_columns;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaletteClass</NAME>
struct _GimpPaletteClass
{
  GimpDataClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_palette_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_new</NAME>
<RETURNS>GimpData         *</RETURNS>
const gchar      *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_get_standard</NAME>
<RETURNS>GimpData         *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_load</NAME>
<RETURNS>GList            *</RETURNS>
const gchar      *filename,GError          **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_add_entry</NAME>
<RETURNS>GimpPaletteEntry *</RETURNS>
GimpPalette      *palette,gint              position,const gchar      *name,const GimpRGB    *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_delete_entry</NAME>
<RETURNS>void               </RETURNS>
GimpPalette      *palette,GimpPaletteEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_set_columns</NAME>
<RETURNS>void               </RETURNS>
GimpPalette      *palette,gint              columns
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_get_columns</NAME>
<RETURNS>gint               </RETURNS>
GimpPalette      *palette
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARASITE_LIST</NAME>
#define GIMP_TYPE_PARASITE_LIST            (gimp_parasite_list_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARASITE_LIST</NAME>
#define GIMP_PARASITE_LIST(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PARASITE_LIST, GimpParasiteList))
</MACRO>
<MACRO>
<NAME>GIMP_PARASITE_LIST_CLASS</NAME>
#define GIMP_PARASITE_LIST_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PARASITE_LIST, GimpParasiteListClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARASITE_LIST</NAME>
#define GIMP_IS_PARASITE_LIST(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PARASITE_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARASITE_LIST_CLASS</NAME>
#define GIMP_IS_PARASITE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PARASITE_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_PARASITE_LIST_GET_CLASS</NAME>
#define GIMP_PARASITE_LIST_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PARASITE_LIST, GimpParasiteListClass))
</MACRO>
<STRUCT>
<NAME>GimpParasiteListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParasiteList</NAME>
struct _GimpParasiteList
{
  GimpObject  object;

  GHashTable *table;
};
</STRUCT>
<STRUCT>
<NAME>GimpParasiteListClass</NAME>
struct _GimpParasiteListClass
{
  GimpObjectClass parent_class;

  void (* add)    (GimpParasiteList *list,
                   GimpParasite     *parasite);
  void (* remove) (GimpParasiteList *list,
                   GimpParasite     *parasite);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_parasite_list_get_type</NAME>
<RETURNS>GType                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_new</NAME>
<RETURNS>GimpParasiteList   *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_copy</NAME>
<RETURNS>GimpParasiteList   *</RETURNS>
const GimpParasiteList *list
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_add</NAME>
<RETURNS>void                 </RETURNS>
GimpParasiteList       *list,const GimpParasite     *parasite
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_remove</NAME>
<RETURNS>void                 </RETURNS>
GimpParasiteList       *list,const gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_length</NAME>
<RETURNS>gint                 </RETURNS>
GimpParasiteList       *list
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_persistent_length</NAME>
<RETURNS>gint                 </RETURNS>
GimpParasiteList *list
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_foreach</NAME>
<RETURNS>void                 </RETURNS>
GimpParasiteList       *list,GHFunc                  function,gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_parasite_list_find</NAME>
<RETURNS>const GimpParasite *</RETURNS>
GimpParasiteList       *list,const gchar            *name
</FUNCTION>
<MACRO>
<NAME>GPATTERN_FILE_VERSION</NAME>
#define GPATTERN_FILE_VERSION    1
</MACRO>
<MACRO>
<NAME>GPATTERN_MAGIC</NAME>
#define GPATTERN_MAGIC    (('G' << 24) + ('P' << 16) + ('A' << 8) + ('T' << 0))
</MACRO>
<STRUCT>
<NAME>PatternHeader</NAME>
</STRUCT>
<STRUCT>
<NAME>PatternHeader</NAME>
struct _PatternHeader
{
  guint32   header_size;  /*  header_size = sizeof(PatternHeader) + pattern name  */
  guint32   version;      /*  pattern file version #  */
  guint32   width;        /*  width of pattern  */
  guint32   height;       /*  height of pattern  */
  guint32   bytes;        /*  depth of pattern in bytes  */
  guint32   magic_number; /*  GIMP pattern magic number  */
};
</STRUCT>
<MACRO>
<NAME>GIMP_PATTERN_FILE_EXTENSION</NAME>
#define GIMP_PATTERN_FILE_EXTENSION ".pat"
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_PATTERN</NAME>
#define GIMP_TYPE_PATTERN            (gimp_pattern_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN</NAME>
#define GIMP_PATTERN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PATTERN, GimpPattern))
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_CLASS</NAME>
#define GIMP_PATTERN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PATTERN, GimpPatternClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PATTERN</NAME>
#define GIMP_IS_PATTERN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PATTERN))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PATTERN_CLASS</NAME>
#define GIMP_IS_PATTERN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PATTERN))
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_GET_CLASS</NAME>
#define GIMP_PATTERN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PATTERN, GimpPatternClass))
</MACRO>
<STRUCT>
<NAME>GimpPatternClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPattern</NAME>
struct _GimpPattern
{
  GimpData  parent_instance;

  TempBuf  *mask;
};
</STRUCT>
<STRUCT>
<NAME>GimpPatternClass</NAME>
struct _GimpPatternClass
{
  GimpDataClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pattern_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_new</NAME>
<RETURNS>GimpData *</RETURNS>
const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_get_standard</NAME>
<RETURNS>GimpData *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_load</NAME>
<RETURNS>GList    *</RETURNS>
const gchar        *filename,GError            **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_load_pixbuf</NAME>
<RETURNS>GList    *</RETURNS>
const gchar        *filename,GError            **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_get_mask</NAME>
<RETURNS>TempBuf  *</RETURNS>
const GimpPattern  *pattern
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PDB_PROGRESS</NAME>
#define GIMP_TYPE_PDB_PROGRESS            (gimp_pdb_progress_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PDB_PROGRESS</NAME>
#define GIMP_PDB_PROGRESS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PDB_PROGRESS, GimpPdbProgress))
</MACRO>
<MACRO>
<NAME>GIMP_PDB_PROGRESS_CLASS</NAME>
#define GIMP_PDB_PROGRESS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PDB_PROGRESS, GimpPdbProgressClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PDB_PROGRESS</NAME>
#define GIMP_IS_PDB_PROGRESS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PDB_PROGRESS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PDB_PROGRESS_CLASS</NAME>
#define GIMP_IS_PDB_PROGRESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PDB_PROGRESS))
</MACRO>
<MACRO>
<NAME>GIMP_PDB_PROGRESS_GET_CLASS</NAME>
#define GIMP_PDB_PROGRESS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PDB_PROGRESS, GimpPdbProgressClass))
</MACRO>
<STRUCT>
<NAME>GimpPdbProgressClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPdbProgress</NAME>
struct _GimpPdbProgress
{
  GObject      object;

  gboolean     active;
  gdouble      value;

  GimpContext *context;
  gchar       *callback_name;
  gboolean     callback_busy;
};
</STRUCT>
<STRUCT>
<NAME>GimpPdbProgressClass</NAME>
struct _GimpPdbProgressClass
{
  GObjectClass  parent_class;

  GList        *progresses;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pdb_progress_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_progress_get_by_callback</NAME>
<RETURNS>GimpPdbProgress *</RETURNS>
GimpPdbProgressClass *klass,const gchar          *callback_name
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PICKABLE</NAME>
#define GIMP_TYPE_PICKABLE               (gimp_pickable_interface_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IS_PICKABLE</NAME>
#define GIMP_IS_PICKABLE(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PICKABLE))
</MACRO>
<MACRO>
<NAME>GIMP_PICKABLE</NAME>
#define GIMP_PICKABLE(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PICKABLE, GimpPickable))
</MACRO>
<MACRO>
<NAME>GIMP_PICKABLE_GET_INTERFACE</NAME>
#define GIMP_PICKABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GIMP_TYPE_PICKABLE, GimpPickableInterface))
</MACRO>
<STRUCT>
<NAME>GimpPickableInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPickableInterface</NAME>
struct _GimpPickableInterface
{
  GTypeInterface base_iface;

  /*  virtual functions  */
  void            (* flush)          (GimpPickable *pickable);
  GimpImage     * (* get_image)      (GimpPickable *pickable);
  GimpImageType   (* get_image_type) (GimpPickable *pickable);
  gint            (* get_bytes)      (GimpPickable *pickable);
  TileManager   * (* get_tiles)      (GimpPickable *pickable);
  guchar        * (* get_color_at)   (GimpPickable *pickable,
                                      gint          x,
                                      gint          y);
  gint            (* get_opacity_at) (GimpPickable *pickable,
                                      gint          x,
                                      gint          y);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pickable_interface_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_flush</NAME>
<RETURNS>void            </RETURNS>
GimpPickable *pickable
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_get_image</NAME>
<RETURNS>GimpImage     *</RETURNS>
GimpPickable *pickable
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_get_image_type</NAME>
<RETURNS>GimpImageType   </RETURNS>
GimpPickable *pickable
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_get_bytes</NAME>
<RETURNS>gint            </RETURNS>
GimpPickable *pickable
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_get_tiles</NAME>
<RETURNS>TileManager   *</RETURNS>
GimpPickable *pickable
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_get_color_at</NAME>
<RETURNS>guchar        *</RETURNS>
GimpPickable *pickable,gint          x,gint          y
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_get_opacity_at</NAME>
<RETURNS>gint            </RETURNS>
GimpPickable *pickable,gint          x,gint          y
</FUNCTION>
<FUNCTION>
<NAME>gimp_pickable_pick_color</NAME>
<RETURNS>gboolean        </RETURNS>
GimpPickable *pickable,gint          x,gint          y,gboolean      sample_average,gdouble       average_radius,GimpRGB      *color,gint         *color_index
</FUNCTION>
<MACRO>
<NAME>PREVIEW_CACHE_PRIME_WIDTH</NAME>
#define PREVIEW_CACHE_PRIME_WIDTH  112
</MACRO>
<MACRO>
<NAME>PREVIEW_CACHE_PRIME_HEIGHT</NAME>
#define PREVIEW_CACHE_PRIME_HEIGHT 112
</MACRO>
<FUNCTION>
<NAME>gimp_preview_cache_get</NAME>
<RETURNS>TempBuf *</RETURNS>
GSList  **plist,gint      width,gint      height
</FUNCTION>
<FUNCTION>
<NAME>gimp_preview_cache_add</NAME>
<RETURNS>void      </RETURNS>
GSList  **plist,TempBuf  *buf
</FUNCTION>
<FUNCTION>
<NAME>gimp_preview_cache_invalidate</NAME>
<RETURNS>void      </RETURNS>
GSList  **plist
</FUNCTION>
<FUNCTION>
<NAME>gimp_preview_cache_get_memsize</NAME>
<RETURNS>gsize     </RETURNS>
GSList   *cache
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PROGRESS</NAME>
#define GIMP_TYPE_PROGRESS               (gimp_progress_interface_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROGRESS</NAME>
#define GIMP_IS_PROGRESS(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PROGRESS))
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS</NAME>
#define GIMP_PROGRESS(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PROGRESS, GimpProgress))
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_GET_INTERFACE</NAME>
#define GIMP_PROGRESS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GIMP_TYPE_PROGRESS, GimpProgressInterface))
</MACRO>
<STRUCT>
<NAME>GimpProgressInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProgressInterface</NAME>
struct _GimpProgressInterface
{
  GTypeInterface base_iface;

  /*  virtual functions  */
  GimpProgress * (* start)      (GimpProgress *progress,
                                 const gchar  *message,
                                 gboolean      cancelable);
  void           (* end)        (GimpProgress *progress);
  gboolean       (* is_active)  (GimpProgress *progress);

  void           (* set_text)   (GimpProgress *progress,
                                 const gchar  *message);
  void           (* set_value)  (GimpProgress *progress,
                                 gdouble       percentage);
  gdouble        (* get_value)  (GimpProgress *progress);
  void           (* pulse)      (GimpProgress *progress);

  guint32        (* get_window) (GimpProgress *progress);

  void           (* message)    (GimpProgress *progress,
                                 Gimp         *gimp,
                                 const gchar  *domain,
                                 const gchar  *message);

  /*  signals  */
  void           (* cancel)     (GimpProgress *progress);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_progress_interface_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_start</NAME>
<RETURNS>GimpProgress *</RETURNS>
GimpProgress *progress,const gchar  *message,gboolean      cancelable
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_end</NAME>
<RETURNS>void           </RETURNS>
GimpProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_is_active</NAME>
<RETURNS>gboolean       </RETURNS>
GimpProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_set_text</NAME>
<RETURNS>void           </RETURNS>
GimpProgress *progress,const gchar  *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_set_value</NAME>
<RETURNS>void           </RETURNS>
GimpProgress *progress,gdouble       percentage
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_get_value</NAME>
<RETURNS>gdouble        </RETURNS>
GimpProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_pulse</NAME>
<RETURNS>void           </RETURNS>
GimpProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_get_window</NAME>
<RETURNS>guint32        </RETURNS>
GimpProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_message</NAME>
<RETURNS>void           </RETURNS>
GimpProgress *progress,Gimp         *gimp,const gchar  *domain,const gchar  *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_cancel</NAME>
<RETURNS>void           </RETURNS>
GimpProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_update_and_flush</NAME>
<RETURNS>void           </RETURNS>
gint          min,gint          max,gint          current,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_construct</NAME>
<RETURNS>void   </RETURNS>
GimpProjection *proj,gint            x,gint            y,gint            w,gint            h
</FUNCTION>
<STRUCT>
<NAME>GimpProjectionIdleRender</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProjectionIdleRender</NAME>
struct _GimpProjectionIdleRender
{
  gint    width;
  gint    height;
  gint    x;
  gint    y;
  gint    base_x;
  gint    base_y;
  guint   idle_id;
  GSList *update_areas;   /*  flushed update areas */
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_PROJECTION</NAME>
#define GIMP_TYPE_PROJECTION            (gimp_projection_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PROJECTION</NAME>
#define GIMP_PROJECTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PROJECTION, GimpProjection))
</MACRO>
<MACRO>
<NAME>GIMP_PROJECTION_CLASS</NAME>
#define GIMP_PROJECTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PROJECTION, GimpProjectionClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROJECTION</NAME>
#define GIMP_IS_PROJECTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PROJECTION))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROJECTION_CLASS</NAME>
#define GIMP_IS_PROJECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PROJECTION))
</MACRO>
<MACRO>
<NAME>GIMP_PROJECTION_GET_CLASS</NAME>
#define GIMP_PROJECTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PROJECTION, GimpProjectionClass))
</MACRO>
<STRUCT>
<NAME>GimpProjectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProjection</NAME>
struct _GimpProjection
{
  GimpObject                parent_instance;

  GimpImage                *image;

  GimpImageType             type;
  gint                      bytes;
  TileManager              *tiles;

  GSList                   *update_areas;
  GimpProjectionIdleRender  idle_render;

  gboolean                  construct_flag;
};
</STRUCT>
<STRUCT>
<NAME>GimpProjectionClass</NAME>
struct _GimpProjectionClass
{
  GimpObjectClass  parent_class;

  void (* update) (GimpProjection *image,
                   gboolean        now,
                   gint            x,
                   gint            y,
                   gint            width,
                   gint            height);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_projection_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_new</NAME>
<RETURNS>GimpProjection *</RETURNS>
GimpImage            *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_get_tiles</NAME>
<RETURNS>TileManager    *</RETURNS>
GimpProjection       *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_get_image</NAME>
<RETURNS>GimpImage      *</RETURNS>
const GimpProjection *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_get_image_type</NAME>
<RETURNS>GimpImageType         </RETURNS>
const GimpProjection *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_get_bytes</NAME>
<RETURNS>gint             </RETURNS>
const GimpProjection *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_get_opacity</NAME>
<RETURNS>gdouble          </RETURNS>
const GimpProjection *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_flush</NAME>
<RETURNS>void             </RETURNS>
GimpProjection       *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_flush_now</NAME>
<RETURNS>void             </RETURNS>
GimpProjection       *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_projection_finish_draw</NAME>
<RETURNS>void             </RETURNS>
GimpProjection       *proj
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_new</NAME>
<RETURNS>GimpScanConvert *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_free</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_set_pixel_ratio</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,gdouble          ratio_xy
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_set_clip_rectangle</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,gint             x,gint             y,gint             width,gint             height
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_add_points</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,guint            n_points,GimpVector2     *points,gboolean         new_polygon
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_add_polyline</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,guint            n_points,GimpVector2     *points,gboolean         closed
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_stroke</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,gdouble          width,GimpJoinStyle    join,GimpCapStyle     cap,gdouble          miter,gdouble          dash_offset,GArray          *dash_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_render</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,TileManager     *tile_manager,gint             off_x,gint             off_y,gboolean         antialias
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_render_value</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,TileManager     *tile_manager,gint             off_x,gint             off_y,guchar           value
</FUNCTION>
<FUNCTION>
<NAME>gimp_scan_convert_compose</NAME>
<RETURNS>void      </RETURNS>
GimpScanConvert *sc,GimpChannelOps   op,TileManager     *tile_manager,gint             off_x,gint             off_y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SELECTION</NAME>
#define GIMP_TYPE_SELECTION            (gimp_selection_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION</NAME>
#define GIMP_SELECTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SELECTION, GimpSelection))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_CLASS</NAME>
#define GIMP_SELECTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SELECTION, GimpSelectionClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION</NAME>
#define GIMP_IS_SELECTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SELECTION))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_CLASS</NAME>
#define GIMP_IS_SELECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SELECTION))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_GET_CLASS</NAME>
#define GIMP_SELECTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SELECTION, GimpSelectionClass))
</MACRO>
<STRUCT>
<NAME>GimpSelectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSelection</NAME>
struct _GimpSelection
{
  GimpChannel parent_instance;

  gboolean    stroking;
};
</STRUCT>
<STRUCT>
<NAME>GimpSelectionClass</NAME>
struct _GimpSelectionClass
{
  GimpChannelClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_selection_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_new</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpImage    *image,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_load</NAME>
<RETURNS>void          </RETURNS>
GimpChannel  *selection,GimpChannel  *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_save</NAME>
<RETURNS>GimpChannel *</RETURNS>
GimpChannel  *selection
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_extract</NAME>
<RETURNS>TileManager *</RETURNS>
GimpChannel  *selection,GimpDrawable *drawable,GimpContext  *context,gboolean      cut_image,gboolean      keep_indexed,gboolean      add_alpha
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_float</NAME>
<RETURNS>GimpLayer   *</RETURNS>
GimpChannel  *selection,GimpDrawable *drawable,GimpContext  *context,gboolean      cut_image,gint          off_x,gint          off_y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_STROKE_DESC</NAME>
#define GIMP_TYPE_STROKE_DESC            (gimp_stroke_desc_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_DESC</NAME>
#define GIMP_STROKE_DESC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_STROKE_DESC, GimpStrokeDesc))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_DESC_CLASS</NAME>
#define GIMP_STROKE_DESC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_STROKE_DESC, GimpStrokeDescClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_DESC</NAME>
#define GIMP_IS_STROKE_DESC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_STROKE_DESC))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_DESC_CLASS</NAME>
#define GIMP_IS_STROKE_DESC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_STROKE_DESC))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_DESC_GET_CLASS</NAME>
#define GIMP_STROKE_DESC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_STROKE_DESC, GimpStrokeDescClass))
</MACRO>
<STRUCT>
<NAME>GimpStrokeDescClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStrokeDesc</NAME>
struct _GimpStrokeDesc
{
  GimpObject         parent_instance;

  Gimp              *gimp;

  GimpStrokeMethod   method;

  GimpStrokeOptions *stroke_options;
  GimpPaintInfo     *paint_info;

  GimpPaintOptions  *paint_options;
};
</STRUCT>
<STRUCT>
<NAME>GimpStrokeDescClass</NAME>
struct _GimpStrokeDescClass
{
  GimpObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_stroke_desc_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_desc_new</NAME>
<RETURNS>GimpStrokeDesc *</RETURNS>
Gimp           *gimp,GimpContext    *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_desc_duplicate</NAME>
<RETURNS>GimpStrokeDesc *</RETURNS>
GimpStrokeDesc *desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_desc_prepare</NAME>
<RETURNS>void             </RETURNS>
GimpStrokeDesc *desc,GimpContext    *context,gboolean        use_default_values
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_desc_finish</NAME>
<RETURNS>void             </RETURNS>
GimpStrokeDesc *desc
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_STROKE_OPTIONS</NAME>
#define GIMP_TYPE_STROKE_OPTIONS            (gimp_stroke_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_OPTIONS</NAME>
#define GIMP_STROKE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_STROKE_OPTIONS, GimpStrokeOptions))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_OPTIONS_CLASS</NAME>
#define GIMP_STROKE_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_STROKE_OPTIONS, GimpStrokeOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_OPTIONS</NAME>
#define GIMP_IS_STROKE_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_STROKE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_OPTIONS_CLASS</NAME>
#define GIMP_IS_STROKE_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_STROKE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_OPTIONS_GET_CLASS</NAME>
#define GIMP_STROKE_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_STROKE_OPTIONS, GimpStrokeOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpStrokeOptionsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStrokeOptions</NAME>
struct _GimpStrokeOptions
{
  GimpContext      parent_instance;

  GimpStrokeStyle  style;

  gdouble          width;
  GimpUnit         unit;

  GimpCapStyle     cap_style;
  GimpJoinStyle    join_style;

  gdouble          miter_limit;

  gboolean         antialias;

  gdouble          dash_offset;
  GArray          *dash_info;
};
</STRUCT>
<STRUCT>
<NAME>GimpStrokeOptionsClass</NAME>
struct _GimpStrokeOptionsClass
{
  GimpContextClass parent_class;

  void (* dash_info_changed) (GimpStrokeOptions *stroke_options,
                              GimpDashPreset     preset);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_stroke_options_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_options_set_dash_pattern</NAME>
<RETURNS>void   </RETURNS>
GimpStrokeOptions *options,GimpDashPreset     preset,GArray            *pattern
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEMPLATE</NAME>
#define GIMP_TYPE_TEMPLATE            (gimp_template_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE</NAME>
#define GIMP_TEMPLATE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEMPLATE, GimpTemplate))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_CLASS</NAME>
#define GIMP_TEMPLATE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEMPLATE, GimpTemplateClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPLATE</NAME>
#define GIMP_IS_TEMPLATE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEMPLATE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPLATE_CLASS</NAME>
#define GIMP_IS_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEMPLATE))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_GET_CLASS</NAME>
#define GIMP_TEMPLATE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEMPLATE, GimpTemplateClass))
</MACRO>
<STRUCT>
<NAME>GimpTemplateClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemplate</NAME>
struct _GimpTemplate
{
  GimpViewable       parent_instance;

  gint               width;
  gint               height;
  GimpUnit           unit;

  gdouble            xresolution;
  gdouble            yresolution;
  GimpUnit           resolution_unit;

  GimpImageBaseType  image_type;
  GimpFillType       fill_type;

  gchar             *comment;
  gchar             *filename;

  guint64            initial_size;
};
</STRUCT>
<STRUCT>
<NAME>GimpTemplateClass</NAME>
struct _GimpTemplateClass
{
  GimpViewableClass  parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_template_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_template_new</NAME>
<RETURNS>GimpTemplate *</RETURNS>
const gchar    *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_template_set_from_image</NAME>
<RETURNS>void           </RETURNS>
GimpTemplate   *template,GimpImage      *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_template_create_image</NAME>
<RETURNS>GimpImage    *</RETURNS>
Gimp           *gimp,GimpTemplate   *template,GimpContext    *context
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL_INFO</NAME>
#define GIMP_TYPE_TOOL_INFO            (gimp_tool_info_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_INFO</NAME>
#define GIMP_TOOL_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_INFO, GimpToolInfo))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_INFO_CLASS</NAME>
#define GIMP_TOOL_INFO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_INFO, GimpToolInfoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_INFO</NAME>
#define GIMP_IS_TOOL_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_INFO_CLASS</NAME>
#define GIMP_IS_TOOL_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_INFO_GET_CLASS</NAME>
#define GIMP_TOOL_INFO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_INFO, GimpToolInfoClass))
</MACRO>
<STRUCT>
<NAME>GimpToolInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolInfo</NAME>
struct _GimpToolInfo
{
  GimpViewable         parent_instance;

  Gimp                *gimp;

  GType                tool_type;
  GType                tool_options_type;
  GimpContextPropMask  context_props;

  gchar               *blurb;
  gchar               *help;

  gchar               *menu_path;
  gchar               *menu_accel;

  gchar               *help_domain;
  gchar               *help_id;

  gboolean             visible;
  GimpToolOptions     *tool_options;
  GimpPaintInfo       *paint_info;

  GimpContainer       *options_presets;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolInfoClass</NAME>
struct _GimpToolInfoClass
{
  GimpViewableClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_info_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_info_new</NAME>
<RETURNS>GimpToolInfo *</RETURNS>
Gimp                *gimp,GType                tool_type,GType                tool_options_type,GimpContextPropMask  context_props,const gchar         *identifier,const gchar         *blurb,const gchar         *help,const gchar         *menu_path,const gchar         *menu_accel,const gchar         *help_domain,const gchar         *help_id,const gchar         *paint_core_name,const gchar         *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_info_set_standard</NAME>
<RETURNS>void           </RETURNS>
Gimp                *gimp,GimpToolInfo        *tool_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_info_get_standard</NAME>
<RETURNS>GimpToolInfo *</RETURNS>
Gimp                *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL_OPTIONS</NAME>
#define GIMP_TYPE_TOOL_OPTIONS            (gimp_tool_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_OPTIONS</NAME>
#define GIMP_TOOL_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_OPTIONS, GimpToolOptions))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_OPTIONS_CLASS</NAME>
#define GIMP_TOOL_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_OPTIONS, GimpToolOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_OPTIONS</NAME>
#define GIMP_IS_TOOL_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_OPTIONS_CLASS</NAME>
#define GIMP_IS_TOOL_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_OPTIONS_GET_CLASS</NAME>
#define GIMP_TOOL_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_OPTIONS, GimpToolOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpToolOptionsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolOptions</NAME>
struct _GimpToolOptions
{
  GimpContext   parent_instance;

  GimpToolInfo *tool_info;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolOptionsClass</NAME>
struct _GimpToolOptionsClass
{
  GimpContextClass parent_class;

  void (* reset) (GimpToolOptions *tool_options);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_options_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_options_reset</NAME>
<RETURNS>void       </RETURNS>
GimpToolOptions  *tool_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_options_build_filename</NAME>
<RETURNS>gchar    *</RETURNS>
GimpToolOptions  *tool_options,const gchar      *extension
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_options_serialize</NAME>
<RETURNS>gboolean   </RETURNS>
GimpToolOptions   *tool_options,const gchar       *extension,GError           **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_options_deserialize</NAME>
<RETURNS>gboolean   </RETURNS>
GimpToolOptions   *tool_options,const gchar       *extension,GError           **error
</FUNCTION>
<STRUCT>
<NAME>GimpUndoAccumulator</NAME>
struct _GimpUndoAccumulator
{
  gboolean mode_changed;
  gboolean size_changed;
  gboolean resolution_changed;
  gboolean unit_changed;
  gboolean quick_mask_changed;
  gboolean alpha_changed;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_UNDO</NAME>
#define GIMP_TYPE_UNDO            (gimp_undo_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_UNDO</NAME>
#define GIMP_UNDO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_UNDO, GimpUndo))
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_CLASS</NAME>
#define GIMP_UNDO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_UNDO, GimpUndoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNDO</NAME>
#define GIMP_IS_UNDO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_UNDO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNDO_CLASS</NAME>
#define GIMP_IS_UNDO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_UNDO))
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_GET_CLASS</NAME>
#define GIMP_UNDO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_UNDO, GimpUndoClass))
</MACRO>
<STRUCT>
<NAME>GimpUndoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndo</NAME>
struct _GimpUndo
{
  GimpViewable      parent_instance;

  GimpImage        *image;          /* the image this undo is part of     */
  guint             time;           /* time of undo step construction     */

  GimpUndoType      undo_type;      /* undo type                          */
  gpointer          data;           /* data to implement the undo         */
  gint64            size;           /* size of undo item                  */
  GimpDirtyMask     dirty_mask;     /* affected parts of the image        */

  GimpUndoPopFunc   pop_func;       /* function pointer to undo pop proc  */
  GimpUndoFreeFunc  free_func;      /* function pointer to free undo data */

  TempBuf          *preview;
  guint             preview_idle_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpUndoClass</NAME>
struct _GimpUndoClass
{
  GimpViewableClass  parent_class;

  void (* pop)  (GimpUndo            *undo,
                 GimpUndoMode         undo_mode,
                 GimpUndoAccumulator *accum);
  void (* free) (GimpUndo            *undo,
                 GimpUndoMode         undo_mode);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_undo_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_pop</NAME>
<RETURNS>void          </RETURNS>
GimpUndo            *undo,GimpUndoMode         undo_mode,GimpUndoAccumulator *accum
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_free</NAME>
<RETURNS>void          </RETURNS>
GimpUndo            *undo,GimpUndoMode         undo_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_create_preview</NAME>
<RETURNS>void          </RETURNS>
GimpUndo            *undo,gboolean             create_now
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_refresh_preview</NAME>
<RETURNS>void          </RETURNS>
GimpUndo            *undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_type_to_name</NAME>
<RETURNS>const gchar *</RETURNS>
GimpUndoType         type
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_UNDO_STACK</NAME>
#define GIMP_TYPE_UNDO_STACK            (gimp_undo_stack_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_STACK</NAME>
#define GIMP_UNDO_STACK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_UNDO_STACK, GimpUndoStack))
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_STACK_CLASS</NAME>
#define GIMP_UNDO_STACK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_UNDO_STACK, GimpUndoStackClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNDO_STACK</NAME>
#define GIMP_IS_UNDO_STACK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_UNDO_STACK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNDO_STACK_CLASS</NAME>
#define GIMP_IS_UNDO_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_UNDO_STACK))
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_STACK_GET_CLASS</NAME>
#define GIMP_UNDO_STACK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_UNDO_STACK, GimpUndoStackClass))
</MACRO>
<STRUCT>
<NAME>GimpUndoStackClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndoStack</NAME>
struct _GimpUndoStack
{
  GimpUndo       parent_instance;

  GimpContainer *undos;
};
</STRUCT>
<STRUCT>
<NAME>GimpUndoStackClass</NAME>
struct _GimpUndoStackClass
{
  GimpUndoClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_undo_stack_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_stack_new</NAME>
<RETURNS>GimpUndoStack *</RETURNS>
GimpImage           *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_stack_push_undo</NAME>
<RETURNS>void            </RETURNS>
GimpUndoStack       *stack,GimpUndo            *undo
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_stack_pop_undo</NAME>
<RETURNS>GimpUndo      *</RETURNS>
GimpUndoStack       *stack,GimpUndoMode         undo_mode,GimpUndoAccumulator *accum
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_stack_free_bottom</NAME>
<RETURNS>GimpUndo      *</RETURNS>
GimpUndoStack       *stack,GimpUndoMode         undo_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_stack_peek</NAME>
<RETURNS>GimpUndo      *</RETURNS>
GimpUndoStack       *stack
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_stack_get_depth</NAME>
<RETURNS>gint            </RETURNS>
GimpUndoStack       *stack
</FUNCTION>
<FUNCTION>
<NAME>gimp_user_units_free</NAME>
<RETURNS>void           </RETURNS>
Gimp        *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_VIEWABLE_MAX_PREVIEW_SIZE</NAME>
#define GIMP_VIEWABLE_MAX_PREVIEW_SIZE 1024
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_MAX_POPUP_SIZE</NAME>
#define GIMP_VIEWABLE_MAX_POPUP_SIZE    256
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_MAX_BUTTON_SIZE</NAME>
#define GIMP_VIEWABLE_MAX_BUTTON_SIZE    64
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_MAX_MENU_SIZE</NAME>
#define GIMP_VIEWABLE_MAX_MENU_SIZE      48
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_VIEWABLE</NAME>
#define GIMP_TYPE_VIEWABLE            (gimp_viewable_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE</NAME>
#define GIMP_VIEWABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEWABLE, GimpViewable))
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_CLASS</NAME>
#define GIMP_VIEWABLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEWABLE, GimpViewableClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEWABLE</NAME>
#define GIMP_IS_VIEWABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VIEWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEWABLE_CLASS</NAME>
#define GIMP_IS_VIEWABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_GET_CLASS</NAME>
#define GIMP_VIEWABLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEWABLE, GimpViewableClass))
</MACRO>
<STRUCT>
<NAME>GimpViewableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewable</NAME>
struct _GimpViewable
{
  GimpObject  parent_instance;

  /*<  private  >*/
  gchar      *stock_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewableClass</NAME>
struct _GimpViewableClass
{
  GimpObjectClass  parent_class;

  const gchar     *default_stock_id;
  const gchar     *name_changed_signal;

  /*  signals  */
  void        (* invalidate_preview) (GimpViewable  *viewable);
  void        (* size_changed)       (GimpViewable  *viewable);

  /*  virtual functions  */
  gboolean    (* get_size)           (GimpViewable  *viewable,
                                      gint          *width,
                                      gint          *height);
  void        (* get_preview_size)   (GimpViewable  *viewable,
                                      gint           size,
                                      gboolean       is_popup,
                                      gboolean       dot_for_dot,
                                      gint          *width,
                                      gint          *height);
  gboolean    (* get_popup_size)     (GimpViewable  *viewable,
                                      gint           width,
                                      gint           height,
                                      gboolean       dot_for_dot,
                                      gint          *popup_width,
                                      gint          *popup_height);
  TempBuf   * (* get_preview)        (GimpViewable  *viewable,
                                      gint           width,
                                      gint           height);
  TempBuf   * (* get_new_preview)    (GimpViewable  *viewable,
                                      gint           width,
                                      gint           height);
  GdkPixbuf * (* get_pixbuf)         (GimpViewable  *viewable,
                                      gint           width,
                                      gint           height);
  GdkPixbuf * (* get_new_pixbuf)     (GimpViewable  *viewable,
                                      gint           width,
                                      gint           height);
  gchar     * (* get_description)    (GimpViewable  *viewable,
                                      gchar        **tooltip);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_viewable_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_invalidate_preview</NAME>
<RETURNS>void        </RETURNS>
GimpViewable  *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_size_changed</NAME>
<RETURNS>void        </RETURNS>
GimpViewable  *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_calc_preview_size</NAME>
<RETURNS>void        </RETURNS>
gint           aspect_width,gint           aspect_height,gint           width,gint           height,gboolean       dot_for_dot,gdouble        xresolution,gdouble        yresolution,gint          *return_width,gint          *return_height,gboolean      *scaling_up
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_size</NAME>
<RETURNS>gboolean    </RETURNS>
GimpViewable  *viewable,gint          *width,gint          *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_preview_size</NAME>
<RETURNS>void        </RETURNS>
GimpViewable  *viewable,gint           size,gboolean       popup,gboolean       dot_for_dot,gint          *width,gint          *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_popup_size</NAME>
<RETURNS>gboolean    </RETURNS>
GimpViewable  *viewable,gint           width,gint           height,gboolean       dot_for_dot,gint          *popup_width,gint          *popup_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_preview</NAME>
<RETURNS>TempBuf   *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_new_preview</NAME>
<RETURNS>TempBuf   *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_dummy_preview</NAME>
<RETURNS>TempBuf   *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height,gint           bpp
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_pixbuf</NAME>
<RETURNS>GdkPixbuf *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_new_pixbuf</NAME>
<RETURNS>GdkPixbuf *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_dummy_pixbuf</NAME>
<RETURNS>GdkPixbuf *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height,gint           bpp
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_description</NAME>
<RETURNS>gchar     *</RETURNS>
GimpViewable  *viewable,gchar        **tooltip
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_get_stock_id</NAME>
<RETURNS>const gchar *</RETURNS>
GimpViewable  *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_set_stock_id</NAME>
<RETURNS>void          </RETURNS>
GimpViewable  *viewable,const gchar   *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_BOOLEAN__BOOLEAN</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_BOOLEAN__ENUM_INT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_BOOLEAN__OBJECT_POINTER</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_BOOLEAN__OBJECT_POINTER_STRING</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__BOOLEAN_INT_INT_INT_INT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__BOXED</NAME>
#define gimp_marshal_VOID__BOXED	g_cclosure_marshal_VOID__BOXED
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__BOXED_ENUM</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__DOUBLE</NAME>
#define gimp_marshal_VOID__DOUBLE	g_cclosure_marshal_VOID__DOUBLE
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__DOUBLE_DOUBLE</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__ENUM</NAME>
#define gimp_marshal_VOID__ENUM	g_cclosure_marshal_VOID__ENUM
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__ENUM_ENUM_BOXED_INT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__ENUM_OBJECT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__ENUM_POINTER</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__FLAGS</NAME>
#define gimp_marshal_VOID__FLAGS	g_cclosure_marshal_VOID__FLAGS
</MACRO>
<MACRO>
<NAME>gimp_marshal_VOID__INT</NAME>
#define gimp_marshal_VOID__INT	g_cclosure_marshal_VOID__INT
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__INT_INT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__INT_INT_INT_INT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__OBJECT</NAME>
#define gimp_marshal_VOID__OBJECT	g_cclosure_marshal_VOID__OBJECT
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__OBJECT_INT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__OBJECT_OBJECT</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__OBJECT_POINTER</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__POINTER</NAME>
#define gimp_marshal_VOID__POINTER	g_cclosure_marshal_VOID__POINTER
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__POINTER_BOXED</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__POINTER_ENUM</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__STRING</NAME>
#define gimp_marshal_VOID__STRING	g_cclosure_marshal_VOID__STRING
</MACRO>
<FUNCTION>
<NAME>gimp_marshal_VOID__STRING_BOOLEAN_UINT_FLAGS</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_marshal_VOID__STRING_FLAGS</NAME>
<RETURNS>void </RETURNS>
GClosure     *closure,GValue       *return_value,guint         n_param_values,const GValue *param_values,gpointer      invocation_hint,gpointer      marshal_data
</FUNCTION>
<MACRO>
<NAME>gimp_marshal_VOID__VOID</NAME>
#define gimp_marshal_VOID__VOID	g_cclosure_marshal_VOID__VOID
</MACRO>
<FUNCTION>
<NAME>gimp_transform_resize_boundary</NAME>
<RETURNS>void   </RETURNS>
const GimpMatrix3   *inv,GimpTransformResize  resize,gint                 u1,gint                 v1,gint                 u2,gint                 v2,gint                *x1,gint                *y1,gint                *x2,gint                *y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_from_preset</NAME>
<RETURNS>GArray *</RETURNS>
GimpDashPreset  preset
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_from_segments</NAME>
<RETURNS>GArray *</RETURNS>
const gboolean *segments,gint            n_segments,gdouble         dash_length
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_segments_set</NAME>
<RETURNS>void     </RETURNS>
GArray         *pattern,gboolean       *segments,gint            n_segments
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_from_value</NAME>
<RETURNS>GArray *</RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_value_set</NAME>
<RETURNS>void     </RETURNS>
GArray         *pattern,GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_copy</NAME>
<RETURNS>GArray *</RETURNS>
GArray         *pattern
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_pattern_free</NAME>
<RETURNS>void     </RETURNS>
GArray         *pattern
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_align</NAME>
<RETURNS>void </RETURNS>
GimpItem          *target,GimpAlignmentType  target_alignment,GimpItem          *refeence,GimpAlignmentType  reference_alignment,gint               offset
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_foreground_extract</NAME>
<RETURNS>void       </RETURNS>
GimpDrawable              *drawable,GimpForegroundExtractMode  mode,GimpDrawable              *mask,GimpProgress              *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_foreground_extract_siox_init</NAME>
<RETURNS>SioxState *</RETURNS>
GimpDrawable *drawable,gint          x,gint          y,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_foreground_extract_siox</NAME>
<RETURNS>void        </RETURNS>
GimpDrawable       *mask,SioxState          *state,SioxRefinementType  refinemane,gint                smoothness,const gdouble       sensitivity[3],gboolean            multiblob,GimpProgress       *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_foreground_extract_siox_done</NAME>
<RETURNS>void        </RETURNS>
SioxState      *state
</FUNCTION>
<FUNCTION>
<NAME>gimp_contexts_init</NAME>
<RETURNS>void       </RETURNS>
Gimp    *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_contexts_exit</NAME>
<RETURNS>void       </RETURNS>
Gimp    *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_contexts_load</NAME>
<RETURNS>void       </RETURNS>
Gimp    *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_contexts_save</NAME>
<RETURNS>void       </RETURNS>
Gimp    *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_contexts_clear</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp    *gimp,GError **error
</FUNCTION>
<MACRO>
<NAME>GIMP_IMAGE_QUICK_MASK_NAME</NAME>
#define GIMP_IMAGE_QUICK_MASK_NAME "Qmask"
</MACRO>
<FUNCTION>
<NAME>gimp_image_set_quick_mask_state</NAME>
<RETURNS>void          </RETURNS>
GimpImage       *image,gboolean         quick_mask_state
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_quick_mask_state</NAME>
<RETURNS>gboolean      </RETURNS>
const GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_set_quick_mask_color</NAME>
<RETURNS>void          </RETURNS>
GimpImage       *image,const GimpRGB   *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_quick_mask_color</NAME>
<RETURNS>void          </RETURNS>
const GimpImage *image,GimpRGB         *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_get_quick_mask</NAME>
<RETURNS>GimpChannel *</RETURNS>
const GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_quick_mask_invert</NAME>
<RETURNS>void          </RETURNS>
GimpImage       *image
</FUNCTION>
<MACRO>
<NAME>GIMP_PARAM_NO_VALIDATE</NAME>
#define GIMP_PARAM_NO_VALIDATE (1 << (6 + G_PARAM_USER_SHIFT))
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_INT32</NAME>
#define GIMP_TYPE_INT32               (gimp_int32_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_INT32</NAME>
#define GIMP_VALUE_HOLDS_INT32(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                       GIMP_TYPE_INT32))
</MACRO>
<FUNCTION>
<NAME>gimp_int32_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_INT32</NAME>
#define GIMP_TYPE_PARAM_INT32           (gimp_param_int32_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_INT32</NAME>
#define GIMP_PARAM_SPEC_INT32(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_INT32, GimpParamSpecInt32))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_INT32</NAME>
#define GIMP_IS_PARAM_SPEC_INT32(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_INT32))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecInt32</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecInt32</NAME>
struct _GimpParamSpecInt32
{
  GParamSpecInt parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_int32_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_int32</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar *name,const gchar *nick,const gchar *blurb,gint         minimum,gint         maximum,gint         default_value,GParamFlags  flags
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INT16</NAME>
#define GIMP_TYPE_INT16               (gimp_int16_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_INT16</NAME>
#define GIMP_VALUE_HOLDS_INT16(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                       GIMP_TYPE_INT16))
</MACRO>
<FUNCTION>
<NAME>gimp_int16_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_INT16</NAME>
#define GIMP_TYPE_PARAM_INT16           (gimp_param_int16_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_INT16</NAME>
#define GIMP_PARAM_SPEC_INT16(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_INT16, GimpParamSpecInt16))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_INT16</NAME>
#define GIMP_IS_PARAM_SPEC_INT16(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_INT16))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecInt16</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecInt16</NAME>
struct _GimpParamSpecInt16
{
  GParamSpecInt parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_int16_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_int16</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar *name,const gchar *nick,const gchar *blurb,gint         minimum,gint         maximum,gint         default_value,GParamFlags  flags
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INT8</NAME>
#define GIMP_TYPE_INT8               (gimp_int8_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_INT8</NAME>
#define GIMP_VALUE_HOLDS_INT8(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                      GIMP_TYPE_INT8))
</MACRO>
<FUNCTION>
<NAME>gimp_int8_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_INT8</NAME>
#define GIMP_TYPE_PARAM_INT8           (gimp_param_int8_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_INT8</NAME>
#define GIMP_PARAM_SPEC_INT8(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_INT8, GimpParamSpecInt8))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_INT8</NAME>
#define GIMP_IS_PARAM_SPEC_INT8(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_INT8))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecInt8</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecInt8</NAME>
struct _GimpParamSpecInt8
{
  GParamSpecUInt parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_int8_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_int8</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar *name,const gchar *nick,const gchar *blurb,guint        minimum,guint        maximum,guint        default_value,GParamFlags  flags
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_STRING</NAME>
#define GIMP_TYPE_PARAM_STRING           (gimp_param_string_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_STRING</NAME>
#define GIMP_PARAM_SPEC_STRING(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_STRING, GimpParamSpecString))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_STRING</NAME>
#define GIMP_IS_PARAM_SPEC_STRING(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_STRING))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecString</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecString</NAME>
struct _GimpParamSpecString
{
  GParamSpecString parent_instance;

  guint            no_validate : 1;
  guint            null_ok     : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_string_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_string</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar *name,const gchar *nick,const gchar *blurb,gboolean     no_validate,gboolean     null_ok,const gchar *default_value,GParamFlags  flags
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_ENUM</NAME>
#define GIMP_TYPE_PARAM_ENUM           (gimp_param_enum_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_ENUM</NAME>
#define GIMP_PARAM_SPEC_ENUM(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_ENUM, GimpParamSpecEnum))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_ENUM</NAME>
#define GIMP_IS_PARAM_SPEC_ENUM(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_ENUM))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecEnum</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecEnum</NAME>
struct _GimpParamSpecEnum
{
  GParamSpecEnum  parent_instance;

  GSList         *excluded_values;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_enum_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_enum</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar       *name,const gchar       *nick,const gchar       *blurb,GType              enum_type,gint               default_value,GParamFlags        flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_enum_exclude_value</NAME>
<RETURNS>void   </RETURNS>
GimpParamSpecEnum *espec,gint               value
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_ID</NAME>
#define GIMP_TYPE_IMAGE_ID               (gimp_image_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_IMAGE_ID</NAME>
#define GIMP_VALUE_HOLDS_IMAGE_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                          GIMP_TYPE_IMAGE_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_image_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_IMAGE_ID</NAME>
#define GIMP_TYPE_PARAM_IMAGE_ID           (gimp_param_image_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_IMAGE_ID</NAME>
#define GIMP_PARAM_SPEC_IMAGE_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_IMAGE_ID, GimpParamSpecImageID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_IMAGE_ID</NAME>
#define GIMP_IS_PARAM_SPEC_IMAGE_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_IMAGE_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecImageID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecImageID</NAME>
struct _GimpParamSpecImageID
{
  GParamSpecInt  parent_instance;

  Gimp          *gimp;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_image_id_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_image_id</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_image</NAME>
<RETURNS>GimpImage  *</RETURNS>
const GValue *value,Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_image</NAME>
<RETURNS>void         </RETURNS>
GValue       *value,GimpImage    *image
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ITEM_ID</NAME>
#define GIMP_TYPE_ITEM_ID               (gimp_item_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_ITEM_ID</NAME>
#define GIMP_VALUE_HOLDS_ITEM_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                         GIMP_TYPE_ITEM_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_item_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_ITEM_ID</NAME>
#define GIMP_TYPE_PARAM_ITEM_ID           (gimp_param_item_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_ITEM_ID</NAME>
#define GIMP_PARAM_SPEC_ITEM_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_ITEM_ID, GimpParamSpecItemID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_ITEM_ID</NAME>
#define GIMP_IS_PARAM_SPEC_ITEM_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_ITEM_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecItemID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecItemID</NAME>
struct _GimpParamSpecItemID
{
  GParamSpecInt  parent_instance;

  Gimp          *gimp;
  GType          item_type;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_item_id_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_item_id</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GType         item_type,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_item</NAME>
<RETURNS>GimpItem   *</RETURNS>
const GValue *value,Gimp         *gimp,GType         item_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_item</NAME>
<RETURNS>void         </RETURNS>
GValue       *value,GimpItem     *item
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DRAWABLE_ID</NAME>
#define GIMP_TYPE_DRAWABLE_ID               (gimp_drawable_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_DRAWABLE_ID</NAME>
#define GIMP_VALUE_HOLDS_DRAWABLE_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                             GIMP_TYPE_DRAWABLE_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_drawable_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_DRAWABLE_ID</NAME>
#define GIMP_TYPE_PARAM_DRAWABLE_ID           (gimp_param_drawable_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_DRAWABLE_ID</NAME>
#define GIMP_PARAM_SPEC_DRAWABLE_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_DRAWABLE_ID, GimpParamSpecDrawableID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_DRAWABLE_ID</NAME>
#define GIMP_IS_PARAM_SPEC_DRAWABLE_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_DRAWABLE_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecDrawableID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecDrawableID</NAME>
struct _GimpParamSpecDrawableID
{
  GimpParamSpecItemID parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_drawable_id_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_drawable_id</NAME>
<RETURNS>GParamSpec  *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_drawable</NAME>
<RETURNS>GimpDrawable *</RETURNS>
const GValue *value,Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_drawable</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,GimpDrawable *drawable
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LAYER_ID</NAME>
#define GIMP_TYPE_LAYER_ID               (gimp_layer_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_LAYER_ID</NAME>
#define GIMP_VALUE_HOLDS_LAYER_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                          GIMP_TYPE_LAYER_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_layer_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_LAYER_ID</NAME>
#define GIMP_TYPE_PARAM_LAYER_ID           (gimp_param_layer_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_LAYER_ID</NAME>
#define GIMP_PARAM_SPEC_LAYER_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_LAYER_ID, GimpParamSpecLayerID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_LAYER_ID</NAME>
#define GIMP_IS_PARAM_SPEC_LAYER_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_LAYER_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecLayerID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecLayerID</NAME>
struct _GimpParamSpecLayerID
{
  GimpParamSpecDrawableID parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_layer_id_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_layer_id</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_layer</NAME>
<RETURNS>GimpLayer  *</RETURNS>
const GValue *value,Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_layer</NAME>
<RETURNS>void         </RETURNS>
GValue       *value,GimpLayer    *layer
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CHANNEL_ID</NAME>
#define GIMP_TYPE_CHANNEL_ID               (gimp_channel_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_CHANNEL_ID</NAME>
#define GIMP_VALUE_HOLDS_CHANNEL_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                            GIMP_TYPE_CHANNEL_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_channel_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_CHANNEL_ID</NAME>
#define GIMP_TYPE_PARAM_CHANNEL_ID           (gimp_param_channel_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_CHANNEL_ID</NAME>
#define GIMP_PARAM_SPEC_CHANNEL_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_CHANNEL_ID, GimpParamSpecChannelID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_CHANNEL_ID</NAME>
#define GIMP_IS_PARAM_SPEC_CHANNEL_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_CHANNEL_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecChannelID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecChannelID</NAME>
struct _GimpParamSpecChannelID
{
  GimpParamSpecDrawableID parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_channel_id_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_channel_id</NAME>
<RETURNS>GParamSpec  *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_channel</NAME>
<RETURNS>GimpChannel *</RETURNS>
const GValue *value,Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_channel</NAME>
<RETURNS>void          </RETURNS>
GValue       *value,GimpChannel  *channel
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LAYER_MASK_ID</NAME>
#define GIMP_TYPE_LAYER_MASK_ID               (gimp_layer_mask_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_LAYER_MASK_ID</NAME>
#define GIMP_VALUE_HOLDS_LAYER_MASK_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                               GIMP_TYPE_LAYER_MASK_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_layer_mask_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_LAYER_MASK_ID</NAME>
#define GIMP_TYPE_PARAM_LAYER_MASK_ID           (gimp_param_layer_mask_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_LAYER_MASK_ID</NAME>
#define GIMP_PARAM_SPEC_LAYER_MASK_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_LAYER_MASK_ID, GimpParamSpecLayerMaskID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_LAYER_MASK_ID</NAME>
#define GIMP_IS_PARAM_SPEC_LAYER_MASK_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_LAYER_MASK_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecLayerMaskID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecLayerMaskID</NAME>
struct _GimpParamSpecLayerMaskID
{
  GimpParamSpecChannelID parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_layer_mask_id_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_layer_mask_id</NAME>
<RETURNS>GParamSpec    *</RETURNS>
const gchar   *name,const gchar   *nick,const gchar   *blurb,Gimp          *gimp,GParamFlags    flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_layer_mask</NAME>
<RETURNS>GimpLayerMask *</RETURNS>
const GValue  *value,Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_layer_mask</NAME>
<RETURNS>void            </RETURNS>
GValue        *value,GimpLayerMask *layer_mask
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SELECTION_ID</NAME>
#define GIMP_TYPE_SELECTION_ID               (gimp_selection_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_SELECTION_ID</NAME>
#define GIMP_VALUE_HOLDS_SELECTION_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                              GIMP_TYPE_SELECTION_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_selection_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_SELECTION_ID</NAME>
#define GIMP_TYPE_PARAM_SELECTION_ID           (gimp_param_selection_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_SELECTION_ID</NAME>
#define GIMP_PARAM_SPEC_SELECTION_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_SELECTION_ID, GimpParamSpecSelectionID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_SELECTION_ID</NAME>
#define GIMP_IS_PARAM_SPEC_SELECTION_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_SELECTION_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecSelectionID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecSelectionID</NAME>
struct _GimpParamSpecSelectionID
{
  GimpParamSpecChannelID parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_selection_id_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_selection_id</NAME>
<RETURNS>GParamSpec    *</RETURNS>
const gchar   *name,const gchar   *nick,const gchar   *blurb,Gimp          *gimp,GParamFlags    flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_selection</NAME>
<RETURNS>GimpSelection *</RETURNS>
const GValue  *value,Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_selection</NAME>
<RETURNS>void            </RETURNS>
GValue        *value,GimpSelection *selection
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VECTORS_ID</NAME>
#define GIMP_TYPE_VECTORS_ID               (gimp_vectors_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_VECTORS_ID</NAME>
#define GIMP_VALUE_HOLDS_VECTORS_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                            GIMP_TYPE_VECTORS_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_vectors_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_VECTORS_ID</NAME>
#define GIMP_TYPE_PARAM_VECTORS_ID           (gimp_param_vectors_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_VECTORS_ID</NAME>
#define GIMP_PARAM_SPEC_VECTORS_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_VECTORS_ID, GimpParamSpecVectorsID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_VECTORS_ID</NAME>
#define GIMP_IS_PARAM_SPEC_VECTORS_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_VECTORS_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecVectorsID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecVectorsID</NAME>
struct _GimpParamSpecVectorsID
{
  GimpParamSpecItemID parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_vectors_id_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_vectors_id</NAME>
<RETURNS>GParamSpec  *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_vectors</NAME>
<RETURNS>GimpVectors *</RETURNS>
const GValue *value,Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_vectors</NAME>
<RETURNS>void          </RETURNS>
GValue       *value,GimpVectors  *vectors
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DISPLAY_ID</NAME>
#define GIMP_TYPE_DISPLAY_ID               (gimp_display_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_DISPLAY_ID</NAME>
#define GIMP_VALUE_HOLDS_DISPLAY_ID(value) (G_TYPE_CHECK_VALUE_TYPE ((value),\
                                            GIMP_TYPE_DISPLAY_ID))
</MACRO>
<FUNCTION>
<NAME>gimp_display_id_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_DISPLAY_ID</NAME>
#define GIMP_TYPE_PARAM_DISPLAY_ID           (gimp_param_display_id_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_DISPLAY_ID</NAME>
#define GIMP_PARAM_SPEC_DISPLAY_ID(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_DISPLAY_ID, GimpParamSpecDisplayID))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_DISPLAY_ID</NAME>
#define GIMP_IS_PARAM_SPEC_DISPLAY_ID(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_DISPLAY_ID))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecDisplayID</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecDisplayID</NAME>
struct _GimpParamSpecDisplayID
{
  GParamSpecInt  parent_instance;

  Gimp          *gimp;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_display_id_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_display_id</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,Gimp         *gimp,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_display</NAME>
<RETURNS>GimpObject *</RETURNS>
const GValue *value,Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_display</NAME>
<RETURNS>void         </RETURNS>
GValue       *value,GimpObject   *display
</FUNCTION>
<STRUCT>
<NAME>GimpArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpArray</NAME>
struct _GimpArray
{
  guint8   *data;
  gsize     length;
  gboolean  static_data;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_array_new</NAME>
<RETURNS>GimpArray *</RETURNS>
const guint8    *data,gsize            length,gboolean         static_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_array_copy</NAME>
<RETURNS>GimpArray *</RETURNS>
const GimpArray *array
</FUNCTION>
<FUNCTION>
<NAME>gimp_array_free</NAME>
<RETURNS>void        </RETURNS>
GimpArray       *array
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ARRAY</NAME>
#define GIMP_TYPE_ARRAY               (gimp_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_ARRAY</NAME>
#define GIMP_VALUE_HOLDS_ARRAY(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_ARRAY))
</MACRO>
<FUNCTION>
<NAME>gimp_array_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_ARRAY</NAME>
#define GIMP_TYPE_PARAM_ARRAY           (gimp_param_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_ARRAY</NAME>
#define GIMP_PARAM_SPEC_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_ARRAY, GimpParamSpecArray))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_ARRAY</NAME>
#define GIMP_IS_PARAM_SPEC_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_ARRAY))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecArray</NAME>
struct _GimpParamSpecArray
{
  GParamSpecBoxed parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_array_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_array</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,GParamFlags   flags
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INT8_ARRAY</NAME>
#define GIMP_TYPE_INT8_ARRAY               (gimp_int8_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_INT8_ARRAY</NAME>
#define GIMP_VALUE_HOLDS_INT8_ARRAY(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_INT8_ARRAY))
</MACRO>
<FUNCTION>
<NAME>gimp_int8_array_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_INT8_ARRAY</NAME>
#define GIMP_TYPE_PARAM_INT8_ARRAY           (gimp_param_int8_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_INT8_ARRAY</NAME>
#define GIMP_PARAM_SPEC_INT8_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_INT8_ARRAY, GimpParamSpecInt8Array))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_INT8_ARRAY</NAME>
#define GIMP_IS_PARAM_SPEC_INT8_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_INT8_ARRAY))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecInt8Array</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecInt8Array</NAME>
struct _GimpParamSpecInt8Array
{
  GimpParamSpecArray parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_int8_array_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_int8_array</NAME>
<RETURNS>GParamSpec   *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_int8array</NAME>
<RETURNS>const guint8 *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_dup_int8array</NAME>
<RETURNS>guint8       *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_int8array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const guint8 *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_static_int8array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const guint8 *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_take_int8array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,guint8       *array,gsize         length
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INT16_ARRAY</NAME>
#define GIMP_TYPE_INT16_ARRAY               (gimp_int16_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_INT16_ARRAY</NAME>
#define GIMP_VALUE_HOLDS_INT16_ARRAY(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_INT16_ARRAY))
</MACRO>
<FUNCTION>
<NAME>gimp_int16_array_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_INT16_ARRAY</NAME>
#define GIMP_TYPE_PARAM_INT16_ARRAY           (gimp_param_int16_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_INT16_ARRAY</NAME>
#define GIMP_PARAM_SPEC_INT16_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_INT16_ARRAY, GimpParamSpecInt16Array))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_INT16_ARRAY</NAME>
#define GIMP_IS_PARAM_SPEC_INT16_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_INT16_ARRAY))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecInt16Array</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecInt16Array</NAME>
struct _GimpParamSpecInt16Array
{
  GimpParamSpecArray parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_int16_array_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_int16_array</NAME>
<RETURNS>GParamSpec   *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_int16array</NAME>
<RETURNS>const gint16 *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_dup_int16array</NAME>
<RETURNS>gint16       *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_int16array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const gint16 *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_static_int16array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const gint16 *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_take_int16array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,gint16       *array,gsize         length
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INT32_ARRAY</NAME>
#define GIMP_TYPE_INT32_ARRAY               (gimp_int32_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_INT32_ARRAY</NAME>
#define GIMP_VALUE_HOLDS_INT32_ARRAY(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_INT32_ARRAY))
</MACRO>
<FUNCTION>
<NAME>gimp_int32_array_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_INT32_ARRAY</NAME>
#define GIMP_TYPE_PARAM_INT32_ARRAY           (gimp_param_int32_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_INT32_ARRAY</NAME>
#define GIMP_PARAM_SPEC_INT32_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_INT32_ARRAY, GimpParamSpecInt32Array))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_INT32_ARRAY</NAME>
#define GIMP_IS_PARAM_SPEC_INT32_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_INT32_ARRAY))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecInt32Array</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecInt32Array</NAME>
struct _GimpParamSpecInt32Array
{
  GimpParamSpecArray parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_int32_array_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_int32_array</NAME>
<RETURNS>GParamSpec   *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_int32array</NAME>
<RETURNS>const gint32 *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_dup_int32array</NAME>
<RETURNS>gint32       *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_int32array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const gint32 *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_static_int32array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const gint32 *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_take_int32array</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,gint32       *array,gsize         length
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FLOAT_ARRAY</NAME>
#define GIMP_TYPE_FLOAT_ARRAY               (gimp_float_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_FLOAT_ARRAY</NAME>
#define GIMP_VALUE_HOLDS_FLOAT_ARRAY(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_FLOAT_ARRAY))
</MACRO>
<FUNCTION>
<NAME>gimp_float_array_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_FLOAT_ARRAY</NAME>
#define GIMP_TYPE_PARAM_FLOAT_ARRAY           (gimp_param_float_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_FLOAT_ARRAY</NAME>
#define GIMP_PARAM_SPEC_FLOAT_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_FLOAT_ARRAY, GimpParamSpecFloatArray))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_FLOAT_ARRAY</NAME>
#define GIMP_IS_PARAM_SPEC_FLOAT_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_FLOAT_ARRAY))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecFloatArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecFloatArray</NAME>
struct _GimpParamSpecFloatArray
{
  GimpParamSpecArray parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_float_array_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_float_array</NAME>
<RETURNS>GParamSpec    *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_floatarray</NAME>
<RETURNS>const gdouble *</RETURNS>
const GValue  *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_dup_floatarray</NAME>
<RETURNS>gdouble       *</RETURNS>
const GValue  *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_floatarray</NAME>
<RETURNS>void            </RETURNS>
GValue        *value,const gdouble *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_static_floatarray</NAME>
<RETURNS>void            </RETURNS>
GValue        *value,const gdouble *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_take_floatarray</NAME>
<RETURNS>void            </RETURNS>
GValue        *value,gdouble       *array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_string_array_new</NAME>
<RETURNS>GimpArray *</RETURNS>
const gchar     **data,gsize             length,gboolean          static_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_string_array_copy</NAME>
<RETURNS>GimpArray *</RETURNS>
const GimpArray  *array
</FUNCTION>
<FUNCTION>
<NAME>gimp_string_array_free</NAME>
<RETURNS>void        </RETURNS>
GimpArray        *array
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_STRING_ARRAY</NAME>
#define GIMP_TYPE_STRING_ARRAY               (gimp_string_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_STRING_ARRAY</NAME>
#define GIMP_VALUE_HOLDS_STRING_ARRAY(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_STRING_ARRAY))
</MACRO>
<FUNCTION>
<NAME>gimp_string_array_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PARAM_STRING_ARRAY</NAME>
#define GIMP_TYPE_PARAM_STRING_ARRAY           (gimp_param_string_array_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PARAM_SPEC_STRING_ARRAY</NAME>
#define GIMP_PARAM_SPEC_STRING_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GIMP_TYPE_PARAM_STRING_ARRAY, GimpParamSpecStringArray))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PARAM_SPEC_STRING_ARRAY</NAME>
#define GIMP_IS_PARAM_SPEC_STRING_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GIMP_TYPE_PARAM_STRING_ARRAY))
</MACRO>
<STRUCT>
<NAME>GimpParamSpecStringArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpParamSpecStringArray</NAME>
struct _GimpParamSpecStringArray
{
  GParamSpecBoxed parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_param_string_array_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_param_spec_string_array</NAME>
<RETURNS>GParamSpec   *</RETURNS>
const gchar  *name,const gchar  *nick,const gchar  *blurb,GParamFlags   flags
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_get_stringarray</NAME>
<RETURNS>const gchar **</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_dup_stringarray</NAME>
<RETURNS>gchar       **</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_stringarray</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const gchar **array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_set_static_stringarray</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,const gchar **array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>gimp_value_take_stringarray</NAME>
<RETURNS>void           </RETURNS>
GValue       *value,gchar       **array,gsize         length
</FUNCTION>
<FUNCTION>
<NAME>about_dialog_create</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContext *context
</FUNCTION>
<STRUCT>
<NAME>ChannelOptionsDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>ChannelOptionsDialog</NAME>
struct _ChannelOptionsDialog
{
  GtkWidget   *dialog;
  GtkWidget   *name_entry;
  GtkWidget   *color_panel;
  GtkWidget   *save_sel_checkbutton;

  GimpImage   *image;
  GimpContext *context;
  GimpChannel *channel;
};
</STRUCT>
<FUNCTION>
<NAME>channel_options_dialog_new</NAME>
<RETURNS>ChannelOptionsDialog *</RETURNS>
GimpImage     *image,GimpContext   *context,GimpChannel   *channel,GtkWidget     *parent,const GimpRGB *channel_color,const gchar   *channel_name,const gchar   *title,const gchar   *role,const gchar   *stock_id,const gchar   *desc,const gchar   *help_id,const gchar   *color_label,const gchar   *opacity_label,gboolean       show_from_sel
</FUNCTION>
<FUNCTION>
<NAME>convert_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpImage    *image,GtkWidget    *parent,GimpProgress *progress
</FUNCTION>
<STRUCT>
<NAME>DesaturateDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>DesaturateDialog</NAME>
struct _DesaturateDialog
{
  GtkWidget          *dialog;

  GimpDrawable       *drawable;
  GimpDesaturateMode  mode;
};
</STRUCT>
<FUNCTION>
<NAME>desaturate_dialog_new</NAME>
<RETURNS>DesaturateDialog *</RETURNS>
GimpDrawable       *drawable,GtkWidget          *parent,GimpDesaturateMode  mode
</FUNCTION>
<FUNCTION>
<NAME>dialogs_image_new_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_file_open_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_file_open_location_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_file_save_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_preferences_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_keyboard_shortcuts_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_module_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_tips_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_about_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_error_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_close_all_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_quit_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_toolbox_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_dock_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_dockable_constructor</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory      *factory,GimpDialogFactoryEntry *entry,GimpContext            *context,gint                    view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_tool_options_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_device_status_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_error_console_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_cursor_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_image_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_brush_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_pattern_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_gradient_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_palette_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_font_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_tool_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_buffer_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_document_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_template_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_image_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_brush_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_pattern_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_gradient_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_palette_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_font_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_tool_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_buffer_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_document_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_template_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_layer_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_channel_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_vectors_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_path_list_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_colormap_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_histogram_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_selection_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_undo_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_sample_point_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_navigation_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_color_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_brush_editor_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_gradient_editor_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>dialogs_palette_editor_get</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpContext       *context,gint               view_size
</FUNCTION>
<VARIABLE>
<NAME>global_dialog_factory</NAME>
extern GimpDialogFactory *global_dialog_factory;
</VARIABLE>
<VARIABLE>
<NAME>global_dock_factory</NAME>
extern GimpDialogFactory *global_dock_factory;
</VARIABLE>
<VARIABLE>
<NAME>global_toolbox_factory</NAME>
extern GimpDialogFactory *global_toolbox_factory;
</VARIABLE>
<FUNCTION>
<NAME>dialogs_init</NAME>
<RETURNS>void        </RETURNS>
Gimp            *gimp,GimpMenuFactory *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>dialogs_exit</NAME>
<RETURNS>void        </RETURNS>
Gimp            *gimp
</FUNCTION>
<FUNCTION>
<NAME>dialogs_get_toolbox</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>file_open_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>file_open_location_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>file_save_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>grid_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpImage *image,GtkWidget *parent
</FUNCTION>
<STRUCT>
<NAME>ImageMergeLayersDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>ImageMergeLayersDialog</NAME>
struct _ImageMergeLayersDialog
{
  GtkWidget     *dialog;

  GimpImage     *image;
  GimpContext   *context;
  GimpMergeType  merge_type;
  gboolean       discard_invisible;
};
</STRUCT>
<FUNCTION>
<NAME>image_merge_layers_dialog_new</NAME>
<RETURNS>ImageMergeLayersDialog  *</RETURNS>
GimpImage     *image,GimpContext   *context,GtkWidget     *parent,GimpMergeType  merge_type,gboolean       discard_invisible
</FUNCTION>
<FUNCTION>
<NAME>image_new_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>image_new_dialog_set</NAME>
<RETURNS>void        </RETURNS>
GtkWidget    *widget,GimpImage    *image,GimpTemplate *template
</FUNCTION>
<FUNCTION>
<NAME>image_properties_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpImage *image,GtkWidget *parent
</FUNCTION>
<STRUCT>
<NAME>ImageScaleDialog</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>ImageScaleDialogCallback</NAME>
<RETURNS>void </RETURNS>
ImageScaleDialog *dialog
</USER_FUNCTION>
<STRUCT>
<NAME>ImageScaleDialog</NAME>
struct _ImageScaleDialog
{
  GtkWidget                *dialog;

  GimpImage                *image;
  GimpDisplay              *display;
  GimpContext              *context;

  gint                      width;
  gint                      height;
  GimpUnit                  unit;
  GimpInterpolationType     interpolation;
  gdouble                   xresolution;
  gdouble                   yresolution;
  GimpUnit                  resolution_unit;

  ImageScaleDialogCallback  callback;
};
</STRUCT>
<FUNCTION>
<NAME>image_scale_dialog_new</NAME>
<RETURNS>ImageScaleDialog *</RETURNS>
GimpImage                *image,GimpDisplay              *display,GimpContext              *context,GtkWidget                *parent,ImageScaleDialogCallback  callback
</FUNCTION>
<STRUCT>
<NAME>LayerAddMaskDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>LayerAddMaskDialog</NAME>
struct _LayerAddMaskDialog
{
  GtkWidget       *dialog;

  GimpLayer       *layer;
  GimpAddMaskType  add_mask_type;
  gboolean         invert;
};
</STRUCT>
<FUNCTION>
<NAME>layer_add_mask_dialog_new</NAME>
<RETURNS>LayerAddMaskDialog *</RETURNS>
GimpLayer       *layer,GtkWidget       *parent,GimpAddMaskType  add_mask_type,gboolean         invert
</FUNCTION>
<STRUCT>
<NAME>LayerOptionsDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>LayerOptionsDialog</NAME>
struct _LayerOptionsDialog
{
  GtkWidget    *dialog;
  GtkWidget    *name_entry;
  GtkWidget    *size_se;
  GtkWidget    *rename_toggle;

  GimpFillType  fill_type;
  gint          xsize;
  gint          ysize;

  GimpImage    *image;
  GimpContext  *context;
  GimpLayer    *layer;
};
</STRUCT>
<FUNCTION>
<NAME>layer_options_dialog_new</NAME>
<RETURNS>LayerOptionsDialog *</RETURNS>
GimpImage    *image,GimpContext  *context,GimpLayer    *layer,GtkWidget    *parent,const gchar  *layer_name,GimpFillType  layer_fill_type,const gchar  *title,const gchar  *role,const gchar  *stock_id,const gchar  *desc,const gchar  *help_id
</FUNCTION>
<FUNCTION>
<NAME>module_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>offset_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDrawable *drawable,GtkWidget    *parent
</FUNCTION>
<FUNCTION>
<NAME>palette_import_dialog_show</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>palette_import_dialog_destroy</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>preferences_dialog_create</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpResolutionCallback</NAME>
<RETURNS>void </RETURNS>
GtkWidget *dialog,
                                         GimpImage *image,
                                         gdouble    xresolution,
                                         gdouble    yresolution,
                                         GimpUnit   resolution_unit,
                                         gpointer   user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>print_size_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpImage              *image,const gchar            *title,const gchar            *role,GtkWidget              *parent,GimpHelpFunc            help_func,const gchar            *help_id,GimpResolutionCallback  callback,gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>quit_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>close_all_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpResizeCallback</NAME>
<RETURNS>void </RETURNS>
GtkWidget             *dialog,
                                     GimpViewable          *viewable,
                                     gint                   width,
                                     gint                   height,
                                     GimpUnit               unit,
                                     gint                   offset_x,
                                     gint                   offset_y,
                                     GimpImageResizeLayers  resize_layers,
                                     gpointer               user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>resize_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewable          *viewable,const gchar           *title,const gchar           *role,GtkWidget             *parent,GimpHelpFunc           help_func,const gchar           *help_id,GimpUnit               unit,GimpResizeCallback     callback,gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>resolution_calibrate_dialog</NAME>
<RETURNS>void  </RETURNS>
GtkWidget  *resolution_entry,GdkPixbuf  *pixbuf
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpScaleCallback</NAME>
<RETURNS>void </RETURNS>
GtkWidget             *dialog,
                                    GimpViewable          *viewable,
                                    gint                   width,
                                    gint                   height,
                                    GimpUnit               unit,
                                    GimpInterpolationType  interpolation,
                                    gdouble                xresolution,
                                    gdouble                yresolution,
                                    GimpUnit               resolution_unit,
                                    gpointer               user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>scale_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewable          *viewable,const gchar           *title,const gchar           *role,GtkWidget             *parent,GimpHelpFunc           help_func,const gchar           *help_id,GimpUnit               unit,GimpInterpolationType  interpolation,GimpScaleCallback      callback,gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>stroke_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpItem    *item,const gchar *title,const gchar *stock_id,const gchar *help_id,GtkWidget   *parent
</FUNCTION>
<STRUCT>
<NAME>TemplateOptionsDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>TemplateOptionsDialog</NAME>
struct _TemplateOptionsDialog
{
  GtkWidget    *dialog;
  GtkWidget    *editor;

  Gimp         *gimp;
  GimpTemplate *template;
};
</STRUCT>
<FUNCTION>
<NAME>template_options_dialog_new</NAME>
<RETURNS>TemplateOptionsDialog *</RETURNS>
Gimp         *gimp,GimpTemplate *template,GtkWidget    *parent,const gchar  *title,const gchar  *role,const gchar  *stock_id,const gchar  *desc,const gchar  *help_id
</FUNCTION>
<FUNCTION>
<NAME>tips_dialog_create</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<STRUCT>
<NAME>GimpTip</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTip</NAME>
struct _GimpTip
{
  gchar *welcome;
  gchar *thetip;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tip_new</NAME>
<RETURNS>GimpTip *</RETURNS>
const gchar  *welcome,const gchar  *thetip
</FUNCTION>
<FUNCTION>
<NAME>gimp_tip_free</NAME>
<RETURNS>void      </RETURNS>
GimpTip      *tip
</FUNCTION>
<FUNCTION>
<NAME>gimp_tips_from_file</NAME>
<RETURNS>GList   *</RETURNS>
const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_tips_free</NAME>
<RETURNS>void      </RETURNS>
GList        *tips
</FUNCTION>
<FUNCTION>
<NAME>user_install_dialog_run</NAME>
<RETURNS>void  </RETURNS>
const gchar *alternate_system_gimprc,const gchar *alernate_gimprc,gboolean     verbose
</FUNCTION>
<STRUCT>
<NAME>VectorsExportDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>VectorsExportDialog</NAME>
struct _VectorsExportDialog
{
  GtkWidget *dialog;

  GimpImage *image;
  gboolean   active_only;
};
</STRUCT>
<FUNCTION>
<NAME>vectors_export_dialog_new</NAME>
<RETURNS>VectorsExportDialog *</RETURNS>
GimpImage *image,GtkWidget *parent,gboolean   active_only
</FUNCTION>
<STRUCT>
<NAME>VectorsImportDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>VectorsImportDialog</NAME>
struct _VectorsImportDialog
{
  GtkWidget *dialog;

  GimpImage *image;
  gboolean    merge_vectors;
  gboolean    scale_vectors;
};
</STRUCT>
<FUNCTION>
<NAME>vectors_import_dialog_new</NAME>
<RETURNS>VectorsImportDialog *</RETURNS>
GimpImage *image,GtkWidget *parent,gboolean   merge_vectors,gboolean   scale_vectors
</FUNCTION>
<STRUCT>
<NAME>VectorsOptionsDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>VectorsOptionsDialog</NAME>
struct _VectorsOptionsDialog
{
  GtkWidget   *dialog;
  GtkWidget   *name_entry;

  GimpImage   *image;
  GimpVectors *vectors;
};
</STRUCT>
<FUNCTION>
<NAME>vectors_options_dialog_new</NAME>
<RETURNS>VectorsOptionsDialog *</RETURNS>
GimpImage   *image,GimpVectors *vectors,GtkWidget   *parent,const gchar *vectors_name,const gchar *title,const gchar *role,const gchar *stock_id,const gchar *desc,const gchar *help_id
</FUNCTION>
<FUNCTION>
<NAME>keyboard_shortcuts_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CURSOR_MODE</NAME>
#define GIMP_TYPE_CURSOR_MODE (gimp_cursor_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_cursor_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCursorMode</NAME>
typedef enum
{
  GIMP_CURSOR_MODE_TOOL_ICON,       /*< desc="Tool icon"                >*/
  GIMP_CURSOR_MODE_TOOL_CROSSHAIR,  /*< desc="Tool icon with crosshair" >*/
  GIMP_CURSOR_MODE_CROSSHAIR        /*< desc="Crosshair only"           >*/
} GimpCursorMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CANVAS_PADDING_MODE</NAME>
#define GIMP_TYPE_CANVAS_PADDING_MODE (gimp_canvas_padding_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_canvas_padding_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCanvasPaddingMode</NAME>
typedef enum
{
  GIMP_CANVAS_PADDING_MODE_DEFAULT,      /*< desc="From theme"        >*/
  GIMP_CANVAS_PADDING_MODE_LIGHT_CHECK,  /*< desc="Light check color" >*/
  GIMP_CANVAS_PADDING_MODE_DARK_CHECK,   /*< desc="Dark check color"  >*/
  GIMP_CANVAS_PADDING_MODE_CUSTOM,       /*< desc="Custom color"      >*/
  GIMP_CANVAS_PADDING_MODE_RESET = -1    /*< skip >*/
} GimpCanvasPaddingMode;
</ENUM>
<STRUCT>
<NAME>GimpCanvas</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplay</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplayShell</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpNavigationEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpScaleComboBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStatusbar</NAME>
</STRUCT>
<STRUCT>
<NAME>Selection</NAME>
</STRUCT>
<ENUM>
<NAME>GimpCanvasStyle</NAME>
typedef enum
{
  GIMP_CANVAS_STYLE_BLACK,
  GIMP_CANVAS_STYLE_WHITE,
  GIMP_CANVAS_STYLE_RENDER,
  GIMP_CANVAS_STYLE_XOR,
  GIMP_CANVAS_STYLE_XOR_DASHED,
  GIMP_CANVAS_STYLE_XOR_DOTTED,
  GIMP_CANVAS_STYLE_SELECTION_IN,
  GIMP_CANVAS_STYLE_SELECTION_OUT,
  GIMP_CANVAS_STYLE_LAYER_BOUNDARY,
  GIMP_CANVAS_STYLE_GUIDE_NORMAL,
  GIMP_CANVAS_STYLE_GUIDE_ACTIVE,
  GIMP_CANVAS_STYLE_SAMPLE_POINT_NORMAL,
  GIMP_CANVAS_STYLE_SAMPLE_POINT_ACTIVE,
  GIMP_CANVAS_STYLE_CUSTOM,
  GIMP_CANVAS_NUM_STYLES
} GimpCanvasStyle;
</ENUM>
<MACRO>
<NAME>GIMP_CANVAS_NUM_STIPPLES</NAME>
#define GIMP_CANVAS_NUM_STIPPLES  8
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_CANVAS</NAME>
#define GIMP_TYPE_CANVAS            (gimp_canvas_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CANVAS</NAME>
#define GIMP_CANVAS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CANVAS, GimpCanvas))
</MACRO>
<MACRO>
<NAME>GIMP_CANVAS_CLASS</NAME>
#define GIMP_CANVAS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CANVAS, GimpCanvasClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CANVAS</NAME>
#define GIMP_IS_CANVAS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CANVAS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CANVAS_CLASS</NAME>
#define GIMP_IS_CANVAS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CANVAS))
</MACRO>
<MACRO>
<NAME>GIMP_CANVAS_GET_CLASS</NAME>
#define GIMP_CANVAS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CANVAS, GimpCanvasClass))
</MACRO>
<STRUCT>
<NAME>GimpCanvasClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCanvas</NAME>
struct _GimpCanvas
{
  GtkDrawingArea  parent_instance;

  GdkGC          *gc[GIMP_CANVAS_NUM_STYLES];
  GdkBitmap      *stipple[GIMP_CANVAS_NUM_STIPPLES];
  PangoLayout    *layout;
};
</STRUCT>
<STRUCT>
<NAME>GimpCanvasClass</NAME>
struct _GimpCanvasClass
{
  GtkDrawingAreaClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_canvas_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_cursor</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,gint             x,gint             y
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_point</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gint             x,gint             y
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_points</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,GdkPoint        *points,gint             num_points
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_line</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gint             x1,gint             y1,gint             x2,gint             y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_lines</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,GdkPoint        *points,gint             num_points
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_rectangle</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gboolean         filled,gint             x,gint             y,gint             width,gint             height
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_arc</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gboolean         filled,gint             x,gint             y,gint             width,gint             height,gint             angle1,gint             angle2
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_polygon</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gboolean         filled,GdkPoint        *points,gint             num_points
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_segments</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,GdkSegment      *segments,gint             num_segments
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_text</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gint             x,gint             y,const gchar     *format,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_draw_rgb</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,gint             x,gint             y,gint             width,gint             height,guchar          *rgb_buf,gint             rowstride,gint             xdith,gint             ydith
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_set_clip_rect</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,GdkRectangle    *rect
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_set_clip_region</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,GdkRegion       *region
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_set_stipple_index</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpCanvasStyle  style,guint            index
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_set_custom_gc</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GdkGC           *gc
</FUNCTION>
<FUNCTION>
<NAME>gimp_canvas_set_bg_color</NAME>
<RETURNS>void         </RETURNS>
GimpCanvas      *canvas,GimpRGB         *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_displays_dirty</NAME>
<RETURNS>gboolean        </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_displays_get_dirty_images</NAME>
<RETURNS>GimpContainer *</RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_displays_delete</NAME>
<RETURNS>void            </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_displays_reconnect</NAME>
<RETURNS>void            </RETURNS>
Gimp      *gimp,GimpImage *old,GimpImage *new
</FUNCTION>
<FUNCTION>
<NAME>gimp_displays_set_busy</NAME>
<RETURNS>void            </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_displays_unset_busy</NAME>
<RETURNS>void            </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_connect</NAME>
<RETURNS>void   </RETURNS>
GimpDisplay *display,GimpImage   *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_disconnect</NAME>
<RETURNS>void   </RETURNS>
GimpDisplay *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DISPLAY</NAME>
#define GIMP_TYPE_DISPLAY            (gimp_display_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY</NAME>
#define GIMP_DISPLAY(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DISPLAY, GimpDisplay))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_CLASS</NAME>
#define GIMP_DISPLAY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DISPLAY, GimpDisplayClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY</NAME>
#define GIMP_IS_DISPLAY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DISPLAY))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_CLASS</NAME>
#define GIMP_IS_DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DISPLAY))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_GET_CLASS</NAME>
#define GIMP_DISPLAY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DISPLAY, GimpDisplayClass))
</MACRO>
<STRUCT>
<NAME>GimpDisplayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplay</NAME>
struct _GimpDisplay
{
  GimpObject  parent_instance;

  gint        ID;               /*  unique identifier for this display     */

  GimpImage  *image;            /*  pointer to the associated image        */
  gint        instance;         /*  the instance # of this display as      */
                                /*  taken from the image at creation       */

  GtkWidget  *shell;            /*  shell widget for this display          */

  GSList     *update_areas;     /*  Update areas list                      */
};
</STRUCT>
<STRUCT>
<NAME>GimpDisplayClass</NAME>
struct _GimpDisplayClass
{
  GimpObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_display_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_new</NAME>
<RETURNS>GimpDisplay *</RETURNS>
GimpImage       *image,GimpUnit         unit,gdouble          scale,GimpMenuFactory *menu_factory,GimpUIManager   *popup_manager
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_delete</NAME>
<RETURNS>void          </RETURNS>
GimpDisplay     *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_get_ID</NAME>
<RETURNS>gint          </RETURNS>
GimpDisplay     *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_get_by_ID</NAME>
<RETURNS>GimpDisplay *</RETURNS>
Gimp            *gimp,gint             ID
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_reconnect</NAME>
<RETURNS>void          </RETURNS>
GimpDisplay     *display,GimpImage       *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_update_area</NAME>
<RETURNS>void          </RETURNS>
GimpDisplay     *display,gboolean         now,gint             x,gint             y,gint             w,gint             h
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_flush</NAME>
<RETURNS>void          </RETURNS>
GimpDisplay     *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_flush_now</NAME>
<RETURNS>void          </RETURNS>
GimpDisplay     *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DISPLAY_OPTIONS</NAME>
#define GIMP_TYPE_DISPLAY_OPTIONS            (gimp_display_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_DISPLAY_OPTIONS_FULLSCREEN</NAME>
#define GIMP_TYPE_DISPLAY_OPTIONS_FULLSCREEN (gimp_display_options_fullscreen_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_OPTIONS</NAME>
#define GIMP_DISPLAY_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DISPLAY_OPTIONS, GimpDisplayOptions))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_OPTIONS_CLASS</NAME>
#define GIMP_DISPLAY_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DISPLAY_OPTIONS, GimpDisplayOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_OPTIONS</NAME>
#define GIMP_IS_DISPLAY_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DISPLAY_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_OPTIONS_CLASS</NAME>
#define GIMP_IS_DISPLAY_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DISPLAY_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_OPTIONS_GET_CLASS</NAME>
#define GIMP_DISPLAY_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DISPLAY_OPTIONS, GimpDisplayOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpDisplayOptionsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplayOptions</NAME>
struct _GimpDisplayOptions
{
  GObject                parent_instance;

  /*  GimpDisplayShell options  */
  gboolean               show_menubar;
  gboolean               show_rulers;
  gboolean               show_scrollbars;
  gboolean               show_statusbar;

  /*  GimpCanvas options  */
  gboolean               show_selection;
  gboolean               show_layer_boundary;
  gboolean               show_guides;
  gboolean               show_grid;
  gboolean               show_sample_points;
  GimpCanvasPaddingMode  padding_mode;
  GimpRGB                padding_color;
  gboolean               padding_mode_set;
};
</STRUCT>
<STRUCT>
<NAME>GimpDisplayOptionsClass</NAME>
struct _GimpDisplayOptionsClass
{
  GObjectClass           parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_display_options_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_options_fullscreen_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_fullscreen</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          fullscreen
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_fullscreen</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_menubar</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_menubar</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_rulers</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_rulers</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_scrollbars</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_scrollbars</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_statusbar</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_statusbar</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_selection</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_selection</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_layer</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_layer</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_transform</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_transform</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_grid</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_grid</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_guides</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_guides</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_snap_to_grid</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          snap
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_snap_to_grid</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_show_sample_points</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          show
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_show_sample_points</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_snap_to_guides</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          snap
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_snap_to_guides</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_snap_to_canvas</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          snap
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_snap_to_canvas</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_snap_to_vectors</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,gboolean          snap
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_snap_to_vectors</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_padding</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,GimpCanvasPaddingMode  mode,const GimpRGB    *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_padding</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell,GimpCanvasPaddingMode *mode,GimpRGB          *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_autoscroll_start</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,GdkModifierType   state,GdkEventMotion   *mevent
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_autoscroll_stop</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<MACRO>
<NAME>GIMP_DISPLAY_SHELL_CANVAS_EVENT_MASK</NAME>
#define GIMP_DISPLAY_SHELL_CANVAS_EVENT_MASK (GDK_EXPOSURE_MASK            | \
                                              GDK_POINTER_MOTION_MASK      | \
                                              GDK_POINTER_MOTION_HINT_MASK | \
                                              GDK_BUTTON_PRESS_MASK        | \
                                              GDK_BUTTON_RELEASE_MASK      | \
                                              GDK_STRUCTURE_MASK           | \
                                              GDK_ENTER_NOTIFY_MASK        | \
                                              GDK_LEAVE_NOTIFY_MASK        | \
                                              GDK_FOCUS_CHANGE_MASK        | \
                                              GDK_KEY_PRESS_MASK           | \
                                              GDK_KEY_RELEASE_MASK         | \
                                              GDK_PROXIMITY_OUT_MASK)
</MACRO>
<FUNCTION>
<NAME>gimp_display_shell_events</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEvent         *event,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_canvas_realize</NAME>
<RETURNS>void       </RETURNS>
GtkWidget        *widget,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_canvas_size_allocate</NAME>
<RETURNS>void       </RETURNS>
GtkWidget        *widget,GtkAllocation    *alloc,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_canvas_expose</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEventExpose   *eevent,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_canvas_tool_events</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEvent         *event,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_hruler_button_press</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEventButton   *bevent,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_vruler_button_press</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEventButton   *bevent,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_origin_button_press</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEventButton   *bevent,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_quick_mask_button_press</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEventButton   *bevent,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_quick_mask_toggled</NAME>
<RETURNS>void       </RETURNS>
GtkWidget        *widget,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_nav_button_press</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget        *widget,GdkEventButton   *bevent,GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_close</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,gboolean          kill_it
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_event_coords</NAME>
<RETURNS>gboolean </RETURNS>
GimpDisplayShell *shell,GdkEvent         *event,GdkDevice        *device,GimpCoords       *coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_device_coords</NAME>
<RETURNS>void     </RETURNS>
GimpDisplayShell *shell,GdkDevice        *device,GimpCoords       *coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_time_coords</NAME>
<RETURNS>void     </RETURNS>
GimpDisplayShell *shell,GdkDevice        *device,GdkTimeCoord     *event,GimpCoords       *coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_event_state</NAME>
<RETURNS>gboolean </RETURNS>
GimpDisplayShell *shell,GdkEvent         *event,GdkDevice        *device,GdkModifierType  *state
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_device_state</NAME>
<RETURNS>void     </RETURNS>
GimpDisplayShell *shell,GdkDevice        *device,GdkModifierType  *state
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_cursor</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,GimpCursorType      cursor_type,GimpToolCursorType  tool_cursor,GimpCursorModifier  modifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_override_cursor</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,GimpCursorType      cursor_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_unset_override_cursor</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_update_cursor</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,gint                display_x,gint                display_y,gint                image_x,gint                image_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_clear_cursor</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_dnd_init</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_guide</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,GimpGuide          *guide,gboolean            active
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_guides</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_grid</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,const GdkRectangle *area
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_pen</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,const GimpVector2  *points,gint                num_points,GimpContext        *context,GimpActiveColor     color,gint                width
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_sample_point</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,GimpSamplePoint    *sample_point,gboolean            active
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_sample_points</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_vector</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,GimpVectors        *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_vectors</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_cursor</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_draw_area</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell   *shell,gint                x,gint                y,gint                w,gint                h
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_filter_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_filter_set</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell      *shell,GimpColorDisplayStack *stack
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_filter_new</NAME>
<RETURNS>GimpColorDisplayStack *</RETURNS>
GimpColorConfig *config
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_connect</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_disconnect</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_layer_select_init</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,gint              move,guint32           time
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_preview_transform</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_render_init</NAME>
<RETURNS>void   </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_render_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_render</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,gint              x,gint              y,gint              w,gint              h,GdkRectangle     *highlight
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_setup</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_set_dot_for_dot</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,gboolean          dot_for_dot
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,GimpZoomType      zoom_type,gdouble           scale
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_to</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,GimpZoomType      zoom_type,gdouble           scale,gdouble           x,gdouble           y
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_fit_in</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_fit_to</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_by_values</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,gdouble           scale,gint              offset_x,gint              offset_y,gboolean          resize_window
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_shrink_wrap</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_resize</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell,gboolean          resize_window,gboolean          redisplay
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scale_dialog</NAME>
<RETURNS>void   </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scroll</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDisplayShell *shell,gint              x_offset,gint              y_offset
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scroll_clamp_offsets</NAME>
<RETURNS>void       </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<STRUCT>
<NAME>Selection</NAME>
struct _Selection
{
  GimpDisplayShell *shell;            /*  shell that owns the selection     */
  GdkSegment       *segs_in;          /*  gdk segments of area boundary     */
  GdkSegment       *segs_out;         /*  gdk segments of area boundary     */
  GdkSegment       *segs_layer;       /*  gdk segments of area boundary     */
  gint              num_segs_in;      /*  number of segments in segs1       */
  gint              num_segs_out;     /*  number of segments in segs2       */
  gint              num_segs_layer;   /*  number of segments in segs3       */
  guint             index;            /*  index of current stipple pattern  */
  gint              state;            /*  internal drawing state            */
  gint              paused;           /*  count of pause requests           */
  gboolean          recalc;           /*  flag to recalculate the selection */
  gboolean          hidden;           /*  is the selection hidden?          */
  gboolean          layer_hidden;     /*  is the layer boundary hidden?     */
  guint             timeout_id;       /*  timer for successive draws        */
  GdkPoint         *points_in[8];     /*  points of segs_in for fast ants   */
  gint              num_points_in[8]; /*  number of points in points_in     */
};
</STRUCT>
<FUNCTION>
<NAME>gimp_display_shell_selection_new</NAME>
<RETURNS>Selection *</RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_free</NAME>
<RETURNS>void   </RETURNS>
Selection    *select
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_pause</NAME>
<RETURNS>void   </RETURNS>
Selection    *select
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_resume</NAME>
<RETURNS>void   </RETURNS>
Selection    *select
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_start</NAME>
<RETURNS>void   </RETURNS>
Selection    *select,gboolean      recalc
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_invis</NAME>
<RETURNS>void   </RETURNS>
Selection    *select
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_layer_invis</NAME>
<RETURNS>void   </RETURNS>
Selection    *select
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_set_hidden</NAME>
<RETURNS>void   </RETURNS>
Selection    *select,gboolean      hidden
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_layer_set_hidden</NAME>
<RETURNS>void   </RETURNS>
Selection    *select,gboolean      hidden
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_title_init</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_title_update</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_transform_coords</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,GimpCoords       *image_coords,GimpCoords       *display_coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_untransform_coords</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,GimpCoords       *display_coords,GimpCoords       *image_coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_transform_xy</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,gdouble           x,gdouble           y,gint             *nx,gint             *ny,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_untransform_xy</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,gint              x,gint              y,gint             *nx,gint             *ny,gboolean          round,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_transform_xy_f</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,gdouble           x,gdouble           y,gdouble          *nx,gdouble          *ny,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_untransform_xy_f</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,gdouble           x,gdouble           y,gdouble          *nx,gdouble          *ny,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_untransform_viewport</NAME>
<RETURNS>void  </RETURNS>
GimpDisplayShell *shell,gint             *x,gint             *y,gint             *width,gint             *height
</FUNCTION>
<MACRO>
<NAME>PROJ_ROUND</NAME>
#define  PROJ_ROUND(coord) ((gint) ceil (coord))
</MACRO>
<MACRO>
<NAME>SCREEN_XRES</NAME>
#define  SCREEN_XRES(s)   ((s)->dot_for_dot ? \
                           (s)->display->image->xresolution : (s)->monitor_xres)
</MACRO>
<MACRO>
<NAME>SCREEN_YRES</NAME>
#define  SCREEN_YRES(s)   ((s)->dot_for_dot ? \
                           (s)->display->image->yresolution : (s)->monitor_yres)
</MACRO>
<MACRO>
<NAME>SCALEFACTOR_X</NAME>
#define  SCALEFACTOR_X(s) (gimp_zoom_model_get_factor ((s)->zoom) \
                           * SCREEN_XRES(s) / (s)->display->image->xresolution)
</MACRO>
<MACRO>
<NAME>SCALEFACTOR_Y</NAME>
#define  SCALEFACTOR_Y(s) (gimp_zoom_model_get_factor ((s)->zoom) \
                           * SCREEN_YRES(s) / (s)->display->image->yresolution)
</MACRO>
<MACRO>
<NAME>SCALEX</NAME>
#define  SCALEX(s,x)      PROJ_ROUND ((x) * SCALEFACTOR_X(s))
</MACRO>
<MACRO>
<NAME>SCALEY</NAME>
#define  SCALEY(s,y)      PROJ_ROUND ((y) * SCALEFACTOR_Y(s))
</MACRO>
<MACRO>
<NAME>UNSCALEX</NAME>
#define  UNSCALEX(s,x)    ((gint) ((x) / SCALEFACTOR_X(s)))
</MACRO>
<MACRO>
<NAME>UNSCALEY</NAME>
#define  UNSCALEY(s,y)    ((gint) ((y) / SCALEFACTOR_Y(s)))
</MACRO>
<MACRO>
<NAME>FUNSCALEX</NAME>
#define  FUNSCALEX(s,x)   ((x) / SCALEFACTOR_X(s))
</MACRO>
<MACRO>
<NAME>FUNSCALEY</NAME>
#define  FUNSCALEY(s,y)   ((y) / SCALEFACTOR_Y(s))
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_DISPLAY_SHELL</NAME>
#define GIMP_TYPE_DISPLAY_SHELL            (gimp_display_shell_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_SHELL</NAME>
#define GIMP_DISPLAY_SHELL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DISPLAY_SHELL, GimpDisplayShell))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_SHELL_CLASS</NAME>
#define GIMP_DISPLAY_SHELL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DISPLAY_SHELL, GimpDisplayShellClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_SHELL</NAME>
#define GIMP_IS_DISPLAY_SHELL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DISPLAY_SHELL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DISPLAY_SHELL_CLASS</NAME>
#define GIMP_IS_DISPLAY_SHELL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DISPLAY_SHELL))
</MACRO>
<MACRO>
<NAME>GIMP_DISPLAY_SHELL_GET_CLASS</NAME>
#define GIMP_DISPLAY_SHELL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DISPLAY_SHELL, GimpDisplayShellClass))
</MACRO>
<STRUCT>
<NAME>GimpDisplayShellClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDisplayShell</NAME>
struct _GimpDisplayShell
{
  GtkWindow         parent_instance;

  GimpDisplay      *display;

  GimpUIManager    *menubar_manager;
  GimpUIManager    *popup_manager;

  gdouble           monitor_xres;
  gdouble           monitor_yres;

  GimpUnit          unit;

  GimpZoomModel    *zoom;
  gdouble           other_scale;       /*  scale factor entered in Zoom->Other     */
  gboolean          dot_for_dot;       /*  is monitor resolution being ignored?    */

  gint              offset_x;          /*  offset of display image into raw image  */
  gint              offset_y;

  gint              disp_width;        /*  width of drawing area              */
  gint              disp_height;       /*  height of drawing area             */
  gint              disp_xoffset;
  gint              disp_yoffset;

  gboolean          proximity;         /*  is a device in proximity           */
  gboolean          snap_to_guides;    /*  should the guides be snapped to?   */
  gboolean          snap_to_grid;      /*  should the grid be snapped to?     */
  gboolean          snap_to_canvas;    /*  should the canvas be snapped to?   */
  gboolean          snap_to_vectors;   /*  should the active path be snapped  */

  Selection        *select;            /*  Selection object                   */

  GtkWidget        *canvas;            /*  GimpCanvas widget                  */
  GdkGC            *grid_gc;           /*  GC for grid drawing                */
  GdkGC            *pen_gc;            /*  GC for felt pen drawing            */

  GtkAdjustment    *hsbdata;           /*  adjustments                        */
  GtkAdjustment    *vsbdata;
  GtkWidget        *hsb;               /*  scroll bars                        */
  GtkWidget        *vsb;

  GtkWidget        *hrule;             /*  rulers                             */
  GtkWidget        *vrule;

  GtkWidget        *origin_button;     /*  NW: origin button                  */
  GtkWidget        *quick_mask_button; /*  SW: quick mask button              */
  GtkWidget        *zoom_button;       /*  NE: zoom toggle button             */
  GtkWidget        *nav_ebox;          /*  SE: navigation event box           */

  GtkWidget        *menubar;           /*  menubar                            */
  GtkWidget        *statusbar;         /*  statusbar                          */

  guchar           *render_buf;        /*  buffer for rendering the image     */

  guint             title_idle_id;     /*  title update idle ID               */

  gint              icon_size;         /*  size of the icon pixmap            */
  guint             icon_idle_id;      /*  ID of the idle-function            */

  GimpCursorFormat    cursor_format;   /*  Currently used cursor format       */
  GimpCursorType      current_cursor;  /*  Currently installed main cursor    */
  GimpToolCursorType  tool_cursor;     /*  Current Tool cursor                */
  GimpCursorModifier  cursor_modifier; /*  Cursor modifier (plus, minus, ...) */

  GimpCursorType    override_cursor;   /*  Overriding cursor                  */
  gboolean          using_override_cursor; /*  is the cursor overridden?      */

  gboolean          draw_cursor;       /* should we draw software cursor ?    */
  gboolean          have_cursor;       /* is cursor currently drawn ?         */
  gint              cursor_x;          /* software cursor X value             */
  gint              cursor_y;          /* software cursor Y value             */

  GtkWidget        *close_dialog;      /*  close dialog                       */
  GtkWidget        *scale_dialog;      /*  scale (zoom) dialog                */
  GtkWidget        *nav_popup;         /*  navigation popup                   */
  GtkWidget        *grid_dialog;       /*  grid configuration dialog          */

  GimpColorDisplayStack *filter_stack;   /* color display conversion stuff    */
  guint                  filter_idle_id;
  GtkWidget             *filters_dialog; /* color display filter dialog       */

  gint              paused_count;

  GQuark            vectors_freeze_handler;
  GQuark            vectors_thaw_handler;
  GQuark            vectors_visible_handler;

  GdkWindowState    window_state;      /* for fullscreen display              */
  gboolean          zoom_on_resize;
  gboolean          show_transform_preview;

  GimpDisplayOptions *options;
  GimpDisplayOptions *fullscreen_options;

  /*  the state of gimp_display_shell_tool_events()  */
  gboolean          space_pressed;
  gboolean          space_release_pending;
  gboolean          scrolling;
  gint              scroll_start_x;
  gint              scroll_start_y;
  gboolean          button_press_before_focus;
  guint32           last_motion_time;

  GdkRectangle     *highlight;         /* in image coordinates, can be NULL   */
  GimpDrawable     *mask;
  GimpChannelType   mask_color;

  gpointer          scroll_info;
};
</STRUCT>
<STRUCT>
<NAME>GimpDisplayShellClass</NAME>
struct _GimpDisplayShellClass
{
  GtkWindowClass  parent_class;

  void (* scaled)    (GimpDisplayShell *shell);
  void (* scrolled)  (GimpDisplayShell *shell);
  void (* reconnect) (GimpDisplayShell *shell);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_display_shell_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDisplay      *display,GimpUnit          unit,gdouble           scale,GimpMenuFactory  *menu_factory,GimpUIManager    *popup_manager
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_reconnect</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scaled</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_scrolled</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_unit</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,GimpUnit          unit
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_get_unit</NAME>
<RETURNS>GimpUnit    </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_snap_coords</NAME>
<RETURNS>gboolean    </RETURNS>
GimpDisplayShell *shell,GimpCoords       *coords,GimpCoords       *snapped_coords,gint              snap_offset_x,gint              snap_offset_y,gint              snap_width,gint              snap_height
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_mask_bounds</NAME>
<RETURNS>gboolean    </RETURNS>
GimpDisplayShell *shell,gint             *x1,gint             *y1,gint             *x2,gint             *y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_expose_area</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,gint              x,gint              y,gint              w,gint              h
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_expose_guide</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,GimpGuide        *guide
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_expose_sample_point</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,GimpSamplePoint  *sample_point
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_expose_full</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_flush</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,gboolean          now
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_pause</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_resume</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_update_icon</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_shrink_wrap</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_selection_visibility</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,GimpSelectionControl  control
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_highlight</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,const GdkRectangle *highlight
</FUNCTION>
<FUNCTION>
<NAME>gimp_display_shell_set_mask</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,GimpDrawable     *mask,GimpChannelType   color
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_NAVIGATION_EDITOR</NAME>
#define GIMP_TYPE_NAVIGATION_EDITOR            (gimp_navigation_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_NAVIGATION_EDITOR</NAME>
#define GIMP_NAVIGATION_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_NAVIGATION_EDITOR, GimpNavigationEditor))
</MACRO>
<MACRO>
<NAME>GIMP_NAVIGATION_EDITOR_CLASS</NAME>
#define GIMP_NAVIGATION_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_NAVIGATION_EDITOR, GimpNavigationEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NAVIGATION_EDITOR</NAME>
#define GIMP_IS_NAVIGATION_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_NAVIGATION_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NAVIGATION_EDITOR_CLASS</NAME>
#define GIMP_IS_NAVIGATION_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_NAVIGATION_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_NAVIGATION_EDITOR_GET_CLASS</NAME>
#define GIMP_NAVIGATION_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_NAVIGATION_EDITOR, GimpNavigationEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpNavigationEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpNavigationEditor</NAME>
struct _GimpNavigationEditor
{
  GimpEditor        parent_instance;

  GimpContext      *context;
  GimpDisplayShell *shell;

  GtkWidget        *view;
  GtkWidget        *zoom_label;
  GtkAdjustment    *zoom_adjustment;

  GtkWidget        *zoom_out_button;
  GtkWidget        *zoom_in_button;
  GtkWidget        *zoom_100_button;
  GtkWidget        *zoom_fit_in_button;
  GtkWidget        *zoom_fit_to_button;
  GtkWidget        *shrink_wrap_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpNavigationEditorClass</NAME>
struct _GimpNavigationEditorClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_navigation_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_navigation_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpMenuFactory  *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_navigation_editor_popup</NAME>
<RETURNS>void        </RETURNS>
GimpDisplayShell *shell,GtkWidget        *widget,gint              click_x,gint              click_y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SCALE_COMBO_BOX</NAME>
#define GIMP_TYPE_SCALE_COMBO_BOX            (gimp_scale_combo_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SCALE_COMBO_BOX</NAME>
#define GIMP_SCALE_COMBO_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SCALE_COMBO_BOX, GimpScaleComboBox))
</MACRO>
<MACRO>
<NAME>GIMP_SCALE_COMBO_BOX_CLASS</NAME>
#define GIMP_SCALE_COMBO_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SCALE_COMBO_BOX, GimpScaleComboBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SCALE_COMBO_BOX</NAME>
#define GIMP_IS_SCALE_COMBO_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SCALE_COMBO_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SCALE_COMBO_BOX_CLASS</NAME>
#define GIMP_IS_SCALE_COMBO_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SCALE_COMBO_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_SCALE_COMBO_BOX_GET_CLASS</NAME>
#define GIMP_SCALE_COMBO_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SCALE_COMBO_BOX, GimpScaleComboBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpScaleComboBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpScaleComboBoxClass</NAME>
struct _GimpScaleComboBoxClass
{
  GtkComboBoxClass  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpScaleComboBox</NAME>
struct _GimpScaleComboBox
{
  GtkComboBox       parent_instance;

  gboolean          actions_added;
  GtkTreePath      *last_path;
  GList            *mru;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_scale_combo_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_scale_combo_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_scale_combo_box_add_action</NAME>
<RETURNS>void        </RETURNS>
GimpScaleComboBox *combo_box,GtkAction         *action,const gchar       *label
</FUNCTION>
<FUNCTION>
<NAME>gimp_scale_combo_box_set_scale</NAME>
<RETURNS>void        </RETURNS>
GimpScaleComboBox *combo_box,gdouble            scale
</FUNCTION>
<FUNCTION>
<NAME>gimp_scale_combo_box_get_scale</NAME>
<RETURNS>gdouble     </RETURNS>
GimpScaleComboBox *combo_box
</FUNCTION>
<MACRO>
<NAME>CURSOR_FORMAT_LENGTH</NAME>
#define CURSOR_FORMAT_LENGTH 32
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_STATUSBAR</NAME>
#define GIMP_TYPE_STATUSBAR            (gimp_statusbar_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_STATUSBAR</NAME>
#define GIMP_STATUSBAR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_STATUSBAR, GimpStatusbar))
</MACRO>
<MACRO>
<NAME>GIMP_STATUSBAR_CLASS</NAME>
#define GIMP_STATUSBAR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_STATUSBAR, GimpStatusbarClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STATUSBAR</NAME>
#define GIMP_IS_STATUSBAR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_STATUSBAR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STATUSBAR_CLASS</NAME>
#define GIMP_IS_STATUSBAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_STATUSBAR))
</MACRO>
<MACRO>
<NAME>GIMP_STATUSBAR_GET_CLASS</NAME>
#define GIMP_STATUSBAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_STATUSBAR, GimpStatusbarClass))
</MACRO>
<STRUCT>
<NAME>GimpStatusbarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStatusbar</NAME>
struct _GimpStatusbar
{
  GtkHBox           parent_instance;

  GSList           *messages;
  GSList           *keys;
  guint             seq_context_id;

  GimpDisplayShell *shell;

  gchar             cursor_format_str[CURSOR_FORMAT_LENGTH];
  gchar             length_format_str[CURSOR_FORMAT_LENGTH];

  GtkWidget        *cursor_frame;
  GtkWidget        *cursor_label;
  GtkWidget        *unit_combo;
  GtkWidget        *scale_combo;

  GtkWidget        *progressbar;
  GtkWidget        *cancel_button;
  gboolean          progress_active;
};
</STRUCT>
<STRUCT>
<NAME>GimpStatusbarClass</NAME>
struct _GimpStatusbarClass
{
  GtkHBoxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_statusbar_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDisplayShell    *shell
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_push</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar,const gchar         *context,const gchar         *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_push_coords</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar,const gchar         *context,const gchar         *title,gdouble              x,const gchar         *separator,gdouble              y
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_push_length</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar,const gchar         *context,const gchar         *title,GimpOrientationType  axis,gdouble              value
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_replace</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar,const gchar         *context,const gchar         *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_pop</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar,const gchar         *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_set_cursor</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar,gdouble              x,gdouble              y
</FUNCTION>
<FUNCTION>
<NAME>gimp_statusbar_clear_cursor</NAME>
<RETURNS>void        </RETURNS>
GimpStatusbar       *statusbar
</FUNCTION>
<FUNCTION>
<NAME>file_open_image</NAME>
<RETURNS>GimpImage *</RETURNS>
Gimp                *gimp,GimpContext         *context,GimpProgress        *progress,const gchar         *uri,const gchar         *entered_filename,GimpPlugInProcedure *file_proc,GimpRunMode          run_mode,GimpPDBStatusType   *status,const gchar        **mime_type,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>file_open_thumbnail</NAME>
<RETURNS>GimpImage *</RETURNS>
Gimp                *gimp,GimpContext         *context,GimpProgress        *progress,const gchar         *uri,gint                 size,const gchar        **mime_type,gint                *image_width,gint                *image_height
</FUNCTION>
<FUNCTION>
<NAME>file_open_with_display</NAME>
<RETURNS>GimpImage *</RETURNS>
Gimp                *gimp,GimpContext         *context,GimpProgress        *progress,const gchar         *uri,GimpPDBStatusType   *status,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>file_open_with_proc_and_display</NAME>
<RETURNS>GimpImage *</RETURNS>
Gimp                *gimp,GimpContext         *context,GimpProgress        *progress,const gchar         *uri,const gchar         *entered_filename,GimpPlugInProcedure *file_proc,GimpPDBStatusType   *status,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>file_open_layer</NAME>
<RETURNS>GimpLayer *</RETURNS>
Gimp                *gimp,GimpContext         *context,GimpProgress        *progress,GimpImage           *dest_image,const gchar         *uri,GimpRunMode          run_mode,GimpPlugInProcedure *file_proc,GimpPDBStatusType   *status,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>file_save</NAME>
<RETURNS>GimpPDBStatusType   </RETURNS>
GimpImage            *image,GimpContext          *context,GimpProgress         *progress,const gchar          *uri,GimpPlugInProcedure  *file_proc,GimpRunMode           run_mode,gboolean              save_a_copy,GError              **error
</FUNCTION>
<FUNCTION>
<NAME>file_utils_filename_to_uri</NAME>
<RETURNS>gchar               *</RETURNS>
GSList        *procs,const gchar   *filename,GError       **error
</FUNCTION>
<FUNCTION>
<NAME>file_utils_filename_from_uri</NAME>
<RETURNS>gchar               *</RETURNS>
const gchar   *uri
</FUNCTION>
<FUNCTION>
<NAME>file_utils_uri_to_utf8_filename</NAME>
<RETURNS>gchar               *</RETURNS>
const gchar   *uri
</FUNCTION>
<FUNCTION>
<NAME>file_utils_uri_display_basename</NAME>
<RETURNS>gchar               *</RETURNS>
const gchar   *uri
</FUNCTION>
<FUNCTION>
<NAME>file_utils_uri_display_name</NAME>
<RETURNS>gchar               *</RETURNS>
const gchar   *uri
</FUNCTION>
<FUNCTION>
<NAME>file_utils_find_proc</NAME>
<RETURNS>GimpPlugInProcedure *</RETURNS>
GSList        *procs,const gchar   *filename
</FUNCTION>
<FUNCTION>
<NAME>file_utils_find_proc_by_extension</NAME>
<RETURNS>GimpPlugInProcedure *</RETURNS>
GSList        *procs,const gchar   *uri
</FUNCTION>
<FUNCTION>
<NAME>file_utils_load_thumbnail</NAME>
<RETURNS>GdkPixbuf           *</RETURNS>
const gchar   *filename
</FUNCTION>
<FUNCTION>
<NAME>file_utils_save_thumbnail</NAME>
<RETURNS>gboolean              </RETURNS>
GimpImage     *image,const gchar   *filename
</FUNCTION>
<STRUCT>
<NAME>GimpRecentItem</NAME>
</STRUCT>
<FUNCTION>
<NAME>gimp_recent_item_new</NAME>
<RETURNS>GimpRecentItem *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_ref</NAME>
<RETURNS>GimpRecentItem *</RETURNS>
GimpRecentItem       *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_unref</NAME>
<RETURNS>GimpRecentItem *</RETURNS>
GimpRecentItem       *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_new_from_uri</NAME>
<RETURNS>GimpRecentItem *</RETURNS>
const gchar          *uri
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_set_uri</NAME>
<RETURNS>gboolean         </RETURNS>
GimpRecentItem       *item,const gchar          *uri
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_get_uri</NAME>
<RETURNS>const gchar    *</RETURNS>
const GimpRecentItem *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_get_uri_utf8</NAME>
<RETURNS>gchar          *</RETURNS>
const GimpRecentItem *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_set_mime_type</NAME>
<RETURNS>void             </RETURNS>
GimpRecentItem       *item,const gchar          *mime
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_get_mime_type</NAME>
<RETURNS>const gchar    *</RETURNS>
const GimpRecentItem *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_set_timestamp</NAME>
<RETURNS>void             </RETURNS>
GimpRecentItem       *item,time_t                timestamp
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_get_timestamp</NAME>
<RETURNS>time_t           </RETURNS>
const GimpRecentItem *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_get_groups</NAME>
<RETURNS>const GList    *</RETURNS>
const GimpRecentItem *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_in_group</NAME>
<RETURNS>gboolean         </RETURNS>
const GimpRecentItem *item,const gchar          *group_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_add_group</NAME>
<RETURNS>void             </RETURNS>
GimpRecentItem       *item,const gchar          *group_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_remove_group</NAME>
<RETURNS>void             </RETURNS>
GimpRecentItem       *item,const gchar          *group_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_set_private</NAME>
<RETURNS>void             </RETURNS>
GimpRecentItem       *item,gboolean              priv
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_item_get_private</NAME>
<RETURNS>gboolean         </RETURNS>
const GimpRecentItem *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_recent_list_add_uri</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *uri,const gchar *mime_type
</FUNCTION>
<MACRO>
<NAME>COLOR_HISTORY_SIZE</NAME>
#define COLOR_HISTORY_SIZE 12
</MACRO>
<FUNCTION>
<NAME>color_history_save</NAME>
<RETURNS>void   </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>color_history_restore</NAME>
<RETURNS>void   </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>color_history_add</NAME>
<RETURNS>gint   </RETURNS>
const GimpRGB    *rgb
</FUNCTION>
<FUNCTION>
<NAME>color_history_set</NAME>
<RETURNS>void   </RETURNS>
gint              index,const GimpRGB    *rgb
</FUNCTION>
<FUNCTION>
<NAME>color_history_get</NAME>
<RETURNS>void   </RETURNS>
gint              index,GimpRGB          *rgb
</FUNCTION>
<FUNCTION>
<NAME>gui_vtable_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gui_libs_init</NAME>
<RETURNS>void               </RETURNS>
GOptionContext *context
</FUNCTION>
<FUNCTION>
<NAME>gui_abort</NAME>
<RETURNS>void               </RETURNS>
const gchar    *abort_message
</FUNCTION>
<FUNCTION>
<NAME>gui_init</NAME>
<RETURNS>GimpInitStatusFunc </RETURNS>
Gimp           *gimp,gboolean        no_spash
</FUNCTION>
<FUNCTION>
<NAME>gui_post_init</NAME>
<RETURNS>void               </RETURNS>
Gimp           *gimp
</FUNCTION>
<FUNCTION>
<NAME>session_init</NAME>
<RETURNS>void       </RETURNS>
Gimp     *gimp
</FUNCTION>
<FUNCTION>
<NAME>session_exit</NAME>
<RETURNS>void       </RETURNS>
Gimp     *gimp
</FUNCTION>
<FUNCTION>
<NAME>session_restore</NAME>
<RETURNS>void       </RETURNS>
Gimp     *gimp
</FUNCTION>
<FUNCTION>
<NAME>session_save</NAME>
<RETURNS>void       </RETURNS>
Gimp     *gimp,gboolean  always_save
</FUNCTION>
<FUNCTION>
<NAME>session_clear</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp     *gimp,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>splash_create</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>splash_destroy</NAME>
<RETURNS>void   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>splash_update</NAME>
<RETURNS>void   </RETURNS>
const gchar *label1,const gchar *label2,gdouble      percentage
</FUNCTION>
<FUNCTION>
<NAME>themes_init</NAME>
<RETURNS>void           </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>themes_exit</NAME>
<RETURNS>void           </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>themes_list_themes</NAME>
<RETURNS>gchar       **</RETURNS>
Gimp        *gimp,gint        *n_themes
</FUNCTION>
<FUNCTION>
<NAME>themes_get_theme_dir</NAME>
<RETURNS>const gchar  *</RETURNS>
Gimp        *gimp,const gchar *theme_name
</FUNCTION>
<FUNCTION>
<NAME>themes_get_theme_file</NAME>
<RETURNS>gchar        *</RETURNS>
Gimp        *gimp,const gchar *first_component,...
</FUNCTION>
<FUNCTION>
<NAME>themes_apply_theme</NAME>
<RETURNS>void           </RETURNS>
Gimp        *gimp,const gchar *theme_name
</FUNCTION>
<FUNCTION>
<NAME>dockable_menu_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager *manager,const gchar   *ui_path
</FUNCTION>
<FUNCTION>
<NAME>file_menu_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager *manager,const gchar   *ui_path
</FUNCTION>
<FUNCTION>
<NAME>image_menu_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager *manager,const gchar   *ui_path
</FUNCTION>
<VARIABLE>
<NAME>global_menu_factory</NAME>
extern GimpMenuFactory *global_menu_factory;
</VARIABLE>
<FUNCTION>
<NAME>menus_init</NAME>
<RETURNS>void       </RETURNS>
Gimp               *gimp,GimpActionFactory  *action_factory
</FUNCTION>
<FUNCTION>
<NAME>menus_exit</NAME>
<RETURNS>void       </RETURNS>
Gimp               *gimp
</FUNCTION>
<FUNCTION>
<NAME>menus_restore</NAME>
<RETURNS>void       </RETURNS>
Gimp               *gimp
</FUNCTION>
<FUNCTION>
<NAME>menus_save</NAME>
<RETURNS>void       </RETURNS>
Gimp               *gimp,gboolean            always_save
</FUNCTION>
<FUNCTION>
<NAME>menus_clear</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp               *gimp,GError            **error
</FUNCTION>
<FUNCTION>
<NAME>plug_in_menus_init</NAME>
<RETURNS>void   </RETURNS>
Gimp                *gimp,GSList              *plug_in_defs,const gchar         *std_plugins_domain
</FUNCTION>
<FUNCTION>
<NAME>plug_in_menus_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager       *manager,const gchar         *ui_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_menus_add_proc</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager       *manager,const gchar         *ui_path,GimpPlugInProcedure *proc,const gchar         *menu_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_menus_remove_proc</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager       *manager,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>tool_options_menu_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager *manager,const gchar   *ui_path
</FUNCTION>
<FUNCTION>
<NAME>toolbox_menu_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager *manager,const gchar   *ui_path
</FUNCTION>
<FUNCTION>
<NAME>window_menu_setup</NAME>
<RETURNS>void   </RETURNS>
GimpUIManager *manager,const gchar   *group_name,const gchar   *ui_path
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_AIRBRUSH</NAME>
#define GIMP_TYPE_AIRBRUSH            (gimp_airbrush_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH</NAME>
#define GIMP_AIRBRUSH(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_AIRBRUSH, GimpAirbrush))
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_CLASS</NAME>
#define GIMP_AIRBRUSH_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_AIRBRUSH, GimpAirbrushClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_AIRBRUSH</NAME>
#define GIMP_IS_AIRBRUSH(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_AIRBRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_IS_AIRBRUSH_CLASS</NAME>
#define GIMP_IS_AIRBRUSH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_AIRBRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_GET_CLASS</NAME>
#define GIMP_AIRBRUSH_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_AIRBRUSH, GimpAirbrushClass))
</MACRO>
<STRUCT>
<NAME>GimpAirbrush</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAirbrushClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAirbrush</NAME>
struct _GimpAirbrush
{
  GimpPaintbrush    parent_instance;

  guint             timeout_id;
  GimpDrawable     *drawable;
  GimpPaintOptions *paint_options;
};
</STRUCT>
<STRUCT>
<NAME>GimpAirbrushClass</NAME>
struct _GimpAirbrushClass
{
  GimpPaintbrushClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_airbrush_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_airbrush_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_AIRBRUSH_OPTIONS</NAME>
#define GIMP_TYPE_AIRBRUSH_OPTIONS            (gimp_airbrush_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_OPTIONS</NAME>
#define GIMP_AIRBRUSH_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_AIRBRUSH_OPTIONS, GimpAirbrushOptions))
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_OPTIONS_CLASS</NAME>
#define GIMP_AIRBRUSH_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_AIRBRUSH_OPTIONS, GimpAirbrushOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_AIRBRUSH_OPTIONS</NAME>
#define GIMP_IS_AIRBRUSH_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_AIRBRUSH_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_AIRBRUSH_OPTIONS_CLASS</NAME>
#define GIMP_IS_AIRBRUSH_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_AIRBRUSH_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_OPTIONS_GET_CLASS</NAME>
#define GIMP_AIRBRUSH_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_AIRBRUSH_OPTIONS, GimpAirbrushOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpAirbrushOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpAirbrushOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpAirbrushOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpAirbrushOptions</NAME>
struct _GimpAirbrushOptions
{
  GimpPaintOptions  parent_instance;

  gdouble           rate;
  gdouble           pressure;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_airbrush_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>KERNEL_WIDTH</NAME>
#define KERNEL_WIDTH     3
</MACRO>
<MACRO>
<NAME>KERNEL_HEIGHT</NAME>
#define KERNEL_HEIGHT    3
</MACRO>
<MACRO>
<NAME>KERNEL_SUBSAMPLE</NAME>
#define KERNEL_SUBSAMPLE 4
</MACRO>
<MACRO>
<NAME>KERNEL_SUM</NAME>
#define KERNEL_SUM       256
</MACRO>
<MACRO>
<NAME>BRUSH_CORE_SUBSAMPLE</NAME>
#define BRUSH_CORE_SUBSAMPLE        4
</MACRO>
<MACRO>
<NAME>BRUSH_CORE_SOLID_SUBSAMPLE</NAME>
#define BRUSH_CORE_SOLID_SUBSAMPLE  2
</MACRO>
<MACRO>
<NAME>PRESSURE_SCALE</NAME>
#define PRESSURE_SCALE              1.5
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_CORE</NAME>
#define GIMP_TYPE_BRUSH_CORE            (gimp_brush_core_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_CORE</NAME>
#define GIMP_BRUSH_CORE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH_CORE, GimpBrushCore))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_CORE_CLASS</NAME>
#define GIMP_BRUSH_CORE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH_CORE, GimpBrushCoreClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_CORE</NAME>
#define GIMP_IS_BRUSH_CORE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH_CORE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_CORE_CLASS</NAME>
#define GIMP_IS_BRUSH_CORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH_CORE))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_CORE_GET_CLASS</NAME>
#define GIMP_BRUSH_CORE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH_CORE, GimpBrushCoreClass))
</MACRO>
<STRUCT>
<NAME>GimpBrushCoreClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushCore</NAME>
struct _GimpBrushCore
{
  GimpPaintCore  parent_instance;

  GimpBrush     *main_brush;
  GimpBrush     *brush;
  gdouble        spacing;
  gdouble        scale;

  /*  brush buffers  */
  MaskBuf       *pressure_brush;

  MaskBuf       *solid_brushes[BRUSH_CORE_SOLID_SUBSAMPLE][BRUSH_CORE_SOLID_SUBSAMPLE];
  MaskBuf       *last_solid_brush;
  gboolean       solid_cache_invalid;

  MaskBuf       *scale_brush;
  MaskBuf       *last_scale_brush;
  gint           last_scale_width;
  gint           last_scale_height;

  MaskBuf       *scale_pixmap;
  MaskBuf       *last_scale_pixmap;
  gint           last_scale_pixmap_width;
  gint           last_scale_pixmap_height;

  MaskBuf       *kernel_brushes[BRUSH_CORE_SUBSAMPLE + 1][BRUSH_CORE_SUBSAMPLE + 1];

  MaskBuf       *last_brush_mask;
  gboolean       cache_invalid;

  gdouble        jitter;

  /*  don't use these...  */
  BoundSeg      *brush_bound_segs;
  gint           n_brush_bound_segs;
  gint           brush_bound_width;
  gint           brush_bound_height;
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushCoreClass</NAME>
struct _GimpBrushCoreClass
{
  GimpPaintCoreClass  parent_class;

  /*  Set for tools that don't mind if the brush changes while painting  */
  gboolean            handles_changing_brush;

  /*  Scale the brush mask depending on pressure  */
  gboolean            use_scale;

  void (* set_brush) (GimpBrushCore *core,
                      GimpBrush     *brush);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_core_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_core_set_brush</NAME>
<RETURNS>void    </RETURNS>
GimpBrushCore            *core,GimpBrush                *brush
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_core_paste_canvas</NAME>
<RETURNS>void    </RETURNS>
GimpBrushCore            *core,GimpDrawable             *drawable,gdouble                   brush_opacity,gdouble                   image_opacity,GimpLayerModeEffects      paint_mode,GimpBrushApplicationMode  brush_hardness,GimpPaintApplicationMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_core_replace_canvas</NAME>
<RETURNS>void    </RETURNS>
GimpBrushCore            *core,GimpDrawable                 *drawable,gdouble                   brush_opacity,gdouble                   image_opacity,GimpBrushApplicationMode  brush_hardness,GimpPaintApplicationMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_core_color_area_with_pixmap</NAME>
<RETURNS>void  </RETURNS>
GimpBrushCore            *core,GimpImage                *dest,GimpDrawable             *drawable,TempBuf                  *area,gdouble                   scale,GimpBrushApplicationMode  mode
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CLONE</NAME>
#define GIMP_TYPE_CLONE            (gimp_clone_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CLONE</NAME>
#define GIMP_CLONE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CLONE, GimpClone))
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_CLASS</NAME>
#define GIMP_CLONE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CLONE, GimpCloneClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CLONE</NAME>
#define GIMP_IS_CLONE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CLONE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CLONE_CLASS</NAME>
#define GIMP_IS_CLONE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CLONE))
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_GET_CLASS</NAME>
#define GIMP_CLONE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CLONE, GimpCloneClass))
</MACRO>
<STRUCT>
<NAME>GimpClone</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCloneClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpClone</NAME>
struct _GimpClone
{
  GimpBrushCore parent_instance;

  gboolean      set_source;

  GimpDrawable *src_drawable;
  gdouble       src_x;
  gdouble       src_y;

  gdouble       orig_src_x;
  gdouble       orig_src_y;

  gdouble       offset_x;
  gdouble       offset_y;
  gboolean      first_stroke;
};
</STRUCT>
<STRUCT>
<NAME>GimpCloneClass</NAME>
struct _GimpCloneClass
{
  GimpBrushCoreClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_clone_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_clone_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CLONE_OPTIONS</NAME>
#define GIMP_TYPE_CLONE_OPTIONS            (gimp_clone_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_OPTIONS</NAME>
#define GIMP_CLONE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CLONE_OPTIONS, GimpCloneOptions))
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_OPTIONS_CLASS</NAME>
#define GIMP_CLONE_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CLONE_OPTIONS, GimpCloneOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CLONE_OPTIONS</NAME>
#define GIMP_IS_CLONE_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CLONE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CLONE_OPTIONS_CLASS</NAME>
#define GIMP_IS_CLONE_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CLONE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_OPTIONS_GET_CLASS</NAME>
#define GIMP_CLONE_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CLONE_OPTIONS, GimpCloneOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpCloneOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpCloneOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpCloneOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpCloneOptions</NAME>
struct _GimpCloneOptions
{
  GimpPaintOptions    paint_options;

  GimpCloneType       clone_type;
  GimpCloneAlignMode  align_mode;
  gboolean            sample_merged;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_clone_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONVOLVE</NAME>
#define GIMP_TYPE_CONVOLVE            (gimp_convolve_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE</NAME>
#define GIMP_CONVOLVE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONVOLVE, GimpConvolve))
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_CLASS</NAME>
#define GIMP_CONVOLVE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONVOLVE, GimpConvolveClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONVOLVE</NAME>
#define GIMP_IS_CONVOLVE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONVOLVE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONVOLVE_CLASS</NAME>
#define GIMP_IS_CONVOLVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONVOLVE))
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_GET_CLASS</NAME>
#define GIMP_CONVOLVE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONVOLVE, GimpConvolveClass))
</MACRO>
<STRUCT>
<NAME>GimpConvolve</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpConvolveClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpConvolve</NAME>
struct _GimpConvolve
{
  GimpBrushCore parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpConvolveClass</NAME>
struct _GimpConvolveClass
{
  GimpBrushCoreClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_convolve_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_convolve_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONVOLVE_OPTIONS</NAME>
#define GIMP_TYPE_CONVOLVE_OPTIONS            (gimp_convolve_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_OPTIONS</NAME>
#define GIMP_CONVOLVE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONVOLVE_OPTIONS, GimpConvolveOptions))
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_OPTIONS_CLASS</NAME>
#define GIMP_CONVOLVE_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONVOLVE_OPTIONS, GimpConvolveOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONVOLVE_OPTIONS</NAME>
#define GIMP_IS_CONVOLVE_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONVOLVE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONVOLVE_OPTIONS_CLASS</NAME>
#define GIMP_IS_CONVOLVE_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONVOLVE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_OPTIONS_GET_CLASS</NAME>
#define GIMP_CONVOLVE_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONVOLVE_OPTIONS, GimpConvolveOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpConvolveOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpConvolveOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpConvolveOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpConvolveOptions</NAME>
struct _GimpConvolveOptions
{
  GimpPaintOptions  paint_options;

  GimpConvolveType  type;
  gdouble           rate;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_convolve_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DODGE_BURN</NAME>
#define GIMP_TYPE_DODGE_BURN            (gimp_dodge_burn_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN</NAME>
#define GIMP_DODGE_BURN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DODGE_BURN, GimpDodgeBurn))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DODGE_BURN</NAME>
#define GIMP_IS_DODGE_BURN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DODGE_BURN))
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN_CLASS</NAME>
#define GIMP_DODGE_BURN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DODGEBURN, GimpDodgeBurnClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DODGE_BURN_CLASS</NAME>
#define GIMP_IS_DODGE_BURN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DODGE_BURN))
</MACRO>
<STRUCT>
<NAME>GimpDodgeBurn</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDodgeBurnClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDodgeBurn</NAME>
struct _GimpDodgeBurn
{
  GimpBrushCore  parent_instance;

  GimpLut       *lut;
};
</STRUCT>
<STRUCT>
<NAME>GimpDodgeBurnClass</NAME>
struct _GimpDodgeBurnClass
{
  GimpBrushCoreClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dodge_burn_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_dodge_burn_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DODGE_BURN_OPTIONS</NAME>
#define GIMP_TYPE_DODGE_BURN_OPTIONS            (gimp_dodge_burn_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN_OPTIONS</NAME>
#define GIMP_DODGE_BURN_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DODGE_BURN_OPTIONS, GimpDodgeBurnOptions))
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN_OPTIONS_CLASS</NAME>
#define GIMP_DODGE_BURN_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DODGE_BURN_OPTIONS, GimpDodgeBurnOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DODGE_BURN_OPTIONS</NAME>
#define GIMP_IS_DODGE_BURN_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DODGE_BURN_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DODGE_BURN_OPTIONS_CLASS</NAME>
#define GIMP_IS_DODGE_BURN_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DODGE_BURN_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN_OPTIONS_GET_CLASS</NAME>
#define GIMP_DODGE_BURN_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DODGE_BURN_OPTIONS, GimpDodgeBurnOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpDodgeBurnOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpDodgeBurnOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpDodgeBurnOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpDodgeBurnOptions</NAME>
struct _GimpDodgeBurnOptions
{
  GimpPaintOptions   paint_options;

  GimpDodgeBurnType  type;
  GimpTransferMode   mode;     /*highlights, midtones, shadows*/
  gdouble            exposure;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dodge_burn_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ERASER</NAME>
#define GIMP_TYPE_ERASER            (gimp_eraser_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ERASER</NAME>
#define GIMP_ERASER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ERASER, GimpEraser))
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_CLASS</NAME>
#define GIMP_ERASER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ERASER, GimpEraserClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERASER</NAME>
#define GIMP_IS_ERASER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ERASER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERASER_CLASS</NAME>
#define GIMP_IS_ERASER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ERASER))
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_GET_CLASS</NAME>
#define GIMP_ERASER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ERASER, GimpEraserClass))
</MACRO>
<STRUCT>
<NAME>GimpEraser</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEraserClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEraser</NAME>
struct _GimpEraser
{
  GimpBrushCore parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpEraserClass</NAME>
struct _GimpEraserClass
{
  GimpBrushCoreClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_eraser_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_eraser_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ERASER_OPTIONS</NAME>
#define GIMP_TYPE_ERASER_OPTIONS            (gimp_eraser_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_OPTIONS</NAME>
#define GIMP_ERASER_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ERASER_OPTIONS, GimpEraserOptions))
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_OPTIONS_CLASS</NAME>
#define GIMP_ERASER_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ERASER_OPTIONS, GimpEraserOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERASER_OPTIONS</NAME>
#define GIMP_IS_ERASER_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ERASER_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERASER_OPTIONS_CLASS</NAME>
#define GIMP_IS_ERASER_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ERASER_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_OPTIONS_GET_CLASS</NAME>
#define GIMP_ERASER_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ERASER_OPTIONS, GimpEraserOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpEraserOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpEraserOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpEraserOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpEraserOptions</NAME>
struct _GimpEraserOptions
{
  GimpPaintOptions  paint_options;

  gboolean          anti_erase;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_eraser_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>BlobPoint</NAME>
</STRUCT>
<STRUCT>
<NAME>BlobSpan</NAME>
</STRUCT>
<STRUCT>
<NAME>Blob</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BlobFunc</NAME>
<RETURNS>Blob *</RETURNS>
gdouble xc,
                             gdouble yc,
                             gdouble xp,
                             gdouble yp,
                             gdouble xq,
                             gdouble yq
</USER_FUNCTION>
<STRUCT>
<NAME>BlobPoint</NAME>
struct _BlobPoint
{
  gint x;
  gint y;
};
</STRUCT>
<STRUCT>
<NAME>BlobSpan</NAME>
struct _BlobSpan
{
  gint left;
  gint right;
};
</STRUCT>
<STRUCT>
<NAME>Blob</NAME>
struct _Blob
{
  gint     y;
  gint     height;
  BlobSpan data[1];
};
</STRUCT>
<FUNCTION>
<NAME>blob_polygon</NAME>
<RETURNS>Blob *</RETURNS>
BlobPoint *points,gint       npoints
</FUNCTION>
<FUNCTION>
<NAME>blob_square</NAME>
<RETURNS>Blob *</RETURNS>
gdouble    xc,gdouble    yc,gdouble    xp,gdouble    yp,gdouble    xq,gdouble    yq
</FUNCTION>
<FUNCTION>
<NAME>blob_diamond</NAME>
<RETURNS>Blob *</RETURNS>
gdouble    xc,gdouble    yc,gdouble    xp,gdouble    yp,gdouble    xq,gdouble    yq
</FUNCTION>
<FUNCTION>
<NAME>blob_ellipse</NAME>
<RETURNS>Blob *</RETURNS>
gdouble    xc,gdouble    yc,gdouble    xp,gdouble    yp,gdouble    xq,gdouble    yq
</FUNCTION>
<FUNCTION>
<NAME>blob_bounds</NAME>
<RETURNS>void   </RETURNS>
Blob      *b,gint      *x,gint      *y,gint      *width,gint      *height
</FUNCTION>
<FUNCTION>
<NAME>blob_convex_union</NAME>
<RETURNS>Blob *</RETURNS>
Blob      *b1,Blob      *b2
</FUNCTION>
<FUNCTION>
<NAME>blob_duplicate</NAME>
<RETURNS>Blob *</RETURNS>
Blob      *b
</FUNCTION>
<FUNCTION>
<NAME>gimp_ink_push_undo</NAME>
<RETURNS>gboolean   </RETURNS>
GimpPaintCore *core,GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<MACRO>
<NAME>DIST_SMOOTHER_BUFFER</NAME>
#define DIST_SMOOTHER_BUFFER 10
</MACRO>
<MACRO>
<NAME>TIME_SMOOTHER_BUFFER</NAME>
#define TIME_SMOOTHER_BUFFER 10
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_INK</NAME>
#define GIMP_TYPE_INK            (gimp_ink_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_INK</NAME>
#define GIMP_INK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_INK, GimpInk))
</MACRO>
<MACRO>
<NAME>GIMP_INK_CLASS</NAME>
#define GIMP_INK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_INK, GimpInkClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INK</NAME>
#define GIMP_IS_INK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_INK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INK_CLASS</NAME>
#define GIMP_IS_INK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_INK))
</MACRO>
<MACRO>
<NAME>GIMP_INK_GET_CLASS</NAME>
#define GIMP_INK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_INK, GimpInkClass))
</MACRO>
<STRUCT>
<NAME>GimpInk</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpInkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpInk</NAME>
struct _GimpInk
{
  GimpPaintCore  parent_instance;

  Blob          *start_blob;   /*  starting blob (for undo)       */

  Blob          *cur_blob;     /*  current blob                   */
  Blob          *last_blob;    /*  blob for last cursor position  */

  /* circular distance history buffer */
  gdouble        dt_buffer[DIST_SMOOTHER_BUFFER];
  gint           dt_index;

  /* circular timing history buffer */
  guint32        ts_buffer[TIME_SMOOTHER_BUFFER];
  gint           ts_index;

  guint32        last_time;     /*  previous time of a motion event  */

  gboolean       init_velocity;
};
</STRUCT>
<STRUCT>
<NAME>GimpInkClass</NAME>
struct _GimpInkClass
{
  GimpPaintCoreClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_ink_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_ink_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INK_OPTIONS</NAME>
#define GIMP_TYPE_INK_OPTIONS            (gimp_ink_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_INK_OPTIONS</NAME>
#define GIMP_INK_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_INK_OPTIONS, GimpInkOptions))
</MACRO>
<MACRO>
<NAME>GIMP_INK_OPTIONS_CLASS</NAME>
#define GIMP_INK_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_INK_OPTIONS, GimpInkOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INK_OPTIONS</NAME>
#define GIMP_IS_INK_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_INK_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INK_OPTIONS_CLASS</NAME>
#define GIMP_IS_INK_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_INK_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_INK_OPTIONS_GET_CLASS</NAME>
#define GIMP_INK_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_INK_OPTIONS, GimpInkOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpInkOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpInkOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpInkOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpInkOptions</NAME>
struct _GimpInkOptions
{
  GimpPaintOptions  paint_options;

  gdouble           size;
  gdouble           tilt_angle;

  gdouble           size_sensitivity;
  gdouble           vel_sensitivity;
  gdouble           tilt_sensitivity;

  GimpInkBlobType   blob_type;
  gdouble           blob_aspect;
  gdouble           blob_angle;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_ink_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PAINTBRUSH</NAME>
#define GIMP_TYPE_PAINTBRUSH            (gimp_paintbrush_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PAINTBRUSH</NAME>
#define GIMP_PAINTBRUSH(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINTBRUSH, GimpPaintbrush))
</MACRO>
<MACRO>
<NAME>GIMP_PAINTBRUSH_CLASS</NAME>
#define GIMP_PAINTBRUSH_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PAINTBRUSH, GimpPaintbrushClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINTBRUSH</NAME>
#define GIMP_IS_PAINTBRUSH(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PAINTBRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINTBRUSH_CLASS</NAME>
#define GIMP_IS_PAINTBRUSH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PAINTBRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_PAINTBRUSH_GET_CLASS</NAME>
#define GIMP_PAINTBRUSH_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PAINTBRUSH, GimpPaintbrushClass))
</MACRO>
<STRUCT>
<NAME>GimpPaintbrush</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintbrushClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintbrush</NAME>
struct _GimpPaintbrush
{
  GimpBrushCore parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaintbrushClass</NAME>
struct _GimpPaintbrushClass
{
  GimpBrushCoreClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_paintbrush_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_paintbrush_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_stroke</NAME>
<RETURNS>gboolean   </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *paint_options,GimpCoords       *strokes,gint              n_strokes
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_stroke_boundary</NAME>
<RETURNS>gboolean   </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *paint_options,const BoundSeg   *bound_segs,gint              n_bound_segs,gint              offset_x,gint              offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_stroke_vectors</NAME>
<RETURNS>gboolean   </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *paint_options,GimpVectors      *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_real_push_undo</NAME>
<RETURNS>gboolean   </RETURNS>
GimpPaintCore *core,GimpImage     *image,const gchar   *undo_desc
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PAINT_CORE</NAME>
#define GIMP_TYPE_PAINT_CORE            (gimp_paint_core_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_CORE</NAME>
#define GIMP_PAINT_CORE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINT_CORE, GimpPaintCore))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_CORE_CLASS</NAME>
#define GIMP_PAINT_CORE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PAINT_CORE, GimpPaintCoreClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_CORE</NAME>
#define GIMP_IS_PAINT_CORE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PAINT_CORE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_CORE_CLASS</NAME>
#define GIMP_IS_PAINT_CORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PAINT_CORE))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_CORE_GET_CLASS</NAME>
#define GIMP_PAINT_CORE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PAINT_CORE, GimpPaintCoreClass))
</MACRO>
<STRUCT>
<NAME>GimpPaintCoreClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintCore</NAME>
struct _GimpPaintCore
{
  GimpObject   parent_instance;

  gint         ID;               /*  unique instance ID                  */

  GimpCoords   start_coords;     /*  starting coords (for undo only)     */

  GimpCoords   cur_coords;       /*  current coords                      */
  GimpCoords   last_coords;      /*  last coords                         */

  GimpVector2  last_paint;       /*  last point that was painted         */

  gdouble      distance;         /*  distance traveled by brush          */
  gdouble      pixel_dist;       /*  distance in pixels                  */

  gint         x1, y1;           /*  undo extents in image coords        */
  gint         x2, y2;           /*  undo extents in image coords        */

  gboolean     use_pressure;     /*  look at coords->pressure            */
  gboolean     use_saved_proj;   /*  keep the unmodified proj around     */

  TileManager *undo_tiles;       /*  tiles which have been modified      */
  TileManager *saved_proj_tiles; /*  proj tiles which have been modified */
  TileManager *canvas_tiles;     /*  the buffer to paint the mask to     */

  TempBuf     *orig_buf;         /*  the unmodified drawable pixels      */
  TempBuf     *orig_proj_buf;    /*  the unmodified projection pixels    */
  TempBuf     *canvas_buf;       /*  the buffer to paint pixels to       */
};
</STRUCT>
<STRUCT>
<NAME>GimpPaintCoreClass</NAME>
struct _GimpPaintCoreClass
{
  GimpObjectClass  parent_class;

  /*  virtual functions  */
  gboolean  (* start)          (GimpPaintCore    *core,
                                GimpDrawable     *drawable,
                                GimpPaintOptions *paint_options,
                                GimpCoords       *coords);

  gboolean  (* pre_paint)      (GimpPaintCore    *core,
                                GimpDrawable     *drawable,
                                GimpPaintOptions *paint_options,
                                GimpPaintState    paint_state,
                                guint32           time);
  void      (* paint)          (GimpPaintCore    *core,
                                GimpDrawable     *drawable,
                                GimpPaintOptions *paint_options,
                                GimpPaintState    paint_state,
                                guint32           time);
  void      (* post_paint)     (GimpPaintCore    *core,
                                GimpDrawable     *drawable,
                                GimpPaintOptions *paint_options,
                                GimpPaintState    paint_state,
                                guint32           time);

  void      (* interpolate)    (GimpPaintCore    *core,
                                GimpDrawable     *drawable,
                                GimpPaintOptions *paint_options,
                                guint32           time);

  TempBuf * (* get_paint_area) (GimpPaintCore    *core,
                                GimpDrawable     *drawable,
                                GimpPaintOptions *paint_options);

  gboolean  (* push_undo)      (GimpPaintCore    *core,
                                GimpImage        *image,
                                const gchar      *undo_desc);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_paint_core_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_paint</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *paint_options,GimpPaintState    state,guint32           time
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_start</NAME>
<RETURNS>gboolean  </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *paint_options,GimpCoords       *coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_finish</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_cancel</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_cleanup</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_interpolate</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *paint_options,guint32           time
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_get_paint_area</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,GimpPaintOptions *options
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_get_orig_image</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,gint              x1,gint              y1,gint              x2,gint              y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_get_orig_proj</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpPaintCore    *core,GimpPickable     *pickable,gint              x1,gint              y1,gint              x2,gint              y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_paste</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore            *core,PixelRegion              *paint_maskPR,GimpDrawable             *drawable,gdouble                       paint_opacity,gdouble                       image_opacity,GimpLayerModeEffects      paint_mode,GimpPaintApplicationMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_replace</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore            *core,PixelRegion              *paint_maskPR,GimpDrawable             *drawable,gdouble                       paint_opacity,gdouble                   image_opacity,GimpPaintApplicationMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_validate_undo_tiles</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,GimpDrawable     *drawable,gint              x,gint              y,gint              w,gint              h
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_validate_saved_proj_tiles</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,GimpPickable     *pickable,gint              x,gint              y,gint              w,gint              h
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_core_validate_canvas_tiles</NAME>
<RETURNS>void      </RETURNS>
GimpPaintCore    *core,gint              x,gint              y,gint              w,gint              h
</FUNCTION>
<MACRO>
<NAME>GIMP_PAINT_OPTIONS_CONTEXT_MASK</NAME>
#define GIMP_PAINT_OPTIONS_CONTEXT_MASK GIMP_CONTEXT_FOREGROUND_MASK | \
                                        GIMP_CONTEXT_BACKGROUND_MASK | \
                                        GIMP_CONTEXT_OPACITY_MASK    | \
                                        GIMP_CONTEXT_PAINT_MODE_MASK | \
                                        GIMP_CONTEXT_BRUSH_MASK
</MACRO>
<STRUCT>
<NAME>GimpPressureOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFadeOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradientOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpJitterOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPressureOptions</NAME>
struct _GimpPressureOptions
{
  gboolean  expanded;
  gboolean  opacity;
  gboolean  hardness;
  gboolean  rate;
  gboolean  size;
  gboolean  inverse_size;
  gboolean  color;
};
</STRUCT>
<STRUCT>
<NAME>GimpFadeOptions</NAME>
struct _GimpFadeOptions
{
  gboolean  use_fade;
  gdouble   fade_length;
  GimpUnit  fade_unit;
};
</STRUCT>
<STRUCT>
<NAME>GimpJitterOptions</NAME>
struct _GimpJitterOptions
{
  gboolean  use_jitter;
  gdouble   jitter_amount;
};
</STRUCT>
<STRUCT>
<NAME>GimpGradientOptions</NAME>
struct _GimpGradientOptions
{
  gboolean        use_gradient;
  gboolean        gradient_reverse;
  gdouble         gradient_length;
  GimpUnit        gradient_unit;
  GimpRepeatMode  gradient_repeat;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_PAINT_OPTIONS</NAME>
#define GIMP_TYPE_PAINT_OPTIONS            (gimp_paint_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_OPTIONS</NAME>
#define GIMP_PAINT_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINT_OPTIONS, GimpPaintOptions))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_OPTIONS_CLASS</NAME>
#define GIMP_PAINT_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PAINT_OPTIONS, GimpPaintOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_OPTIONS</NAME>
#define GIMP_IS_PAINT_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PAINT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_OPTIONS_CLASS</NAME>
#define GIMP_IS_PAINT_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PAINT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_OPTIONS_GET_CLASS</NAME>
#define GIMP_PAINT_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PAINT_OPTIONS, GimpPaintOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpPaintOptionsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintOptions</NAME>
struct _GimpPaintOptions
{
  GimpToolOptions           parent_instance;

  GimpPaintInfo            *paint_info;

  GimpPaintApplicationMode  application_mode;
  GimpPaintApplicationMode  application_mode_save;

  gboolean                  hard;

  GimpPressureOptions      *pressure_options;
  GimpFadeOptions          *fade_options;
  GimpGradientOptions      *gradient_options;
  GimpJitterOptions        *jitter_options;

  GimpViewType              brush_view_type;
  GimpViewSize              brush_view_size;
  GimpViewType              pattern_view_type;
  GimpViewSize              pattern_view_size;
  GimpViewType              gradient_view_type;
  GimpViewSize              gradient_view_size;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaintOptionsClass</NAME>
struct _GimpPaintOptionsClass
{
  GimpToolOptionsClass  parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_paint_options_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_options_new</NAME>
<RETURNS>GimpPaintOptions *</RETURNS>
GimpPaintInfo    *paint_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_options_get_fade</NAME>
<RETURNS>gdouble            </RETURNS>
GimpPaintOptions *paint_options,GimpImage        *image,gdouble           pixel_dist
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_options_get_gradient_color</NAME>
<RETURNS>gboolean </RETURNS>
GimpPaintOptions *paint_options,GimpImage        *image,gdouble           pressure,gdouble           pixel_dist,GimpRGB          *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_options_get_jitter</NAME>
<RETURNS>gdouble          </RETURNS>
GimpPaintOptions *paint_options,GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_options_get_brush_mode</NAME>
<RETURNS>GimpBrushApplicationMode</RETURNS>
GimpPaintOptions *paint_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PENCIL</NAME>
#define GIMP_TYPE_PENCIL            (gimp_pencil_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL</NAME>
#define GIMP_PENCIL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PENCIL, GimpPencil))
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_CLASS</NAME>
#define GIMP_PENCIL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PENCIL, GimpPencilClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PENCIL</NAME>
#define GIMP_IS_PENCIL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PENCIL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PENCIL_CLASS</NAME>
#define GIMP_IS_PENCIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PENCIL))
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_GET_CLASS</NAME>
#define GIMP_PENCIL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PENCIL, GimpPencilClass))
</MACRO>
<STRUCT>
<NAME>GimpPencil</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPencilClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPencil</NAME>
struct _GimpPencil
{
  GimpPaintbrush  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPencilClass</NAME>
struct _GimpPencilClass
{
  GimpPaintbrushClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pencil_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_pencil_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PENCIL_OPTIONS</NAME>
#define GIMP_TYPE_PENCIL_OPTIONS            (gimp_pencil_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_OPTIONS</NAME>
#define GIMP_PENCIL_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PENCIL_OPTIONS, GimpPencilOptions))
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_OPTIONS_CLASS</NAME>
#define GIMP_PENCIL_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PENCIL_OPTIONS, GimpPencilOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PENCIL_OPTIONS</NAME>
#define GIMP_IS_PENCIL_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PENCIL_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PENCIL_OPTIONS_CLASS</NAME>
#define GIMP_IS_PENCIL_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PENCIL_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_OPTIONS_GET_CLASS</NAME>
#define GIMP_PENCIL_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PENCIL_OPTIONS, GimpPencilOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpPencilOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpPencilOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpPencilOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpPencilOptions</NAME>
struct _GimpPencilOptions
{
  GimpPaintOptions  parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pencil_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SMUDGE</NAME>
#define GIMP_TYPE_SMUDGE            (gimp_smudge_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE</NAME>
#define GIMP_SMUDGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SMUDGE, GimpSmudge))
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_CLASS</NAME>
#define GIMP_SMUDGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SMUDGE, GimpSmudgeClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SMUDGE</NAME>
#define GIMP_IS_SMUDGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SMUDGE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SMUDGE_CLASS</NAME>
#define GIMP_IS_SMUDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SMUDGE))
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_GET_CLASS</NAME>
#define GIMP_SMUDGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SMUDGE, GimpSmudgeClass))
</MACRO>
<STRUCT>
<NAME>GimpSmudge</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSmudgeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSmudge</NAME>
struct _GimpSmudge
{
  GimpBrushCore  parent_instance;

  gboolean       initialized;
  PixelRegion    accumPR;
  guchar        *accum_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpSmudgeClass</NAME>
struct _GimpSmudgeClass
{
  GimpBrushCoreClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_smudge_register</NAME>
<RETURNS>void    </RETURNS>
Gimp                      *gimp,GimpPaintRegisterCallback  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_smudge_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SMUDGE_OPTIONS</NAME>
#define GIMP_TYPE_SMUDGE_OPTIONS            (gimp_smudge_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_OPTIONS</NAME>
#define GIMP_SMUDGE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SMUDGE_OPTIONS, GimpSmudgeOptions))
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_OPTIONS_CLASS</NAME>
#define GIMP_SMUDGE_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SMUDGE_OPTIONS, GimpSmudgeOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SMUDGE_OPTIONS</NAME>
#define GIMP_IS_SMUDGE_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SMUDGE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SMUDGE_OPTIONS_CLASS</NAME>
#define GIMP_IS_SMUDGE_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SMUDGE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_OPTIONS_GET_CLASS</NAME>
#define GIMP_SMUDGE_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SMUDGE_OPTIONS, GimpSmudgeOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpSmudgeOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpSmudgeOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpSmudgeOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpSmudgeOptions</NAME>
struct _GimpSmudgeOptions
{
  GimpPaintOptions  paint_options;

  gdouble           rate;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_smudge_options_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_APPLICATION_MODE</NAME>
#define GIMP_TYPE_BRUSH_APPLICATION_MODE (gimp_brush_application_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_brush_application_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpBrushApplicationMode</NAME>
typedef enum
{
  GIMP_BRUSH_HARD,
  GIMP_BRUSH_SOFT,
  GIMP_BRUSH_PRESSURE  /*< pdb-skip, skip >*/
} GimpBrushApplicationMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CLONE_ALIGN_MODE</NAME>
#define GIMP_TYPE_CLONE_ALIGN_MODE (gimp_clone_align_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_clone_align_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCloneAlignMode</NAME>
typedef enum /*< pdb-skip >*/
{
  GIMP_CLONE_ALIGN_NO,          /*< desc="None"        >*/
  GIMP_CLONE_ALIGN_YES,         /*< desc="Aligned"     >*/
  GIMP_CLONE_ALIGN_REGISTERED,  /*< desc="Registered"  >*/
  GIMP_CLONE_ALIGN_FIXED        /*< desc="Fixed"       >*/
} GimpCloneAlignMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CONVOLVE_TYPE</NAME>
#define GIMP_TYPE_CONVOLVE_TYPE (gimp_convolve_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_convolve_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpConvolveType</NAME>
typedef enum
{
  GIMP_BLUR_CONVOLVE,     /*< desc="Blur"    >*/
  GIMP_SHARPEN_CONVOLVE,  /*< desc="Sharpen" >*/
  GIMP_CUSTOM_CONVOLVE    /*< pdb-skip, skip >*/
} GimpConvolveType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_INK_BLOB_TYPE</NAME>
#define GIMP_TYPE_INK_BLOB_TYPE (gimp_ink_blob_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_ink_blob_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpInkBlobType</NAME>
typedef enum  /*< pdb-skip >*/
{
  GIMP_INK_BLOB_TYPE_ELLIPSE,
  GIMP_INK_BLOB_TYPE_SQUARE,
  GIMP_INK_BLOB_TYPE_DIAMOND
} GimpInkBlobType;
</ENUM>
<ENUM>
<NAME>GimpPaintState</NAME>
typedef enum  /*< skip, pdb-skip >*/
{
  GIMP_PAINT_STATE_INIT,    /*  Setup PaintFunc internals                    */
  GIMP_PAINT_STATE_MOTION,  /*  PaintFunc performs motion-related rendering  */
  GIMP_PAINT_STATE_FINISH   /*  Cleanup and/or reset PaintFunc operation     */
} GimpPaintState;
</ENUM>
<STRUCT>
<NAME>GimpPaintCore</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushCore</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintOptions</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GimpPaintRegisterCallback</NAME>
<RETURNS>void </RETURNS>
Gimp        *gimp,
                                            GType        paint_type,
                                            GType        paint_options_type,
                                            const gchar *identifier,
                                            const gchar *blurb,
                                            const gchar *stock_id
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpPaintRegisterFunc</NAME>
<RETURNS>void </RETURNS>
Gimp                      *gimp,
                                            GimpPaintRegisterCallback  callback
</USER_FUNCTION>
<MACRO>
<NAME>TRANSPARENT_OPACITY</NAME>
#define TRANSPARENT_OPACITY        0
</MACRO>
<MACRO>
<NAME>OPAQUE_OPACITY</NAME>
#define OPAQUE_OPACITY             255
</MACRO>
<ENUM>
<NAME>InitialMode</NAME>
typedef enum
{
  INITIAL_CHANNEL_MASK = 0,
  INITIAL_CHANNEL_SELECTION,
  INITIAL_INDEXED,
  INITIAL_INDEXED_ALPHA,
  INITIAL_INTENSITY,
  INITIAL_INTENSITY_ALPHA
} InitialMode;
</ENUM>
<ENUM>
<NAME>CombinationMode</NAME>
typedef enum
{
  NO_COMBINATION = 0,
  COMBINE_INDEXED_INDEXED,
  COMBINE_INDEXED_INDEXED_A,
  COMBINE_INDEXED_A_INDEXED_A,
  COMBINE_INTEN_A_INDEXED_A,
  COMBINE_INTEN_A_CHANNEL_MASK,
  COMBINE_INTEN_A_CHANNEL_SELECTION,
  COMBINE_INTEN_INTEN,
  COMBINE_INTEN_INTEN_A,
  COMBINE_INTEN_A_INTEN,
  COMBINE_INTEN_A_INTEN_A,

  /*  Non-conventional combination modes  */
  BEHIND_INTEN,
  BEHIND_INDEXED,
  REPLACE_INTEN,
  REPLACE_INDEXED,
  ERASE_INTEN,
  ERASE_INDEXED,
  ANTI_ERASE_INTEN,
  ANTI_ERASE_INDEXED,
  COLOR_ERASE_INTEN
} CombinationMode;
</ENUM>
<FUNCTION>
<NAME>paint_funcs_setup</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>paint_funcs_free</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>color_pixels</NAME>
<RETURNS>void  </RETURNS>
guchar       *dest,const guchar *color,guint         w,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>blend_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src1,const guchar *src2,guchar       *dest,guchar        blend,guint         w,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>shade_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,const guchar *color,guchar        rblend,guint         w,guint         bytes,gboolean      has_alpha
</FUNCTION>
<FUNCTION>
<NAME>extract_alpha_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,const guchar *mask,guchar       *dest,guint         w,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>swap_pixels</NAME>
<RETURNS>void  </RETURNS>
guchar       *src,guchar       *dest,guint         length
</FUNCTION>
<FUNCTION>
<NAME>scale_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,guint         length,gint          scale
</FUNCTION>
<FUNCTION>
<NAME>add_alpha_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>flatten_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,const guchar *bg,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>gray_to_rgb_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>component_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,guint         length,guint         bytes,guint         pixel
</FUNCTION>
<FUNCTION>
<NAME>apply_mask_to_alpha_channel</NAME>
<RETURNS>void  </RETURNS>
guchar       *src,const guchar *mask,guint         opacity,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_mask_and_alpha_channel_stipple</NAME>
<RETURNS>void  </RETURNS>
guchar       *src,const guchar *mask,guint         opacity,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_mask_and_alpha_channel_stroke</NAME>
<RETURNS>void  </RETURNS>
guchar       *src,const guchar *mask,guint         opacity,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>copy_gray_to_inten_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>initial_channel_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>initial_indexed_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,const guchar *cmap,guint         length
</FUNCTION>
<FUNCTION>
<NAME>initial_indexed_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,guchar       *dest,const guchar *mask,const guchar *no_mask,const guchar *cmap,guint         opacity,guint         length
</FUNCTION>
<FUNCTION>
<NAME>initial_inten_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src,guchar         *dest,const guchar   *mask,const guchar   *no_mask,guint           opacity,const gboolean *affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>initial_inten_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_indexed_and_indexed_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src1,const guchar   *src2,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_indexed_and_indexed_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src1,const guchar *src2,guchar       *dest,const guchar *mask,guint         opacity,const gint   *affect,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_indexed_a_and_indexed_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src1,const guchar   *src2,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_a_and_indexed_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src1,const guchar *src2,guchar       *dest,const guchar *mask,const guchar *cmap,guint         opacity,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_and_inten_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src1,const guchar   *src2,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_and_inten_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src1,const guchar   *src2,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_a_and_inten_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src1,const guchar   *src2,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,gboolean        mode_affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_a_and_inten_a_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar   *src1,const guchar   *src2,guchar         *dest,const guchar   *mask,guint           opacity,const gboolean *affect,gboolean        mode_affect,guint           length,guint           bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_a_and_channel_mask_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,const guchar *channel,guchar       *dest,const guchar *col,guint         opacity,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>combine_inten_a_and_channel_selection_pixels</NAME>
<RETURNS>void  </RETURNS>
const guchar *src,const guchar *channel,guchar       *dest,const guchar *col,guint         opacity,guint         length,guint         bytes
</FUNCTION>
<FUNCTION>
<NAME>extract_from_inten_pixels</NAME>
<RETURNS>void  </RETURNS>
guchar       *src,guchar       *dest,const guchar *mask,const guchar *bg,gboolean      cut,guint         length,guint         src_bytes,guint         dest_bytes
</FUNCTION>
<FUNCTION>
<NAME>extract_from_indexed_pixels</NAME>
<RETURNS>void  </RETURNS>
guchar       *src,guchar       *dest,const guchar *mask,const guchar *cmap,const guchar *bg,gboolean      cut,guint         length,guint         src_bytes,guint         dest_bytes
</FUNCTION>
<FUNCTION>
<NAME>color_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion  *dest,const guchar *color
</FUNCTION>
<FUNCTION>
<NAME>color_region_mask</NAME>
<RETURNS>void  </RETURNS>
PixelRegion  *dest,PixelRegion  *mask,const guchar *color
</FUNCTION>
<FUNCTION>
<NAME>pattern_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion  *dest,PixelRegion  *mask,TempBuf      *pattern,gint          off_x,gint          off_y
</FUNCTION>
<FUNCTION>
<NAME>blend_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src1,PixelRegion *src2,PixelRegion *dest,guchar       blend
</FUNCTION>
<FUNCTION>
<NAME>shade_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest,guchar      *color,guchar       blend
</FUNCTION>
<FUNCTION>
<NAME>copy_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest
</FUNCTION>
<FUNCTION>
<NAME>copy_region_nocow</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest
</FUNCTION>
<FUNCTION>
<NAME>add_alpha_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest
</FUNCTION>
<FUNCTION>
<NAME>flatten_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest,guchar      *bg
</FUNCTION>
<FUNCTION>
<NAME>extract_alpha_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *mask,PixelRegion *dest
</FUNCTION>
<FUNCTION>
<NAME>extract_from_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion       *src,PixelRegion       *dest,PixelRegion       *mask,const guchar      *cmap,const guchar      *bg,GimpImageBaseType  type,gboolean           cut
</FUNCTION>
<FUNCTION>
<NAME>convolve_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion         *srcR,PixelRegion         *destR,gfloat              *matrix,gint                 size,gdouble              divisor,GimpConvolutionType  mode,gboolean             alpha_weighting
</FUNCTION>
<FUNCTION>
<NAME>multiply_alpha_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *srcR
</FUNCTION>
<FUNCTION>
<NAME>separate_alpha_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *srcR
</FUNCTION>
<FUNCTION>
<NAME>gaussian_blur_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *srcR,gdouble      radius_x,gdouble      radius_y
</FUNCTION>
<FUNCTION>
<NAME>border_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,gint16       xradius,gint16       yradius
</FUNCTION>
<FUNCTION>
<NAME>subsample_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *srcPR,PixelRegion *destPR,gint         subsample
</FUNCTION>
<FUNCTION>
<NAME>shapeburst_region</NAME>
<RETURNS>gfloat </RETURNS>
PixelRegion      *srcPR,PixelRegion      *distPR,GimpProgressFunc  progress_callback,gpointer          progress_data
</FUNCTION>
<FUNCTION>
<NAME>thin_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *region,gint16       xradius,gint16       yradius,gboolean     edge_lock
</FUNCTION>
<FUNCTION>
<NAME>fatten_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *region,gint16       xradius,gint16       yradius
</FUNCTION>
<FUNCTION>
<NAME>smooth_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *region
</FUNCTION>
<FUNCTION>
<NAME>erode_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *region
</FUNCTION>
<FUNCTION>
<NAME>dilate_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *region
</FUNCTION>
<FUNCTION>
<NAME>swap_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest
</FUNCTION>
<FUNCTION>
<NAME>apply_mask_to_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *mask,guint        opacity
</FUNCTION>
<FUNCTION>
<NAME>combine_mask_and_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *mask,guint        opacity,gboolean     stipple
</FUNCTION>
<FUNCTION>
<NAME>copy_gray_to_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest
</FUNCTION>
<FUNCTION>
<NAME>copy_component</NAME>
<RETURNS>void  </RETURNS>
PixelRegion *src,PixelRegion *dest,guint        pixel
</FUNCTION>
<FUNCTION>
<NAME>initial_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion    *src,PixelRegion    *dest,PixelRegion    *mask,guchar         *data,guint           opacity,GimpLayerModeEffects  mode,const gboolean *affect,InitialMode     type
</FUNCTION>
<FUNCTION>
<NAME>combine_regions</NAME>
<RETURNS>void  </RETURNS>
PixelRegion    *src1,PixelRegion    *src2,PixelRegion    *dest,PixelRegion    *mask,guchar         *data,guint           opacity,GimpLayerModeEffects  mode,const gboolean *affect,CombinationMode type
</FUNCTION>
<FUNCTION>
<NAME>combine_regions_replace</NAME>
<RETURNS>void  </RETURNS>
PixelRegion    *src1,PixelRegion    *src2,PixelRegion    *dest,PixelRegion    *mask,guchar         *data,guint           opacity,const gboolean *affect,CombinationMode type
</FUNCTION>
<MACRO>
<NAME>EPSILON</NAME>
#define EPSILON          (0.0001)
</MACRO>
<MACRO>
<NAME>LANCZOS_SPP</NAME>
#define LANCZOS_SPP      (1000)
</MACRO>
<MACRO>
<NAME>LANCZOS_WIDTH</NAME>
#define LANCZOS_WIDTH    (4)
</MACRO>
<MACRO>
<NAME>LANCZOS_SAMPLES</NAME>
#define LANCZOS_SAMPLES  (1 + (LANCZOS_SPP * LANCZOS_WIDTH))
</MACRO>
<MACRO>
<NAME>LANCZOS_WIDTH2</NAME>
#define LANCZOS_WIDTH2   (LANCZOS_WIDTH * 2)
</MACRO>
<FUNCTION>
<NAME>scale_region</NAME>
<RETURNS>void  </RETURNS>
PixelRegion           *srcPR,PixelRegion           *destPR,GimpInterpolationType  interpolation,GimpProgressFunc       progress_callback,gpointer               progress_data
</FUNCTION>
<FUNCTION>
<NAME>internal_procs_init</NAME>
<RETURNS>void </RETURNS>
Gimp *gimp
</FUNCTION>
<STRUCT>
<NAME>GimpProcedure</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPlugInProcedure</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemporaryProcedure</NAME>
</STRUCT>
<ENUM>
<NAME>GimpPDBCompatMode</NAME>
typedef enum
{
  GIMP_PDB_COMPAT_OFF,
  GIMP_PDB_COMPAT_ON,
  GIMP_PDB_COMPAT_WARN
} GimpPDBCompatMode;
</ENUM>
<FUNCTION>
<NAME>gimp_pdb_compat_param_spec</NAME>
<RETURNS>GParamSpec     *</RETURNS>
Gimp           *gimp,GimpPDBArgType  arg_type,const gchar    *name,const gchar    *desc
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_compat_arg_type_to_gtype</NAME>
<RETURNS>GType            </RETURNS>
GimpPDBArgType  type
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_compat_arg_type_from_gtype</NAME>
<RETURNS>GimpPDBArgType   </RETURNS>
GType           type
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_compat_arg_type_to_string</NAME>
<RETURNS>gchar          *</RETURNS>
GimpPDBArgType  type
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dump</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp             *gimp,const gchar      *filename
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_query</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp             *gimp,const gchar      *name,const gchar      *blurb,const gchar      *help,const gchar      *author,const gchar      *copyright,const gchar      *date,const gchar      *proc_type,gint             *num_procs,gchar          ***procs
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_proc_info</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp             *gimp,const gchar      *proc_name,gchar           **blurb,gchar           **help,gchar           **author,gchar           **copyright,gchar           **date,GimpPDBProcType  *proc_type,gint             *num_args,gint             *num_values
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_init</NAME>
<RETURNS>void            </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_exit</NAME>
<RETURNS>void            </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_init_procs</NAME>
<RETURNS>void            </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_register</NAME>
<RETURNS>void            </RETURNS>
Gimp          *gimp,GimpProcedure *procedure
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_unregister</NAME>
<RETURNS>void            </RETURNS>
Gimp          *gimp,const gchar   *procedure_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_lookup</NAME>
<RETURNS>GimpProcedure *</RETURNS>
Gimp          *gimp,const gchar   *procedure_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_execute</NAME>
<RETURNS>GValueArray   *</RETURNS>
Gimp          *gimp,GimpContext   *context,GimpProgress  *progress,const gchar   *procedure_name,GValueArray   *args
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_run_proc</NAME>
<RETURNS>GValueArray   *</RETURNS>
Gimp          *gimp,GimpContext   *context,GimpProgress  *progress,const gchar   *procedure_name,...
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpMarshalFunc</NAME>
<RETURNS>GValueArray *</RETURNS>
GimpProcedure     *procedure,
                                           Gimp              *gimp,
                                           GimpContext       *context,
                                           GimpProgress      *progress,
                                           const GValueArray *args
</USER_FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PROCEDURE</NAME>
#define GIMP_TYPE_PROCEDURE            (gimp_procedure_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PROCEDURE</NAME>
#define GIMP_PROCEDURE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PROCEDURE, GimpProcedure))
</MACRO>
<MACRO>
<NAME>GIMP_PROCEDURE_CLASS</NAME>
#define GIMP_PROCEDURE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PROCEDURE, GimpProcedureClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROCEDURE</NAME>
#define GIMP_IS_PROCEDURE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PROCEDURE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROCEDURE_CLASS</NAME>
#define GIMP_IS_PROCEDURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PROCEDURE))
</MACRO>
<MACRO>
<NAME>GIMP_PROCEDURE_GET_CLASS</NAME>
#define GIMP_PROCEDURE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PROCEDURE, GimpProcedureClass))
</MACRO>
<STRUCT>
<NAME>GimpProcedureClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProcedure</NAME>
struct _GimpProcedure
{
  GimpObject        parent_instance;

  GimpPDBProcType   proc_type;      /* Type of procedure              */

  gboolean          static_strings; /* Are the strings allocated?     */

  gchar            *original_name;  /* Uncanonicalized procedure name */
  gchar            *blurb;          /* Short procedure description    */
  gchar            *help;           /* Detailed help instructions     */
  gchar            *author;         /* Author field                   */
  gchar            *copyright;      /* Copyright field                */
  gchar            *date;           /* Date field                     */
  gchar            *deprecated;     /* Replacement if deprecated      */

  gint32            num_args;       /* Number of procedure arguments  */
  GParamSpec      **args;           /* Array of procedure arguments   */

  gint32            num_values;     /* Number of return values        */
  GParamSpec      **values;         /* Array of return values         */

  GimpMarshalFunc   marshal_func;   /* Marshaller for internal procs  */
};
</STRUCT>
<STRUCT>
<NAME>GimpProcedureClass</NAME>
struct _GimpProcedureClass
{
  GimpObjectClass parent_class;

  GValueArray * (* execute)       (GimpProcedure *procedure,
                                   Gimp          *gimp,
                                   GimpContext   *context,
                                   GimpProgress  *progress,
                                   GValueArray   *args);
  void          (* execute_async) (GimpProcedure *procedure,
                                   Gimp          *gimp,
                                   GimpContext   *context,
                                   GimpProgress  *progress,
                                   GValueArray   *args,
                                   gint32         display_ID);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_procedure_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_new</NAME>
<RETURNS>GimpProcedure *</RETURNS>
GimpMarshalFunc   marshal_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_set_strings</NAME>
<RETURNS>void            </RETURNS>
GimpProcedure    *procedure,gchar            *original_name,gchar            *blurb,gchar            *help,gchar            *author,gchar            *copyright,gchar            *date,gchar            *deprecated
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_set_static_strings</NAME>
<RETURNS>void            </RETURNS>
GimpProcedure    *procedure,gchar            *original_name,gchar            *blurb,gchar            *help,gchar            *author,gchar            *copyright,gchar            *date,gchar            *deprecated
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_take_strings</NAME>
<RETURNS>void            </RETURNS>
GimpProcedure    *procedure,gchar            *original_name,gchar            *blurb,gchar            *help,gchar            *author,gchar            *copyright,gchar            *date,gchar            *deprecated
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_add_argument</NAME>
<RETURNS>void            </RETURNS>
GimpProcedure    *procedure,GParamSpec       *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_add_return_value</NAME>
<RETURNS>void            </RETURNS>
GimpProcedure    *procedure,GParamSpec       *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_get_arguments</NAME>
<RETURNS>GValueArray   *</RETURNS>
GimpProcedure    *procedure
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_get_return_values</NAME>
<RETURNS>GValueArray   *</RETURNS>
GimpProcedure    *procedure,gboolean          success
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_execute</NAME>
<RETURNS>GValueArray   *</RETURNS>
GimpProcedure    *procedure,Gimp             *gimp,GimpContext      *context,GimpProgress     *progress,GValueArray      *args
</FUNCTION>
<FUNCTION>
<NAME>gimp_procedure_execute_async</NAME>
<RETURNS>void            </RETURNS>
GimpProcedure    *procedure,Gimp             *gimp,GimpContext      *context,GimpProgress     *progress,GValueArray      *args,gint32            display_ID
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PLUG_IN_PROCEDURE</NAME>
#define GIMP_TYPE_PLUG_IN_PROCEDURE            (gimp_plug_in_procedure_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PLUG_IN_PROCEDURE</NAME>
#define GIMP_PLUG_IN_PROCEDURE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PLUG_IN_PROCEDURE, GimpPlugInProcedure))
</MACRO>
<MACRO>
<NAME>GIMP_PLUG_IN_PROCEDURE_CLASS</NAME>
#define GIMP_PLUG_IN_PROCEDURE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PLUG_IN_PROCEDURE, GimpPlugInProcedureClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PLUG_IN_PROCEDURE</NAME>
#define GIMP_IS_PLUG_IN_PROCEDURE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PLUG_IN_PROCEDURE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PLUG_IN_PROCEDURE_CLASS</NAME>
#define GIMP_IS_PLUG_IN_PROCEDURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PLUG_IN_PROCEDURE))
</MACRO>
<MACRO>
<NAME>GIMP_PLUG_IN_PROCEDURE_GET_CLASS</NAME>
#define GIMP_PLUG_IN_PROCEDURE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PLUG_IN_PROCEDURE, GimpPlugInProcedureClass))
</MACRO>
<STRUCT>
<NAME>GimpPlugInProcedureClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPlugInProcedure</NAME>
struct _GimpPlugInProcedure
{
  GimpProcedure    parent_instance;

  /*  common members  */
  gchar           *prog;
  gchar           *menu_label;
  GList           *menu_paths;
  GimpIconType     icon_type;
  gint             icon_data_length;
  guint8          *icon_data;
  gchar           *image_types;
  PlugInImageType  image_types_val;
  time_t           mtime;
  gboolean           installed_during_init;

  /*  file proc specific members  */
  gboolean         file_proc;
  gchar           *extensions;
  gchar           *prefixes;
  gchar           *magics;
  gchar           *mime_type;
  GSList          *extensions_list;
  GSList          *prefixes_list;
  GSList          *magics_list;
  gchar           *thumb_loader;
};
</STRUCT>
<STRUCT>
<NAME>GimpPlugInProcedureClass</NAME>
struct _GimpPlugInProcedureClass
{
  GimpProcedureClass parent_class;

  const gchar * (* get_progname) (const GimpPlugInProcedure *procedure);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_new</NAME>
<RETURNS>GimpProcedure *</RETURNS>
GimpPDBProcType            proc_type,const gchar               *prog
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_find</NAME>
<RETURNS>GimpPlugInProcedure *</RETURNS>
GSList                    *list,const gchar               *proc_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_progname</NAME>
<RETURNS>const gchar *</RETURNS>
const GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_add_menu_path</NAME>
<RETURNS>gboolean      </RETURNS>
GimpPlugInProcedure       *proc,const gchar               *menu_path,GError                   **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_label</NAME>
<RETURNS>gchar       *</RETURNS>
const GimpPlugInProcedure *proc,const gchar               *locale_domain
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_set_icon</NAME>
<RETURNS>void          </RETURNS>
GimpPlugInProcedure       *proc,GimpIconType               type,const guint8              *data,gint                       data_length
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_stock_id</NAME>
<RETURNS>const gchar *</RETURNS>
const GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_pixbuf</NAME>
<RETURNS>GdkPixbuf   *</RETURNS>
const GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_help_id</NAME>
<RETURNS>gchar       *</RETURNS>
const GimpPlugInProcedure *proc,const gchar               *help_domain
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_get_sensitive</NAME>
<RETURNS>gboolean      </RETURNS>
const GimpPlugInProcedure *proc,GimpImageType              image_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_set_image_types</NAME>
<RETURNS>void          </RETURNS>
GimpPlugInProcedure       *proc,const gchar               *image_types
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_set_file_proc</NAME>
<RETURNS>void          </RETURNS>
GimpPlugInProcedure       *proc,const gchar               *extensions,const gchar               *prefixes,const gchar               *magics
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_set_mime_type</NAME>
<RETURNS>void          </RETURNS>
GimpPlugInProcedure       *proc,const gchar               *mime_ype
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_procedure_set_thumb_loader</NAME>
<RETURNS>void          </RETURNS>
GimpPlugInProcedure       *proc,const gchar               *thumbnailer
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEMPORARY_PROCEDURE</NAME>
#define GIMP_TYPE_TEMPORARY_PROCEDURE            (gimp_temporary_procedure_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEMPORARY_PROCEDURE</NAME>
#define GIMP_TEMPORARY_PROCEDURE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEMPORARY_PROCEDURE, GimpTemporaryProcedure))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPORARY_PROCEDURE_CLASS</NAME>
#define GIMP_TEMPORARY_PROCEDURE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEMPORARY_PROCEDURE, GimpTemporaryProcedureClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPORARY_PROCEDURE</NAME>
#define GIMP_IS_TEMPORARY_PROCEDURE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEMPORARY_PROCEDURE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPORARY_PROCEDURE_CLASS</NAME>
#define GIMP_IS_TEMPORARY_PROCEDURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEMPORARY_PROCEDURE))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPORARY_PROCEDURE_GET_CLASS</NAME>
#define GIMP_TEMPORARY_PROCEDURE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEMPORARY_PROCEDURE, GimpTemporaryProcedureClass))
</MACRO>
<STRUCT>
<NAME>GimpTemporaryProcedureClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemporaryProcedure</NAME>
struct _GimpTemporaryProcedure
{
  GimpPlugInProcedure  parent_instance;

  PlugIn              *plug_in;
};
</STRUCT>
<STRUCT>
<NAME>GimpTemporaryProcedureClass</NAME>
struct _GimpTemporaryProcedureClass
{
  GimpPlugInProcedureClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_temporary_procedure_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_temporary_procedure_new</NAME>
<RETURNS>GimpProcedure *</RETURNS>
PlugIn *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_context_push</NAME>
<RETURNS>gboolean  </RETURNS>
PlugIn *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_context_pop</NAME>
<RETURNS>gboolean  </RETURNS>
PlugIn *plug_in
</FUNCTION>
<ENUM>
<NAME>GimpDebugWrapFlag</NAME>
typedef enum
{
  GIMP_DEBUG_WRAP_QUERY = 1 << 0,
  GIMP_DEBUG_WRAP_INIT  = 1 << 1,
  GIMP_DEBUG_WRAP_RUN   = 1 << 2,

  GIMP_DEBUG_WRAP_DEFAULT = GIMP_DEBUG_WRAP_RUN
} GimpDebugWrapFlag;
</ENUM>
<FUNCTION>
<NAME>plug_in_debug_init</NAME>
<RETURNS>void       </RETURNS>
Gimp               *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_debug_exit</NAME>
<RETURNS>void       </RETURNS>
Gimp               *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_debug_argv</NAME>
<RETURNS>gchar    **</RETURNS>
Gimp               *gimp,const gchar        *name,GimpDebugWrapFlag   flag,gchar             **args
</FUNCTION>
<STRUCT>
<NAME>PlugInDef</NAME>
struct _PlugInDef
{
  gchar    *prog;
  GSList   *procedures;
  gchar    *locale_domain_name;
  gchar    *locale_domain_path;
  gchar    *help_domain_name;
  gchar    *help_domain_uri;
  time_t    mtime;
  gboolean  needs_query;  /* Does the plug-in need to be queried ?     */
  gboolean  has_init;     /* Does the plug-in need to be initialized ? */
};
</STRUCT>
<FUNCTION>
<NAME>plug_in_def_new</NAME>
<RETURNS>PlugInDef *</RETURNS>
const gchar         *prog
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_free</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_add_procedure</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_remove_procedure</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_locale_domain_name</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,const gchar         *domain_name
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_locale_domain_path</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,const gchar         *domain_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_help_domain_name</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,const gchar         *domain_name
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_help_domain_uri</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,const gchar         *domain_uri
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_mtime</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,time_t               mtime
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_needs_query</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,gboolean             needs_query
</FUNCTION>
<FUNCTION>
<NAME>plug_in_def_set_has_init</NAME>
<RETURNS>void        </RETURNS>
PlugInDef           *plug_in_def,gboolean             has_init
</FUNCTION>
<ENUM>
<NAME>PlugInImageType</NAME>
typedef enum /*< pdb-skip >*/ /*< skip >*/
{
  PLUG_IN_RGB_IMAGE      = 1 << 0,
  PLUG_IN_GRAY_IMAGE     = 1 << 1,
  PLUG_IN_INDEXED_IMAGE  = 1 << 2,
  PLUG_IN_RGBA_IMAGE     = 1 << 3,
  PLUG_IN_GRAYA_IMAGE    = 1 << 4,
  PLUG_IN_INDEXEDA_IMAGE = 1 << 5
} PlugInImageType;
</ENUM>
<FUNCTION>
<NAME>plug_in_handle_message</NAME>
<RETURNS>void   </RETURNS>
PlugIn          *plug_in,GimpWireMessage *msg
</FUNCTION>
<FUNCTION>
<NAME>plug_in_params_to_args</NAME>
<RETURNS>GValueArray *</RETURNS>
GParamSpec  **pspecs,gint          n_pspecs,GPParam      *params,gint          n_params,gboolean      return_values,gboolean      full_copy
</FUNCTION>
<FUNCTION>
<NAME>plug_in_args_to_params</NAME>
<RETURNS>GPParam     *</RETURNS>
GValueArray  *args,gboolean      full_copy
</FUNCTION>
<STRUCT>
<NAME>PlugInProcFrame</NAME>
struct _PlugInProcFrame
{
  gint           ref_count;

  GimpContext   *main_context;
  GList         *context_stack;

  GimpProcedure *procedure;
  GMainLoop     *main_loop;

  GValueArray   *return_vals;

  GimpProgress  *progress;
  gboolean       progress_created;
  gulong         progress_cancel_id;
};
</STRUCT>
<FUNCTION>
<NAME>plug_in_proc_frame_new</NAME>
<RETURNS>PlugInProcFrame *</RETURNS>
GimpContext     *context,GimpProgress    *progress,GimpProcedure   *procedure
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_init</NAME>
<RETURNS>void              </RETURNS>
PlugInProcFrame *proc_frame,GimpContext     *context,GimpProgress    *progress,GimpProcedure   *procedure
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_dispose</NAME>
<RETURNS>void              </RETURNS>
PlugInProcFrame *proc_frame,PlugIn          *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_ref</NAME>
<RETURNS>PlugInProcFrame *</RETURNS>
PlugInProcFrame *proc_frame
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_unref</NAME>
<RETURNS>void              </RETURNS>
PlugInProcFrame *proc_frame,PlugIn          *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_get_return_vals</NAME>
<RETURNS>GValueArray *</RETURNS>
PlugInProcFrame *proc_frame
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_start</NAME>
<RETURNS>void       </RETURNS>
PlugIn      *plug_in,const gchar *message,GimpObject  *display
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_end</NAME>
<RETURNS>void       </RETURNS>
PlugIn      *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_set_text</NAME>
<RETURNS>void       </RETURNS>
PlugIn      *plug_in,const gchar *message
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_set_value</NAME>
<RETURNS>void       </RETURNS>
PlugIn      *plug_in,gdouble      percentage
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_pulse</NAME>
<RETURNS>void       </RETURNS>
PlugIn      *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_get_window</NAME>
<RETURNS>guint32    </RETURNS>
PlugIn      *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_install</NAME>
<RETURNS>gboolean   </RETURNS>
PlugIn      *plug_in,const gchar *progress_callback
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_uninstall</NAME>
<RETURNS>gboolean   </RETURNS>
PlugIn      *plug_in,const gchar *progress_callback
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_cancel</NAME>
<RETURNS>gboolean   </RETURNS>
PlugIn      *plug_in,const gchar *progress_callback
</FUNCTION>
<FUNCTION>
<NAME>plug_in_progress_message</NAME>
<RETURNS>void       </RETURNS>
PlugIn      *plug_in,const gchar *message
</FUNCTION>
<FUNCTION>
<NAME>plug_in_rc_parse</NAME>
<RETURNS>GSList   *</RETURNS>
Gimp         *gimp,const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>plug_in_rc_write</NAME>
<RETURNS>gboolean   </RETURNS>
GSList       *plug_in_defs,const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>plug_in_run</NAME>
<RETURNS>GValueArray *</RETURNS>
Gimp                   *gimp,GimpContext            *context,GimpProgress           *progress,GimpPlugInProcedure    *procedure,GValueArray            *args,gboolean                synchronous,gboolean                destroy_return_vals,gint                    display_ID
</FUNCTION>
<FUNCTION>
<NAME>plug_in_run_temp</NAME>
<RETURNS>GValueArray *</RETURNS>
Gimp                   *gimp,GimpContext            *context,GimpProgress           *progress,GimpTemporaryProcedure *procedure,GValueArray            *args
</FUNCTION>
<FUNCTION>
<NAME>plug_in_shm_init</NAME>
<RETURNS>void     </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_shm_exit</NAME>
<RETURNS>void     </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_shm_get_ID</NAME>
<RETURNS>gint     </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_shm_get_addr</NAME>
<RETURNS>guchar *</RETURNS>
Gimp *gimp
</FUNCTION>
<STRUCT>
<NAME>PlugIn</NAME>
</STRUCT>
<STRUCT>
<NAME>PlugInDef</NAME>
</STRUCT>
<STRUCT>
<NAME>PlugInMenuBranch</NAME>
</STRUCT>
<STRUCT>
<NAME>PlugInProcFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>PlugInShm</NAME>
</STRUCT>
<MACRO>
<NAME>WRITE_BUFFER_SIZE</NAME>
#define WRITE_BUFFER_SIZE  512
</MACRO>
<STRUCT>
<NAME>PlugIn</NAME>
struct _PlugIn
{
  Gimp         *gimp;

  gint          ref_count;

  guint         open : 1;         /*  Is the plug-in open?                    */
  guint         query : 1;        /*  Are we querying the plug-in?            */
  guint         init : 1;         /*  Are we initialing the plug-in?          */
  guint         synchronous : 1;  /*  Is the plug-in running synchronously?   */

  GPid          pid;              /*  Plug-in's process id                    */

  gchar        *name;             /*  Plug-in's name                          */
  gchar        *prog;             /*  Plug-in's full path name                */

  GIOChannel   *my_read;          /*  App's read and write channels           */
  GIOChannel   *my_write;
  GIOChannel   *his_read;         /*  Plug-in's read and write channels       */
  GIOChannel   *his_write;

  guint         input_id;         /*  Id of input proc                        */

  gchar         write_buffer[WRITE_BUFFER_SIZE]; /*  Buffer for writing       */
  gint          write_buffer_index;              /*  Buffer index for writing */

  GSList       *temp_procedures;  /*  Temporary procedures                    */

  GMainLoop    *ext_main_loop;    /*  for waiting for extension_ack           */

  PlugInProcFrame  main_proc_frame;

  GList           *temp_proc_frames;

  PlugInDef    *plug_in_def;      /*  Valid only during query() and init()    */
};
</STRUCT>
<FUNCTION>
<NAME>plug_in_init</NAME>
<RETURNS>void              </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_exit</NAME>
<RETURNS>void              </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_call_query</NAME>
<RETURNS>void              </RETURNS>
Gimp          *gimp,GimpContext   *context,PlugInDef     *plug_in_def
</FUNCTION>
<FUNCTION>
<NAME>plug_in_call_init</NAME>
<RETURNS>void              </RETURNS>
Gimp          *gimp,GimpContext   *context,PlugInDef     *plug_in_def
</FUNCTION>
<FUNCTION>
<NAME>plug_in_new</NAME>
<RETURNS>PlugIn          *</RETURNS>
Gimp          *gimp,GimpContext   *context,GimpProgress  *progress,GimpProcedure *procedure,const gchar   *prog
</FUNCTION>
<FUNCTION>
<NAME>plug_in_ref</NAME>
<RETURNS>void              </RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_unref</NAME>
<RETURNS>void              </RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_open</NAME>
<RETURNS>gboolean          </RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_close</NAME>
<RETURNS>void              </RETURNS>
PlugIn        *plug_in,gboolean       kill_it
</FUNCTION>
<FUNCTION>
<NAME>plug_in_push</NAME>
<RETURNS>void              </RETURNS>
Gimp          *gimp,PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_pop</NAME>
<RETURNS>void              </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_get_proc_frame</NAME>
<RETURNS>PlugInProcFrame *</RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_push</NAME>
<RETURNS>PlugInProcFrame *</RETURNS>
PlugIn        *plug_in,GimpContext   *context,GimpProgress  *progress,GimpProcedure *procedure
</FUNCTION>
<FUNCTION>
<NAME>plug_in_proc_frame_pop</NAME>
<RETURNS>void              </RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_main_loop</NAME>
<RETURNS>void              </RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_main_loop_quit</NAME>
<RETURNS>void              </RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_get_undo_desc</NAME>
<RETURNS>gchar           *</RETURNS>
PlugIn        *plug_in
</FUNCTION>
<FUNCTION>
<NAME>plug_in_menu_register</NAME>
<RETURNS>gboolean          </RETURNS>
PlugIn        *plug_in,const gchar   *proc_name,const gchar   *menu_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_add_temp_proc</NAME>
<RETURNS>void              </RETURNS>
PlugIn                 *plug_in,GimpTemporaryProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_remove_temp_proc</NAME>
<RETURNS>void              </RETURNS>
PlugIn                 *plug_in,GimpTemporaryProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_ins_query</NAME>
<RETURNS>gint   </RETURNS>
Gimp          *gimp,const gchar   *search_str,gchar       ***menu_strs,gchar       ***accel_strs,gchar       ***prog_strs,gchar       ***types_strs,gchar       ***realname_strs,gint32       **time_ints
</FUNCTION>
<FUNCTION>
<NAME>plug_ins_init</NAME>
<RETURNS>void   </RETURNS>
Gimp                   *gimp,GimpContext            *context,GimpInitStatusFunc      status_callback
</FUNCTION>
<FUNCTION>
<NAME>plug_ins_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp                   *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_ins_procedure_add</NAME>
<RETURNS>void   </RETURNS>
Gimp                   *gimp,GimpPlugInProcedure    *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_ins_temp_procedure_add</NAME>
<RETURNS>void   </RETURNS>
Gimp                   *gimp,GimpTemporaryProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_ins_temp_procedure_remove</NAME>
<RETURNS>void   </RETURNS>
Gimp                   *gimp,GimpTemporaryProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_data_free</NAME>
<RETURNS>void           </RETURNS>
Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_data_set</NAME>
<RETURNS>void           </RETURNS>
Gimp         *gimp,const gchar  *identifier,gint32        bytes,const guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>plug_in_data_get</NAME>
<RETURNS>const guint8 *</RETURNS>
Gimp         *gimp,const gchar  *identifier,gint32       *bytes
</FUNCTION>
<FUNCTION>
<NAME>plug_in_file_register_load_handler</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp        *gimp,const gchar *name,const gchar *extensions,const gchar *prefixes,const gchar *magics
</FUNCTION>
<FUNCTION>
<NAME>plug_in_file_register_save_handler</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp        *gimp,const gchar *name,const gchar *extensions,const gchar *prefixes
</FUNCTION>
<FUNCTION>
<NAME>plug_in_file_register_mime_type</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp        *gimp,const gchar *name,const gchar *mime_type
</FUNCTION>
<FUNCTION>
<NAME>plug_in_file_register_thumb_loader</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp        *gimp,const gchar *load_proc,const gchar *thumb_proc
</FUNCTION>
<FUNCTION>
<NAME>plug_in_help_domain_exit</NAME>
<RETURNS>void          </RETURNS>
Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_help_domain_add</NAME>
<RETURNS>void          </RETURNS>
Gimp         *gimp,const gchar  *prog_name,const gchar  *domain_name,const gchar  *domain_uri
</FUNCTION>
<FUNCTION>
<NAME>plug_in_help_domain</NAME>
<RETURNS>const gchar *</RETURNS>
Gimp         *gimp,const gchar  *prog_name,const gchar **help_uri
</FUNCTION>
<FUNCTION>
<NAME>plug_in_help_domains</NAME>
<RETURNS>gint          </RETURNS>
Gimp         *gimp,gchar      ***help_domains,gchar      ***help_uris
</FUNCTION>
<FUNCTION>
<NAME>plug_in_locale_domain_exit</NAME>
<RETURNS>void          </RETURNS>
Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_locale_domain_add</NAME>
<RETURNS>void          </RETURNS>
Gimp         *gimp,const gchar  *prog_name,const gchar  *domain_name,const gchar  *domain_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_locale_domain</NAME>
<RETURNS>const gchar *</RETURNS>
Gimp         *gimp,const gchar  *prog_name,const gchar **locale_path
</FUNCTION>
<FUNCTION>
<NAME>plug_in_standard_locale_domain</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>PlugInMenuBranch</NAME>
struct _PlugInMenuBranch
{
  gchar *prog_name;
  gchar *menu_path;
  gchar *menu_label;
};
</STRUCT>
<FUNCTION>
<NAME>plug_in_menu_branch_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>plug_in_menu_branch_add</NAME>
<RETURNS>void   </RETURNS>
Gimp        *gimp,const gchar *prog_name,const gchar *menu_path,const gchar *menu_label
</FUNCTION>
<FUNCTION>
<NAME>gimp_fonts_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_fonts_load</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_fonts_reset</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_font_util_pango_font_description_to_string</NAME>
<RETURNS>gchar *</RETURNS>
const PangoFontDescription *desc
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FONT</NAME>
#define GIMP_TYPE_FONT            (gimp_font_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FONT</NAME>
#define GIMP_FONT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FONT, GimpFont))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_CLASS</NAME>
#define GIMP_FONT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FONT, GimpFontClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT</NAME>
#define GIMP_IS_FONT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FONT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_CLASS</NAME>
#define GIMP_IS_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FONT))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_GET_CLASS</NAME>
#define GIMP_FONT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FONT, GimpFontClass))
</MACRO>
<STRUCT>
<NAME>GimpFontClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>gimp_font_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_font_get_standard</NAME>
<RETURNS>GimpFont *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FONT_LIST</NAME>
#define GIMP_TYPE_FONT_LIST            (gimp_font_list_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FONT_LIST</NAME>
#define GIMP_FONT_LIST(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FONT_LIST, GimpFontList))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_LIST_CLASS</NAME>
#define GIMP_FONT_LIST_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FONT_LIST, GimpFontListClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_LIST</NAME>
#define GIMP_IS_FONT_LIST(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FONT_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_LIST_CLASS</NAME>
#define GIMP_IS_FONT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FONT_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_LIST_GET_CLASS</NAME>
#define GIMP_FONT_LIST_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FONT_LIST, GimpFontListClass))
</MACRO>
<STRUCT>
<NAME>GimpFontListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFontList</NAME>
struct _GimpFontList
{
  GimpList  parent_instance;

  gdouble   xresolution;
  gdouble   yresolution;
};
</STRUCT>
<STRUCT>
<NAME>GimpFontListClass</NAME>
struct _GimpFontListClass
{
  GimpListClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_font_list_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_font_list_new</NAME>
<RETURNS>GimpContainer *</RETURNS>
gdouble       xresolution,gdouble       yresolution
</FUNCTION>
<FUNCTION>
<NAME>gimp_font_list_restore</NAME>
<RETURNS>void            </RETURNS>
GimpFontList *list
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_render_bitmap</NAME>
<RETURNS>void  </RETURNS>
PangoFont  *font,PangoGlyph  glyph,FT_Int32    flags,FT_Matrix  *trafo,gint        x,gint        y,FT_Bitmap  *bitmap
</FUNCTION>
<FUNCTION>
<NAME>text_render</NAME>
<RETURNS>GimpLayer *</RETURNS>
GimpImage    *image,GimpDrawable *drawable,GimpContext  *context,gint          text_x,gint          text_y,const gchar  *fontname,const gchar  *text,gint          border,gboolean      antialias
</FUNCTION>
<FUNCTION>
<NAME>text_get_extents</NAME>
<RETURNS>gboolean    </RETURNS>
const gchar  *fontname,const gchar  *text,gint         *width,gint         *height,gint         *ascent,gint         *descent
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_parasite_name</NAME>
<RETURNS>const gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_to_parasite</NAME>
<RETURNS>GimpParasite *</RETURNS>
const GimpText      *text
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_from_parasite</NAME>
<RETURNS>GimpText     *</RETURNS>
const GimpParasite  *parasite,GError             **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_gdyntext_parasite_name</NAME>
<RETURNS>const gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_from_gdyntext_parasite</NAME>
<RETURNS>GimpText     *</RETURNS>
const GimpParasite  *parasite
</FUNCTION>
<STRUCT>
<NAME>GimpTextLayout</NAME>
struct _GimpTextLayout
{
  GObject         object;

  GimpText       *text;
  PangoLayout    *layout;
  PangoRectangle  extents;
};
</STRUCT>
<STRUCT>
<NAME>GimpTextLayoutClass</NAME>
struct _GimpTextLayoutClass
{
  GObjectClass   parent_class;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GimpTextRenderFunc</NAME>
<RETURNS>void </RETURNS>
PangoFont  *font,
                                      PangoGlyph  glyph,
                                      FT_Int32    load_flags,
                                      FT_Matrix  *tranform,
                                      gint        x,
                                      gint        y,
                                      gpointer    render_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_text_vectors_new</NAME>
<RETURNS>GimpVectors *</RETURNS>
GimpImage *image,GimpText  *text
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_font_name_from_xlfd</NAME>
<RETURNS>gchar    *</RETURNS>
const gchar *xlfd
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_font_size_from_xlfd</NAME>
<RETURNS>gboolean   </RETURNS>
const gchar *xlfd,gdouble     *size,GimpUnit    *size_unit
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_set_font_from_xlfd</NAME>
<RETURNS>void       </RETURNS>
GimpText    *text,const gchar *xlfd
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT</NAME>
#define GIMP_TYPE_TEXT            (gimp_text_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT</NAME>
#define GIMP_TEXT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT, GimpText))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_CLASS</NAME>
#define GIMP_TEXT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEXT, GimpTextClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT</NAME>
#define GIMP_IS_TEXT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_CLASS</NAME>
#define GIMP_IS_TEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_GET_CLASS</NAME>
#define GIMP_TEXT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEXT, GimpTextClass))
</MACRO>
<STRUCT>
<NAME>GimpTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpText</NAME>
struct _GimpText
{
  GimpObject             parent_instance;

  gchar                 *text;
  gchar                 *font;
  GimpUnit               unit;
  gdouble                font_size;
  gboolean               hinting;
  gboolean               autohint;
  gboolean               antialias;
  gboolean               kerning;
  gchar                 *language;
  GimpTextDirection      base_dir;
  GimpRGB                color;
  GimpTextOutline        outline;
  GimpTextJustification  justify;
  gdouble                indent;
  gdouble                line_spacing;
  gdouble                letter_spacing;
  GimpTextBoxMode        box_mode;
  gdouble                box_width;
  gdouble                box_height;
  GimpUnit               box_unit;
  GimpMatrix2            transformation;
  gdouble                offset_x;
  gdouble                offset_y;

  gdouble                border;
};
</STRUCT>
<STRUCT>
<NAME>GimpTextClass</NAME>
struct _GimpTextClass
{
  GimpObjectClass        parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_text_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_get_transformation</NAME>
<RETURNS>void   </RETURNS>
GimpText    *text,GimpMatrix3 *matrix
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_scale</NAME>
<RETURNS>void  </RETURNS>
GimpItem               *item,gint                    new_width,gint                    new_height,gint                    new_offset_x,gint                    new_offset_y,GimpInterpolationType   interpolation_type,GimpProgress           *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_flip</NAME>
<RETURNS>void  </RETURNS>
GimpItem               *item,GimpContext            *context,GimpOrientationType     flip_type,gdouble                 axis,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_rotate</NAME>
<RETURNS>void  </RETURNS>
GimpItem               *item,GimpContext            *context,GimpRotationType        rotate_type,gdouble                 center_x,gdouble                 center_y,gboolean                clip_result
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_transform</NAME>
<RETURNS>void  </RETURNS>
GimpItem               *item,GimpContext            *context,const GimpMatrix3      *matrix,GimpTransformDirection  direction,GimpInterpolationType   interpolation_type,gboolean                supersample,gint                    recursion_level,gboolean                clip_result,GimpProgress           *progress
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_xcf_load_hack</NAME>
<RETURNS>gboolean  </RETURNS>
GimpLayer     **layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_xcf_save_prepare</NAME>
<RETURNS>void      </RETURNS>
GimpTextLayer  *text_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_get_xcf_flags</NAME>
<RETURNS>guint32   </RETURNS>
GimpTextLayer  *text_layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_set_xcf_flags</NAME>
<RETURNS>void      </RETURNS>
GimpTextLayer  *text_layer,guint32         flags
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_LAYER</NAME>
#define GIMP_TYPE_TEXT_LAYER            (gimp_text_layer_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_LAYER</NAME>
#define GIMP_TEXT_LAYER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT_LAYER, GimpTextLayer))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_LAYER_CLASS</NAME>
#define GIMP_TEXT_LAYER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEXT_LAYER, GimpTextLayerClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_LAYER</NAME>
#define GIMP_IS_TEXT_LAYER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT_LAYER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_LAYER_CLASS</NAME>
#define GIMP_IS_TEXT_LAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEXT_LAYER))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_LAYER_GET_CLASS</NAME>
#define GIMP_TEXT_LAYER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEXT_LAYER, GimpTextLayerClass))
</MACRO>
<STRUCT>
<NAME>GimpTextLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextLayer</NAME>
struct _GimpTextLayer
{
  GimpLayer     layer;

  GimpText     *text;
  const gchar  *text_parasite;  /*  parasite name that this text was set from,
                                 *  and that should be removed when the text
                                 *  is changed.
                                 */
  gboolean      auto_rename;
  gboolean      modified;
};
</STRUCT>
<STRUCT>
<NAME>GimpTextLayerClass</NAME>
struct _GimpTextLayerClass
{
  GimpLayerClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_text_layer_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_new</NAME>
<RETURNS>GimpLayer *</RETURNS>
GimpImage     *image,GimpText      *text
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_get_text</NAME>
<RETURNS>GimpText  *</RETURNS>
GimpTextLayer *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_set_text</NAME>
<RETURNS>void        </RETURNS>
GimpTextLayer *layer,GimpText      *text
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_discard</NAME>
<RETURNS>void        </RETURNS>
GimpTextLayer *layer
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layer_set</NAME>
<RETURNS>void        </RETURNS>
GimpTextLayer *layer,const gchar   *undo_desc,const gchar   *first_property_name,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_drawable_is_text_layer</NAME>
<RETURNS>gboolean    </RETURNS>
GimpDrawable  *drawable
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layout_render</NAME>
<RETURNS>void  </RETURNS>
GimpTextLayout     *layout,GimpTextRenderFunc  render_func,gpointer            render_data
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_LAYOUT</NAME>
#define GIMP_TYPE_TEXT_LAYOUT    (gimp_text_layout_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_LAYOUT</NAME>
#define GIMP_TEXT_LAYOUT(obj)    (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT_LAYOUT, GimpTextLayout))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_LAYOUT</NAME>
#define GIMP_IS_TEXT_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT_LAYOUT))
</MACRO>
<STRUCT>
<NAME>GimpTextLayoutClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>gimp_text_layout_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layout_new</NAME>
<RETURNS>GimpTextLayout *</RETURNS>
GimpText       *text,GimpImage      *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layout_get_size</NAME>
<RETURNS>gboolean         </RETURNS>
GimpTextLayout *layout,gint           *width,gint           *heigth
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_layout_get_offsets</NAME>
<RETURNS>void             </RETURNS>
GimpTextLayout *layout,gint           *x,gint           *y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_UNDO</NAME>
#define GIMP_TYPE_TEXT_UNDO            (gimp_text_undo_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_UNDO</NAME>
#define GIMP_TEXT_UNDO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT_UNDO, GimpTextUndo))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_UNDO_CLASS</NAME>
#define GIMP_TEXT_UNDO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEXT_UNDO, GimpTextUndoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_UNDO</NAME>
#define GIMP_IS_TEXT_UNDO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT_UNDO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_UNDO_CLASS</NAME>
#define GIMP_IS_TEXT_UNDO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEXT_UNDO))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_UNDO_GET_CLASS</NAME>
#define GIMP_TEXT_UNDO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEXT_UNDO, GimpTextUndoClass))
</MACRO>
<STRUCT>
<NAME>GimpTextUndoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextUndo</NAME>
struct _GimpTextUndo
{
  GimpItemUndo      parent_instance;

  GimpText         *text;
  const GParamSpec *pspec;
  GValue           *value;
};
</STRUCT>
<STRUCT>
<NAME>GimpTextUndoClass</NAME>
struct _GimpTextUndoClass
{
  GimpItemClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_text_undo_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_BOX_MODE</NAME>
#define GIMP_TYPE_TEXT_BOX_MODE (gimp_text_box_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_text_box_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTextBoxMode</NAME>
typedef enum /*< pdb-skip >*/
{
  GIMP_TEXT_BOX_DYNAMIC,
  GIMP_TEXT_BOX_FIXED
} GimpTextBoxMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TEXT_DIRECTION</NAME>
#define GIMP_TYPE_TEXT_DIRECTION (gimp_text_direction_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_text_direction_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTextDirection</NAME>
typedef enum /*< pdb-skip >*/
{
  GIMP_TEXT_DIRECTION_LTR,   /*< desc="From left to right" >*/
  GIMP_TEXT_DIRECTION_RTL    /*< desc="From right to left" >*/
} GimpTextDirection;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TEXT_JUSTIFICATION</NAME>
#define GIMP_TYPE_TEXT_JUSTIFICATION (gimp_text_justification_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_text_justification_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTextJustification</NAME>
typedef enum /*< pdb-skip >*/
{
  GIMP_TEXT_JUSTIFY_LEFT,    /*< desc="Left justified"  >*/
  GIMP_TEXT_JUSTIFY_RIGHT,   /*< desc="Right justified" >*/
  GIMP_TEXT_JUSTIFY_CENTER,  /*< desc="Centered"        >*/
  GIMP_TEXT_JUSTIFY_FILL     /*< desc="Filled"          >*/
} GimpTextJustification;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TEXT_OUTLINE</NAME>
#define GIMP_TYPE_TEXT_OUTLINE (gimp_text_outline_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_text_outline_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTextOutline</NAME>
typedef enum /*< pdb-skip >*/
{
  GIMP_TEXT_OUTLINE_NONE,
  GIMP_TEXT_OUTLINE_STROKE_ONLY,
  GIMP_TEXT_OUTLINE_STROKE_FILL
} GimpTextOutline;
</ENUM>
<STRUCT>
<NAME>GimpFont</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFontList</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpText</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextLayout</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextUndo</NAME>
</STRUCT>
<FUNCTION>
<NAME>gimp_tools_init</NAME>
<RETURNS>void       </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_tools_exit</NAME>
<RETURNS>void       </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_tools_restore</NAME>
<RETURNS>void       </RETURNS>
Gimp      *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_tools_save</NAME>
<RETURNS>void       </RETURNS>
Gimp      *gimp,gboolean   save_tool_options,gboolean   always_save
</FUNCTION>
<FUNCTION>
<NAME>gimp_tools_clear</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp      *gimp,GError   **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_tools_get_default_order</NAME>
<RETURNS>GList    *</RETURNS>
Gimp      *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_AIRBRUSH_TOOL</NAME>
#define GIMP_TYPE_AIRBRUSH_TOOL            (gimp_airbrush_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_TOOL</NAME>
#define GIMP_AIRBRUSH_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_AIRBRUSH_TOOL, GimpAirbrushTool))
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_TOOL_CLASS</NAME>
#define GIMP_AIRBRUSH_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_AIRBRUSH_TOOL, GimpAirbrushToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_AIRBRUSH_TOOL</NAME>
#define GIMP_IS_AIRBRUSH_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_AIRBRUSH_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_AIRBRUSH_TOOL_CLASS</NAME>
#define GIMP_IS_AIRBRUSH_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_AIRBRUSH_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_AIRBRUSH_TOOL_GET_CLASS</NAME>
#define GIMP_AIRBRUSH_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_AIRBRUSH_TOOL, GimpAirbrushToolClass))
</MACRO>
<STRUCT>
<NAME>GimpAirbrushTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAirbrushToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAirbrushTool</NAME>
struct _GimpAirbrushTool
{
  GimpPaintbrushTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpAirbrushToolClass</NAME>
struct _GimpAirbrushToolClass
{
  GimpPaintbrushToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_airbrush_tool_register</NAME>
<RETURNS>void       </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_airbrush_tool_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BLEND_OPTIONS</NAME>
#define GIMP_TYPE_BLEND_OPTIONS            (gimp_blend_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BLEND_OPTIONS</NAME>
#define GIMP_BLEND_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BLEND_OPTIONS, GimpBlendOptions))
</MACRO>
<MACRO>
<NAME>GIMP_BLEND_OPTIONS_CLASS</NAME>
#define GIMP_BLEND_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BLEND_OPTIONS, GimpBlendOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BLEND_OPTIONS</NAME>
#define GIMP_IS_BLEND_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BLEND_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BLEND_OPTIONS_CLASS</NAME>
#define GIMP_IS_BLEND_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BLEND_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_BLEND_OPTIONS_GET_CLASS</NAME>
#define GIMP_BLEND_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BLEND_OPTIONS, GimpBlendOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpBlendOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpBlendOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpBlendOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpBlendOptions</NAME>
struct _GimpBlendOptions
{
  GimpPaintOptions  paint_options;

  gdouble           offset;
  GimpGradientType  gradient_type;

  gboolean          supersample;
  gint              supersample_depth;
  gdouble           supersample_threshold;

  gboolean          dither;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_blend_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_blend_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BLEND_TOOL</NAME>
#define GIMP_TYPE_BLEND_TOOL            (gimp_blend_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BLEND_TOOL</NAME>
#define GIMP_BLEND_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BLEND_TOOL, GimpBlendTool))
</MACRO>
<MACRO>
<NAME>GIMP_BLEND_TOOL_CLASS</NAME>
#define GIMP_BLEND_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BLEND_TOOL, GimpBlendToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BLEND_TOOL</NAME>
#define GIMP_IS_BLEND_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BLEND_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BLEND_TOOL_CLASS</NAME>
#define GIMP_IS_BLEND_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BLEND_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_BLEND_TOOL_GET_CLASS</NAME>
#define GIMP_BLEND_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BLEND_TOOL, GimpBlendToolClass))
</MACRO>
<STRUCT>
<NAME>GimpBlendTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBlendToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBlendTool</NAME>
struct _GimpBlendTool
{
  GimpDrawTool  parent_instance;

  gdouble       startx;      /*  starting x coord     */
  gdouble       starty;      /*  starting y coord     */
  gdouble       endx;        /*  ending x coord       */
  gdouble       endy;        /*  ending y coord       */
};
</STRUCT>
<STRUCT>
<NAME>GimpBlendToolClass</NAME>
struct _GimpBlendToolClass
{
  GimpDrawToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_blend_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_blend_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL</NAME>
#define GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL            (gimp_brightness_contrast_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRIGHTNESS_CONTRAST_TOOL</NAME>
#define GIMP_BRIGHTNESS_CONTRAST_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL, GimpBrightnessContrastTool))
</MACRO>
<MACRO>
<NAME>GIMP_BRIGHTNESS_CONTRAST_TOOL_CLASS</NAME>
#define GIMP_BRIGHTNESS_CONTRAST_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL, GimpBrightnessContrastToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRIGHTNESS_CONTRAST_TOOL</NAME>
#define GIMP_IS_BRIGHTNESS_CONTRAST_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRIGHTNESS_CONTRAST_TOOL_CLASS</NAME>
#define GIMP_IS_BRIGHTNESS_CONTRAST_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_BRIGHTNESS_CONTRAST_TOOL_GET_CLASS</NAME>
#define GIMP_BRIGHTNESS_CONTRAST_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRIGHTNESS_CONTRAST_TOOL, GimpBrightnessContrastToolClass))
</MACRO>
<STRUCT>
<NAME>GimpBrightnessContrastTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrightnessContrastToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrightnessContrastTool</NAME>
struct _GimpBrightnessContrastTool
{
  GimpImageMapTool  parent_instance;

  gdouble           x, y;
  gdouble           dx, dy;

  gdouble           brightness;
  gdouble           contrast;
  GimpLut          *lut;

  /*  dialog  */
  GtkAdjustment    *brightness_data;
  GtkAdjustment    *contrast_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpBrightnessContrastToolClass</NAME>
struct _GimpBrightnessContrastToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brightness_contrast_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_brightness_contrast_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BUCKET_FILL_OPTIONS</NAME>
#define GIMP_TYPE_BUCKET_FILL_OPTIONS            (gimp_bucket_fill_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BUCKET_FILL_OPTIONS</NAME>
#define GIMP_BUCKET_FILL_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BUCKET_FILL_OPTIONS, GimpBucketFillOptions))
</MACRO>
<MACRO>
<NAME>GIMP_BUCKET_FILL_OPTIONS_CLASS</NAME>
#define GIMP_BUCKET_FILL_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BUCKET_FILL_OPTIONS, GimpBucketFillOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUCKET_FILL_OPTIONS</NAME>
#define GIMP_IS_BUCKET_FILL_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BUCKET_FILL_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUCKET_FILL_OPTIONS_CLASS</NAME>
#define GIMP_IS_BUCKET_FILL_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BUCKET_FILL_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_BUCKET_FILL_OPTIONS_GET_CLASS</NAME>
#define GIMP_BUCKET_FILL_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BUCKET_FILL_OPTIONS, GimpBucketFillOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpBucketFillOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpBucketFillOptionsClass</NAME>
typedef struct _GimpPaintOptionsClass GimpBucketFillOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpBucketFillOptions</NAME>
struct _GimpBucketFillOptions
{
  GimpPaintOptions    paint_options;

  GimpBucketFillMode  fill_mode;
  gboolean            fill_selection;
  gboolean            fill_transparent;
  gboolean            sample_merged;
  gdouble             threshold;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_bucket_fill_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_bucket_fill_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BUCKET_FILL_TOOL</NAME>
#define GIMP_TYPE_BUCKET_FILL_TOOL            (gimp_bucket_fill_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BUCKET_FILL_TOOL</NAME>
#define GIMP_BUCKET_FILL_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BUCKET_FILL_TOOL, GimpBucketFillTool))
</MACRO>
<MACRO>
<NAME>GIMP_BUCKET_FILL_TOOL_CLASS</NAME>
#define GIMP_BUCKET_FILL_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BUCKET_FILL_TOOL, GimpBucketFillToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUCKET_FILL_TOOL</NAME>
#define GIMP_IS_BUCKET_FILL_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BUCKET_FILL_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUCKET_FILL_TOOL_CLASS</NAME>
#define GIMP_IS_BUCKET_FILL_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BUCKET_FILL_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_BUCKET_FILL_TOOL_GET_CLASS</NAME>
#define GIMP_BUCKET_FILL_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BUCKET_FILL_TOOL, GimpBucketFillToolClass))
</MACRO>
<STRUCT>
<NAME>GimpBucketFillTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBucketFillToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBucketFillTool</NAME>
struct _GimpBucketFillTool
{
  GimpTool  parent_instance;

  gint      target_x;  /*  starting x coord  */
  gint      target_y;  /*  starting y coord  */
};
</STRUCT>
<STRUCT>
<NAME>GimpBucketFillToolClass</NAME>
struct _GimpBucketFillToolClass
{
  GimpToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_bucket_fill_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_bucket_fill_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BY_COLOR_SELECT_TOOL</NAME>
#define GIMP_TYPE_BY_COLOR_SELECT_TOOL            (gimp_by_color_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BY_COLOR_SELECT_TOOL</NAME>
#define GIMP_BY_COLOR_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BY_COLOR_SELECT_TOOL, GimpByColorSelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_BY_COLOR_SELECT_TOOL_CLASS</NAME>
#define GIMP_BY_COLOR_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BY_COLOR_SELECT_TOOL, GimpByColorSelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BY_COLOR_SELECT_TOOL</NAME>
#define GIMP_IS_BY_COLOR_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BY_COLOR_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BY_COLOR_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_BY_COLOR_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BY_COLOR_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_BY_COLOR_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_BY_COLOR_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BY_COLOR_SELECT_TOOL, GimpByColorSelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpByColorSelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpByColorSelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpByColorSelectTool</NAME>
struct _GimpByColorSelectTool
{
  GimpSelectionTool parent_instance;

  gint              x, y;  /*  Point from which to execute seed fill  */
};
</STRUCT>
<STRUCT>
<NAME>GimpByColorSelectToolClass</NAME>
struct _GimpByColorSelectToolClass
{
  GimpSelectionToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_by_color_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_by_color_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CLONE_TOOL</NAME>
#define GIMP_TYPE_CLONE_TOOL            (gimp_clone_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_TOOL</NAME>
#define GIMP_CLONE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CLONE_TOOL, GimpCloneTool))
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_TOOL_CLASS</NAME>
#define GIMP_CLONE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CLONE_TOOL, GimpCloneToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CLONE_TOOL</NAME>
#define GIMP_IS_CLONE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CLONE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CLONE_TOOL_CLASS</NAME>
#define GIMP_IS_CLONE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CLONE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_CLONE_TOOL_GET_CLASS</NAME>
#define GIMP_CLONE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CLONE_TOOL, GimpCloneToolClass))
</MACRO>
<STRUCT>
<NAME>GimpCloneTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCloneToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCloneTool</NAME>
struct _GimpCloneTool
{
  GimpPaintTool parent_instance;
  GimpDisplay  *src_display;
};
</STRUCT>
<STRUCT>
<NAME>GimpCloneToolClass</NAME>
struct _GimpCloneToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_clone_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_clone_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_BALANCE_TOOL</NAME>
#define GIMP_TYPE_COLOR_BALANCE_TOOL            (gimp_color_balance_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BALANCE_TOOL</NAME>
#define GIMP_COLOR_BALANCE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_BALANCE_TOOL, GimpColorBalanceTool))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BALANCE_TOOL_CLASS</NAME>
#define GIMP_COLOR_BALANCE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_BALANCE_TOOL, GimpColorBalanceToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_BALANCE_TOOL</NAME>
#define GIMP_IS_COLOR_BALANCE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_BALANCE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BALANCE_TOOL_CLASS</NAME>
#define GIMP_COLOR_BALANCE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_BALANCE_TOOL, GimpColorBalanceToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_BALANCE_TOOL_CLASS</NAME>
#define GIMP_IS_COLOR_BALANCE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_BALANCE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BALANCE_TOOL_GET_CLASS</NAME>
#define GIMP_COLOR_BALANCE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_BALANCE_TOOL, GimpColorBalanceToolClass))
</MACRO>
<STRUCT>
<NAME>GimpColorBalanceTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorBalanceToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorBalanceTool</NAME>
struct _GimpColorBalanceTool
{
  GimpImageMapTool  parent_instance;

  ColorBalance     *color_balance;

  /*  dialog  */
  GimpTransferMode  transfer_mode;
  GtkAdjustment    *cyan_red_adj;
  GtkAdjustment    *magenta_green_adj;
  GtkAdjustment    *yellow_blue_adj;
  GtkWidget        *preserve_toggle;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorBalanceToolClass</NAME>
struct _GimpColorBalanceToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_balance_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_balance_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLORIZE_TOOL</NAME>
#define GIMP_TYPE_COLORIZE_TOOL            (gimp_colorize_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLORIZE_TOOL</NAME>
#define GIMP_COLORIZE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLORIZE_TOOL, GimpColorizeTool))
</MACRO>
<MACRO>
<NAME>GIMP_COLORIZE_TOOL_CLASS</NAME>
#define GIMP_COLORIZE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLORIZE_TOOL, GimpColorizeToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLORIZE_TOOL</NAME>
#define GIMP_IS_COLORIZE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLORIZE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLORIZE_TOOL_CLASS</NAME>
#define GIMP_IS_COLORIZE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLORIZE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_COLORIZE_TOOL_GET_CLASS</NAME>
#define GIMP_COLORIZE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLORIZE_TOOL, GimpColorizeToolClass))
</MACRO>
<STRUCT>
<NAME>GimpColorizeTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorizeToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorizeTool</NAME>
struct _GimpColorizeTool
{
  GimpImageMapTool  parent_instance;

  Colorize         *colorize;

  /*  dialog  */
  GtkAdjustment    *hue_data;
  GtkAdjustment    *saturation_data;
  GtkAdjustment    *lightness_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorizeToolClass</NAME>
struct _GimpColorizeToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_colorize_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_colorize_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_OPTIONS</NAME>
#define GIMP_TYPE_COLOR_OPTIONS            (gimp_color_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_OPTIONS</NAME>
#define GIMP_COLOR_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_OPTIONS, GimpColorOptions))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_OPTIONS_CLASS</NAME>
#define GIMP_COLOR_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_OPTIONS, GimpColorOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_OPTIONS</NAME>
#define GIMP_IS_COLOR_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_OPTIONS_CLASS</NAME>
#define GIMP_IS_COLOR_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_OPTIONS_GET_CLASS</NAME>
#define GIMP_COLOR_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_OPTIONS, GimpColorOptionsClass))
</MACRO>
<TYPEDEF>
<NAME>GimpColorOptionsClass</NAME>
typedef  GimpImageMapOptionsClass  GimpColorOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpColorOptions</NAME>
struct _GimpColorOptions
{
  GimpImageMapOptions  parent_instance;

  gboolean             sample_merged;
  gboolean             sample_average;
  gdouble              average_radius;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_PICKER_OPTIONS</NAME>
#define GIMP_TYPE_COLOR_PICKER_OPTIONS            (gimp_color_picker_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PICKER_OPTIONS</NAME>
#define GIMP_COLOR_PICKER_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_PICKER_OPTIONS, GimpColorPickerOptions))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PICKER_OPTIONS_CLASS</NAME>
#define GIMP_COLOR_PICKER_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_PICKER_OPTIONS, GimpColorPickerOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_PICKER_OPTIONS</NAME>
#define GIMP_IS_COLOR_PICKER_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_PICKER_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_PICKER_OPTIONS_CLASS</NAME>
#define GIMP_IS_COLOR_PICKER_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_PICKER_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PICKER_OPTIONS_GET_CLASS</NAME>
#define GIMP_COLOR_PICKER_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_PICKER_OPTIONS, GimpColorPickerOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpColorPickerOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpColorPickerOptionsClass</NAME>
typedef struct _GimpToolOptionsClass   GimpColorPickerOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpColorPickerOptions</NAME>
struct _GimpColorPickerOptions
{
  GimpColorOptions   parent_instance;

  GimpColorPickMode  pick_mode;
  gboolean           add_to_palette; /* unused */
  gboolean           use_info_window;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_picker_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_picker_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_PICKER_TOOL</NAME>
#define GIMP_TYPE_COLOR_PICKER_TOOL            (gimp_color_picker_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PICKER_TOOL</NAME>
#define GIMP_COLOR_PICKER_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_PICKER_TOOL, GimpColorPickerTool))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PICKER_TOOL_CLASS</NAME>
#define GIMP_COLOR_PICKER_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_PICKER_TOOL, GimpColorPickerToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_PICKER_TOOL</NAME>
#define GIMP_IS_COLOR_PICKER_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_PICKER_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_PICKER_TOOL_CLASS</NAME>
#define GIMP_IS_COLOR_PICKER_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_PICKER_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PICKER_TOOL_GET_CLASS</NAME>
#define GIMP_COLOR_PICKER_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_PICKER_TOOL, GimpColorPickerToolClass))
</MACRO>
<STRUCT>
<NAME>GimpColorPickerTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorPickerToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorPickerTool</NAME>
struct _GimpColorPickerTool
{
  GimpColorTool  parent_instance;

  GtkWidget     *dialog;
  GtkWidget     *color_area;
  GtkWidget     *color_frame1;
  GtkWidget     *color_frame2;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorPickerToolClass</NAME>
struct _GimpColorPickerToolClass
{
  GimpColorToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_picker_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_picker_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_TOOL</NAME>
#define GIMP_TYPE_COLOR_TOOL            (gimp_color_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_TOOL</NAME>
#define GIMP_COLOR_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_TOOL, GimpColorTool))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_TOOL_CLASS</NAME>
#define GIMP_COLOR_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_TOOL, GimpColorToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_TOOL</NAME>
#define GIMP_IS_COLOR_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_TOOL_CLASS</NAME>
#define GIMP_IS_COLOR_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_TOOL_GET_CLASS</NAME>
#define GIMP_COLOR_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_TOOL, GimpColorToolClass))
</MACRO>
<STRUCT>
<NAME>GimpColorToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorTool</NAME>
struct _GimpColorTool
{
  GimpDrawTool       parent_instance;

  gboolean           enabled;
  gint               center_x;
  gint               center_y;
  GimpColorPickMode  pick_mode;

  GimpColorOptions  *options;

  GimpSamplePoint   *sample_point;
  gboolean           moving_sample_point;
  gint               sample_point_x;
  gint               sample_point_y;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorToolClass</NAME>
struct _GimpColorToolClass
{
  GimpDrawToolClass  parent_class;

  /*  virtual functions  */
  gboolean (* pick)   (GimpColorTool      *tool,
                       gint                x,
                       gint                y,
                       GimpImageType      *sample_type,
                       GimpRGB            *color,
                       gint               *color_index);

  /*  signals  */
  void     (* picked) (GimpColorTool      *tool,
                       GimpColorPickState  pick_state,
                       GimpImageType       sample_type,
                       GimpRGB            *color,
                       gint                color_index);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_tool_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_tool_enable</NAME>
<RETURNS>void       </RETURNS>
GimpColorTool    *color_tool,GimpColorOptions *options
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_tool_disable</NAME>
<RETURNS>void       </RETURNS>
GimpColorTool    *color_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_tool_is_enabled</NAME>
<RETURNS>gboolean   </RETURNS>
GimpColorTool    *color_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_tool_start_sample_point</NAME>
<RETURNS>void       </RETURNS>
GimpTool         *tool,GimpDisplay      *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONVOLVE_TOOL</NAME>
#define GIMP_TYPE_CONVOLVE_TOOL            (gimp_convolve_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_TOOL</NAME>
#define GIMP_CONVOLVE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONVOLVE_TOOL, GimpConvolveTool))
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_TOOL_CLASS</NAME>
#define GIMP_CONVOLVE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONVOLVE_TOOL, GimpConvolveToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONVOLVE_TOOL</NAME>
#define GIMP_IS_CONVOLVE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONVOLVE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONVOLVE_TOOL_CLASS</NAME>
#define GIMP_IS_CONVOLVE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONVOLVE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_CONVOLVE_TOOL_GET_CLASS</NAME>
#define GIMP_CONVOLVE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONVOLVE_TOOL, GimpConvolveToolClass))
</MACRO>
<STRUCT>
<NAME>GimpConvolveTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpConvolveToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpConvolveTool</NAME>
struct _GimpConvolveTool
{
  GimpPaintTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpConvolveToolClass</NAME>
struct _GimpConvolveToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_convolve_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_convolve_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CROP_OPTIONS</NAME>
#define GIMP_TYPE_CROP_OPTIONS            (gimp_crop_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CROP_OPTIONS</NAME>
#define GIMP_CROP_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CROP_OPTIONS, GimpCropOptions))
</MACRO>
<MACRO>
<NAME>GIMP_CROP_OPTIONS_CLASS</NAME>
#define GIMP_CROP_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CROP_OPTIONS, GimpCropOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CROP_OPTIONS</NAME>
#define GIMP_IS_CROP_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CROP_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CROP_OPTIONS_CLASS</NAME>
#define GIMP_IS_CROP_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CROP_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_CROP_OPTIONS_GET_CLASS</NAME>
#define GIMP_CROP_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CROP_OPTIONS, GimpCropOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpCropOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpCropOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpCropOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpCropOptions</NAME>
struct _GimpCropOptions
{
  GimpToolOptions  parent_instence;

  gboolean         layer_only;
  GimpCropMode     crop_mode;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_crop_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_crop_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CROP_TOOL</NAME>
#define GIMP_TYPE_CROP_TOOL            (gimp_crop_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CROP_TOOL</NAME>
#define GIMP_CROP_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CROP_TOOL, GimpCropTool))
</MACRO>
<MACRO>
<NAME>GIMP_CROP_TOOL_CLASS</NAME>
#define GIMP_CROP_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CROP_TOOL, GimpCropToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CROP_TOOL</NAME>
#define GIMP_IS_CROP_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CROP_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CROP_TOOL_CLASS</NAME>
#define GIMP_IS_CROP_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CROP_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_CROP_TOOL_GET_CLASS</NAME>
#define GIMP_CROP_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CROP_TOOL, GimpCropToolClass))
</MACRO>
<STRUCT>
<NAME>GimpCropTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCropToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCropTool</NAME>
struct _GimpCropTool
{
  GimpDrawTool  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpCropToolClass</NAME>
struct _GimpCropToolClass
{
  GimpDrawToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_crop_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_crop_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CURVES_TOOL</NAME>
#define GIMP_TYPE_CURVES_TOOL            (gimp_curves_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CURVES_TOOL</NAME>
#define GIMP_CURVES_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CURVES_TOOL, GimpCurvesTool))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CURVES_TOOL</NAME>
#define GIMP_IS_CURVES_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CURVES_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_CURVES_TOOL_CLASS</NAME>
#define GIMP_CURVES_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CURVES_TOOL, GimpCurvesToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CURVES_TOOL_CLASS</NAME>
#define GIMP_IS_CURVES_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CURVES_TOOL))
</MACRO>
<STRUCT>
<NAME>GimpCurvesTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCurvesToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCurvesTool</NAME>
struct _GimpCurvesTool
{
  GimpImageMapTool      parent_instance;

  Curves               *curves;
  GimpLut              *lut;

  /* dialog */
  gboolean              color;
  gboolean              alpha;
  GimpHistogramChannel  channel;

  gint                  selected;
  gint                  last;
  gint                  leftmost;
  gint                  rightmost;
  gint                  col_value[5];
  gboolean              grabbed;

  GimpHistogram        *hist;

  GtkWidget            *channel_menu;
  GtkWidget            *xrange;
  GtkWidget            *yrange;
  GtkWidget            *graph;
  GtkWidget            *curve_type;

  gint                  cursor_x;
  gint                  cursor_y;
  PangoLayout          *xpos_layout;
  PangoLayout          *cursor_layout;
  PangoRectangle        cursor_rect;
};
</STRUCT>
<STRUCT>
<NAME>GimpCurvesToolClass</NAME>
struct _GimpCurvesToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_curves_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_curves_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DODGE_BURN_TOOL</NAME>
#define GIMP_TYPE_DODGE_BURN_TOOL            (gimp_dodge_burn_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN_TOOL</NAME>
#define GIMP_DODGE_BURN_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DODGE_BURN_TOOL, GimpDodgeBurnTool))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DODGE_BURN_TOOL</NAME>
#define GIMP_IS_DODGE_BURN_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DODGE_BURN_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_DODGE_BURN_TOOL_CLASS</NAME>
#define GIMP_DODGE_BURN_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DODGE_BURN_TOOL, GimpDodgeBurnToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DODGE_BURN_TOOL_CLASS</NAME>
#define GIMP_IS_DODGE_BURN_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DODGE_BURN_TOOL))
</MACRO>
<STRUCT>
<NAME>GimpDodgeBurnTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDodgeBurnToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDodgeBurnTool</NAME>
struct _GimpDodgeBurnTool
{
  GimpPaintTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpDodgeBurnToolClass</NAME>
struct _GimpDodgeBurnToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dodge_burn_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dodge_burn_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpHandleType</NAME>
typedef enum
{
  GIMP_HANDLE_SQUARE,
  GIMP_HANDLE_FILLED_SQUARE,
  GIMP_HANDLE_CIRCLE,
  GIMP_HANDLE_FILLED_CIRCLE,
  GIMP_HANDLE_CROSS
} GimpHandleType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_DRAW_TOOL</NAME>
#define GIMP_TYPE_DRAW_TOOL            (gimp_draw_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DRAW_TOOL</NAME>
#define GIMP_DRAW_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DRAW_TOOL, GimpDrawTool))
</MACRO>
<MACRO>
<NAME>GIMP_DRAW_TOOL_CLASS</NAME>
#define GIMP_DRAW_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DRAW_TOOL, GimpDrawToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DRAW_TOOL</NAME>
#define GIMP_IS_DRAW_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DRAW_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DRAW_TOOL_CLASS</NAME>
#define GIMP_IS_DRAW_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DRAW_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_DRAW_TOOL_GET_CLASS</NAME>
#define GIMP_DRAW_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DRAW_TOOL, GimpDrawToolClass))
</MACRO>
<STRUCT>
<NAME>GimpDrawToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDrawTool</NAME>
struct _GimpDrawTool
{
  GimpTool      parent_instance;

  GimpDisplay  *display;      /*  The display we are drawing to (may be
                               *  a different one than tool->display)
                               */

  gint          paused_count; /*  count to keep track of multiple pauses */

  GList        *vectors;      /*  GimpVectors to render                  */
  GimpMatrix3  *transform;    /*  Transformation matrix fof the vectors  */
};
</STRUCT>
<STRUCT>
<NAME>GimpDrawToolClass</NAME>
struct _GimpDrawToolClass
{
  GimpToolClass   parent_class;

  /*  virtual function  */

  void (* draw) (GimpDrawTool *draw_tool);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_draw_tool_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_start</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_stop</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_is_active</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDrawTool     *draw_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_pause</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_resume</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_set_vectors</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,GList            *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_set_transform</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,GimpMatrix3      *transform
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_calc_distance</NAME>
<RETURNS>gdouble    </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display,gdouble           x1,gdouble           y1,gdouble           x2,gdouble           y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_in_radius</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display,gdouble           x1,gdouble           y1,gdouble           x2,gdouble           y2,gint              radius
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_line</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gdouble           x1,gdouble           y1,gdouble           x2,gdouble           y2,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_dashed_line</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gdouble           x1,gdouble           y1,gdouble           x2,gdouble           y2,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_rectangle</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gboolean          filled,gdouble           x,gdouble           y,gdouble           width,gdouble           height,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_arc</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gboolean          filled,gdouble           x,gdouble           y,gdouble           width,gdouble           height,gint              angle1,gint              angle2,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_rectangle_by_anchor</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gboolean          filled,gdouble           x,gdouble           y,gint              width,gint              height,GtkAnchorType     anchor,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_arc_by_anchor</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gboolean          filled,gdouble           x,gdouble           y,gint              radius_x,gint              radius_y,gint              angle1,gint              angle2,GtkAnchorType     anchor,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_cross_by_anchor</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,gdouble           x,gdouble           y,gint              width,gint              height,GtkAnchorType     anchor,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_handle</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,GimpHandleType    type,gdouble           x,gdouble           y,gint              width,gint              height,GtkAnchorType     anchor,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_on_handle</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display,gdouble           x,gdouble           y,GimpHandleType    type,gdouble           handle_x,gdouble           handle_y,gint              width,gint              height,GtkAnchorType     anchor,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_on_vectors_handle</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display,GimpVectors      *vectors,const GimpCoords *coord,gint              width,gint              height,GimpAnchorType    preferred,gboolean          exclusive,GimpAnchor      **ret_anchor,GimpStroke      **ret_stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_on_vectors_curve</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display,GimpVectors      *vectors,const GimpCoords *coord,gint              width,gint              height,GimpCoords       *ret_coords,gdouble          *ret_pos,GimpAnchor      **ret_segment_start,GimpAnchor      **ret_segment_end,GimpStroke      **ret_stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_on_vectors</NAME>
<RETURNS>gboolean   </RETURNS>
GimpDrawTool     *draw_tool,GimpDisplay      *display,const GimpCoords *coord,gint              width,gint              height,GimpCoords       *ret_coords,gdouble          *ret_pos,GimpAnchor      **ret_segment_start,GimpAnchor      **ret_segment_end,GimpStroke      **ret_stroke,GimpVectors     **ret_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_lines</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,const gdouble    *points,gint              n_points,gboolean          filled,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_strokes</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,const GimpCoords *points,gint              n_points,gboolean          filled,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_draw_tool_draw_boundary</NAME>
<RETURNS>void       </RETURNS>
GimpDrawTool     *draw_tool,const BoundSeg   *bound_segs,gint              n_bound_segs,gdouble           offset_x,gdouble           offset_y,gboolean          use_offsets
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_selection_tool_start</NAME>
<RETURNS>void       </RETURNS>
GimpTool          *parent_tool,GimpDisplay       *display,GimpCoords        *coords,GimpTranslateMode  edit_mode,gboolean           propagate_release
</FUNCTION>
<FUNCTION>
<NAME>gimp_edit_selection_tool_key_press</NAME>
<RETURNS>gboolean   </RETURNS>
GimpTool          *tool,GdkEventKey       *kevent,GimpDisplay       *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ELLIPSE_SELECT_TOOL</NAME>
#define GIMP_TYPE_ELLIPSE_SELECT_TOOL            (gimp_ellipse_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ELLIPSE_SELECT_TOOL</NAME>
#define GIMP_ELLIPSE_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ELLIPSE_SELECT_TOOL, GimpEllipseSelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_ELLIPSE_SELECT_TOOL_CLASS</NAME>
#define GIMP_ELLIPSE_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ELLIPSE_SELECT_TOOL, GimpEllipseSelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ELLIPSE_SELECT_TOOL</NAME>
#define GIMP_IS_ELLIPSE_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ELLIPSE_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ELLIPSE_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_ELLIPSE_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ELLIPSE_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_ELLIPSE_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_ELLIPSE_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ELLIPSE_SELECT_TOOL, GimpEllipseSelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpEllipseSelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEllipseSelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEllipseSelectTool</NAME>
struct _GimpEllipseSelectTool
{
  GimpNewRectSelectTool  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpEllipseSelectToolClass</NAME>
struct _GimpEllipseSelectToolClass
{
  GimpNewRectSelectToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_ellipse_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_ellipse_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ERASER_TOOL</NAME>
#define GIMP_TYPE_ERASER_TOOL            (gimp_eraser_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_TOOL</NAME>
#define GIMP_ERASER_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ERASER_TOOL, GimpEraserTool))
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_TOOL_CLASS</NAME>
#define GIMP_ERASER_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ERASER_TOOL, GimpEraserToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERASER_TOOL</NAME>
#define GIMP_IS_ERASER_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ERASER_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERASER_TOOL_CLASS</NAME>
#define GIMP_IS_ERASER_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ERASER_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_ERASER_TOOL_GET_CLASS</NAME>
#define GIMP_ERASER_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ERASER_TOOL, GimpEraserToolClass))
</MACRO>
<STRUCT>
<NAME>GimpEraserTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEraserToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEraserTool</NAME>
struct _GimpEraserTool
{
  GimpPaintTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpEraserToolClass</NAME>
struct _GimpEraserToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_eraser_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_eraser_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FLIP_OPTIONS</NAME>
#define GIMP_TYPE_FLIP_OPTIONS            (gimp_flip_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FLIP_OPTIONS</NAME>
#define GIMP_FLIP_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FLIP_OPTIONS, GimpFlipOptions))
</MACRO>
<MACRO>
<NAME>GIMP_FLIP_OPTIONS_CLASS</NAME>
#define GIMP_FLIP_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FLIP_OPTIONS, GimpFlipOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FLIP_OPTIONS</NAME>
#define GIMP_IS_FLIP_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FLIP_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FLIP_OPTIONS_CLASS</NAME>
#define GIMP_IS_FLIP_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FLIP_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_FLIP_OPTIONS_GET_CLASS</NAME>
#define GIMP_FLIP_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FLIP_OPTIONS, GimpFlipOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpFlipOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpFlipOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpFlipOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpFlipOptions</NAME>
struct _GimpFlipOptions
{
  GimpTransformOptions  parent_instance;

  GimpOrientationType   flip_type;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_flip_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_flip_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FLIP_TOOL</NAME>
#define GIMP_TYPE_FLIP_TOOL            (gimp_flip_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FLIP_TOOL</NAME>
#define GIMP_FLIP_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FLIP_TOOL, GimpFlipTool))
</MACRO>
<MACRO>
<NAME>GIMP_FLIP_TOOL_CLASS</NAME>
#define GIMP_FLIP_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FLIP_TOOL, GimpFlipToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FLIP_TOOL</NAME>
#define GIMP_IS_FLIP_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FLIP_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FLIP_TOOL_CLASS</NAME>
#define GIMP_IS_FLIP_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FLIP_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_FLIP_TOOL_GET_CLASS</NAME>
#define GIMP_FLIP_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FLIP_TOOL, GimpFlipToolClass))
</MACRO>
<STRUCT>
<NAME>GimpFlipTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFlipToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFlipTool</NAME>
struct _GimpFlipTool
{
  GimpTransformTool  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpFlipToolClass</NAME>
struct _GimpFlipToolClass
{
  GimpTransformToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_flip_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_flip_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FREE_SELECT_TOOL</NAME>
#define GIMP_TYPE_FREE_SELECT_TOOL            (gimp_free_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FREE_SELECT_TOOL</NAME>
#define GIMP_FREE_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FREE_SELECT_TOOL, GimpFreeSelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_FREE_SELECT_TOOL_CLASS</NAME>
#define GIMP_FREE_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FREE_SELECT_TOOL, GimpFreeSelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FREE_SELECT_TOOL</NAME>
#define GIMP_IS_FREE_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FREE_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FREE_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_FREE_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FREE_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_FREE_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_FREE_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FREE_SELECT_TOOL, GimpFreeSelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpFreeSelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFreeSelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFreeSelectTool</NAME>
struct _GimpFreeSelectTool
{
  GimpSelectionTool  parent_instance;

  GimpCoords         last_coords;

  GimpVector2       *points;
  gint               num_points;
  gint               max_segs;
};
</STRUCT>
<STRUCT>
<NAME>GimpFreeSelectToolClass</NAME>
struct _GimpFreeSelectToolClass
{
  GimpSelectionToolClass  parent_class;

  /*  virtual function  */

  void (* select) (GimpFreeSelectTool *free_select_tool,
                   GimpDisplay        *display);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_free_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_free_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_free_select_tool_select</NAME>
<RETURNS>void    </RETURNS>
GimpFreeSelectTool       *free_sel,GimpDisplay              *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FUZZY_SELECT_TOOL</NAME>
#define GIMP_TYPE_FUZZY_SELECT_TOOL            (gimp_fuzzy_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FUZZY_SELECT_TOOL</NAME>
#define GIMP_FUZZY_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FUZZY_SELECT_TOOL, GimpFuzzySelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_FUZZY_SELECT_TOOL_CLASS</NAME>
#define GIMP_FUZZY_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FUZZY_SELECT_TOOL, GimpFuzzySelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FUZZY_SELECT_TOOL</NAME>
#define GIMP_IS_FUZZY_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FUZZY_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FUZZY_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_FUZZY_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FUZZY_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_FUZZY_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_FUZZY_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FUZZY_SELECT_TOOL, GimpFuzzySelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpFuzzySelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFuzzySelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFuzzySelectTool</NAME>
struct _GimpFuzzySelectTool
{
  GimpSelectionTool  parent_instance;

  gint         x, y;             /*  Point from which to execute seed fill   */
  gint         first_x;          /*                                          */
  gint         first_y;          /*  variables to keep track of sensitivity  */
  gdouble      first_threshold;  /*  initial value of threshold slider       */

  GimpChannel *fuzzy_mask;

  /*  Segments which make up the fuzzy selection boundary  */
  GdkSegment  *segs;
  gint         num_segs;
};
</STRUCT>
<STRUCT>
<NAME>GimpFuzzySelectToolClass</NAME>
struct _GimpFuzzySelectToolClass
{
  GimpSelectionToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_fuzzy_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_fuzzy_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_HISTOGRAM_OPTIONS</NAME>
#define GIMP_TYPE_HISTOGRAM_OPTIONS            (gimp_histogram_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_OPTIONS</NAME>
#define GIMP_HISTOGRAM_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_HISTOGRAM_OPTIONS, GimpHistogramOptions))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_OPTIONS_CLASS</NAME>
#define GIMP_HISTOGRAM_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_HISTOGRAM_OPTIONS, GimpHistogramOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_OPTIONS</NAME>
#define GIMP_IS_HISTOGRAM_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_HISTOGRAM_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_OPTIONS_CLASS</NAME>
#define GIMP_IS_HISTOGRAM_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_HISTOGRAM_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_OPTIONS_GET_CLASS</NAME>
#define GIMP_HISTOGRAM_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_HISTOGRAM_OPTIONS, GimpHistogramOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpHistogramOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpHistogramOptionsClass</NAME>
typedef         GimpColorOptionsClass GimpHistogramOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpHistogramOptions</NAME>
struct _GimpHistogramOptions
{
  GimpColorOptions    parent_instance;

  GimpHistogramScale  scale;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_histogram_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions      *tool_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_options_connect_view</NAME>
<RETURNS>void        </RETURNS>
GimpHistogramOptions *options,GimpHistogramView    *view
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_HUE_SATURATION_TOOL</NAME>
#define GIMP_TYPE_HUE_SATURATION_TOOL            (gimp_hue_saturation_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_HUE_SATURATION_TOOL</NAME>
#define GIMP_HUE_SATURATION_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_HUE_SATURATION_TOOL, GimpHueSaturationTool))
</MACRO>
<MACRO>
<NAME>GIMP_HUE_SATURATION_TOOL_CLASS</NAME>
#define GIMP_HUE_SATURATION_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_HUE_SATURATION_TOOL, GimpHueSaturationToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HUE_SATURATION_TOOL</NAME>
#define GIMP_IS_HUE_SATURATION_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_HUE_SATURATION_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HUE_SATURATION_TOOL_CLASS</NAME>
#define GIMP_IS_HUE_SATURATION_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_HUE_SATURATION_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_HUE_SATURATION_TOOL_GET_CLASS</NAME>
#define GIMP_HUE_SATURATION_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_HUE_SATURATION_TOOL, GimpHueSaturationToolClass))
</MACRO>
<STRUCT>
<NAME>GimpHueSaturationTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHueSaturationToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHueSaturationTool</NAME>
struct _GimpHueSaturationTool
{
  GimpImageMapTool  parent_instance;

  HueSaturation    *hue_saturation;

  /*  dialog  */
  GimpHueRange      hue_partition;
  GtkWidget        *hue_partition_da[6];
  GtkAdjustment    *overlap_data;
  GtkAdjustment    *hue_data;
  GtkAdjustment    *lightness_data;
  GtkAdjustment    *saturation_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpHueSaturationToolClass</NAME>
struct _GimpHueSaturationToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_hue_saturation_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_hue_saturation_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_MAP_OPTIONS</NAME>
#define GIMP_TYPE_IMAGE_MAP_OPTIONS            (gimp_image_map_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_OPTIONS</NAME>
#define GIMP_IMAGE_MAP_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_MAP_OPTIONS, GimpImageMapOptions))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_OPTIONS_CLASS</NAME>
#define GIMP_IMAGE_MAP_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_MAP_OPTIONS, GimpImageMapOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_MAP_OPTIONS</NAME>
#define GIMP_IS_IMAGE_MAP_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_MAP_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_MAP_OPTIONS_CLASS</NAME>
#define GIMP_IS_IMAGE_MAP_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_MAP_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_OPTIONS_GET_CLASS</NAME>
#define GIMP_IMAGE_MAP_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_MAP_OPTIONS, GimpImageMapOptionsClass))
</MACRO>
<TYPEDEF>
<NAME>GimpImageMapOptionsClass</NAME>
typedef struct _GimpToolOptionsClass  GimpImageMapOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpImageMapOptions</NAME>
struct _GimpImageMapOptions
{
  GimpToolOptions  parent_instance;

  gboolean         preview;
  gchar           *settings;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_map_options_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_MAP_TOOL</NAME>
#define GIMP_TYPE_IMAGE_MAP_TOOL            (gimp_image_map_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_TOOL</NAME>
#define GIMP_IMAGE_MAP_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_MAP_TOOL, GimpImageMapTool))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_TOOL_CLASS</NAME>
#define GIMP_IMAGE_MAP_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_MAP_TOOL, GimpImageMapToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_MAP_TOOL</NAME>
#define GIMP_IS_IMAGE_MAP_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_MAP_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_MAP_TOOL_CLASS</NAME>
#define GIMP_IS_IMAGE_MAP_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_MAP_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_MAP_TOOL_GET_CLASS</NAME>
#define GIMP_IMAGE_MAP_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_MAP_TOOL, GimpImageMapToolClass))
</MACRO>
<STRUCT>
<NAME>GimpImageMapToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageMapTool</NAME>
struct _GimpImageMapTool
{
  GimpColorTool  parent_instance;

  GimpDrawable  *drawable;
  GimpImageMap  *image_map;

  /* dialog */
  GtkWidget     *shell;
  GtkWidget     *main_vbox;
  GtkWidget     *load_button;
  GtkWidget     *save_button;

  /* settings file dialog */
  GtkWidget     *settings_dialog;
};
</STRUCT>
<STRUCT>
<NAME>GimpImageMapToolClass</NAME>
struct _GimpImageMapToolClass
{
  GimpColorToolClass  parent_class;

  const gchar        *shell_desc;
  const gchar        *settings_name;
  const gchar        *load_button_tip;
  const gchar        *load_dialog_title;
  const gchar        *save_button_tip;
  const gchar        *save_dialog_title;

  /* virtual functions */
  void     (* map)           (GimpImageMapTool *image_map_tool);
  void     (* dialog)        (GimpImageMapTool *image_map_tool);
  void     (* reset)         (GimpImageMapTool *image_map_tool);

  gboolean (* settings_load) (GimpImageMapTool *image_map_tool,
                              gpointer          file);
  gboolean (* settings_save) (GimpImageMapTool *image_map_tool,
                              gpointer          file);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_map_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_map_tool_preview</NAME>
<RETURNS>void    </RETURNS>
GimpImageMapTool *image_map_tool
</FUNCTION>
<FUNCTION>
<NAME>gimp_ink_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_INK_TOOL</NAME>
#define GIMP_TYPE_INK_TOOL            (gimp_ink_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_INK_TOOL</NAME>
#define GIMP_INK_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_INK_TOOL, GimpInkTool))
</MACRO>
<MACRO>
<NAME>GIMP_INK_TOOL_CLASS</NAME>
#define GIMP_INK_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_INK_TOOL, GimpInkToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INK_TOOL</NAME>
#define GIMP_IS_INK_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_INK_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_INK_TOOL_CLASS</NAME>
#define GIMP_IS_INK_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_INK_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_INK_TOOL_GET_CLASS</NAME>
#define GIMP_INK_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_INK_TOOL, GimpInkToolClass))
</MACRO>
<STRUCT>
<NAME>GimpInkTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpInkToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpInkTool</NAME>
struct _GimpInkTool
{
  GimpPaintTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpInkToolClass</NAME>
struct _GimpInkToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_ink_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_ink_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>IscissorsState</NAME>
typedef enum
{
  NO_ACTION,
  SEED_PLACEMENT,
  SEED_ADJUSTMENT,
  WAITING
} IscissorsState;
</ENUM>
<ENUM>
<NAME>IscissorsDraw</NAME>
typedef enum
{
  DRAW_NOTHING      = 0x0,
  DRAW_CURRENT_SEED = 0x1,
  DRAW_CURVE        = 0x2,
  DRAW_ACTIVE_CURVE = 0x4,
  DRAW_LIVEWIRE     = 0x8
} IscissorsDraw;
</ENUM>
<ENUM>
<NAME>IscissorsOps</NAME>
typedef enum
{
  ISCISSORS_OP_NONE,
  ISCISSORS_OP_SELECT,
  ISCISSORS_OP_MOVE_POINT,
  ISCISSORS_OP_ADD_POINT,
  ISCISSORS_OP_IMPOSSIBLE
} IscissorsOps;
</ENUM>
<STRUCT>
<NAME>ICurve</NAME>
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_ISCISSORS_TOOL</NAME>
#define GIMP_TYPE_ISCISSORS_TOOL            (gimp_iscissors_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ISCISSORS_TOOL</NAME>
#define GIMP_ISCISSORS_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ISCISSORS_TOOL, GimpIscissorsTool))
</MACRO>
<MACRO>
<NAME>GIMP_ISCISSORS_TOOL_CLASS</NAME>
#define GIMP_ISCISSORS_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ISCISSORS_TOOL, GimpIscissorsToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ISCISSORS_TOOL</NAME>
#define GIMP_IS_ISCISSORS_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ISCISSORS_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ISCISSORS_TOOL_CLASS</NAME>
#define GIMP_IS_ISCISSORS_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ISCISSORS_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_ISCISSORS_TOOL_GET_CLASS</NAME>
#define GIMP_ISCISSORS_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ISCISSORS_TOOL, GimpIscissorsToolClass))
</MACRO>
<STRUCT>
<NAME>GimpIscissorsTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpIscissorsToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpIscissorsTool</NAME>
struct _GimpIscissorsTool
{
  GimpSelectionTool  parent_instance;

  IscissorsOps    op;

  gint            x, y;         /*  upper left hand coordinate            */
  gint            ix, iy;       /*  initial coordinates                   */
  gint            nx, ny;       /*  new coordinates                       */

  TempBuf        *dp_buf;       /*  dynamic programming buffer            */

  ICurve         *livewire;     /*  livewire boundary curve               */

  ICurve         *curve1;       /*  1st curve connected to current point  */
  ICurve         *curve2;       /*  2nd curve connected to current point  */

  GSList         *curves;       /*  the list of curves                    */

  gboolean        first_point;  /*  is this the first point?              */
  gboolean        connected;    /*  is the region closed?                 */

  IscissorsState  state;        /*  state of iscissors                    */
  IscissorsDraw   draw;         /*  items to draw on a draw request       */

  /* XXX might be useful */
  GimpChannel    *mask;         /*  selection mask                        */
  TileManager    *gradient_map; /*  lazily filled gradient map            */
};
</STRUCT>
<STRUCT>
<NAME>GimpIscissorsToolClass</NAME>
struct _GimpIscissorsToolClass
{
  GimpSelectionToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_iscissors_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_iscissors_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LEVELS_TOOL</NAME>
#define GIMP_TYPE_LEVELS_TOOL            (gimp_levels_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_LEVELS_TOOL</NAME>
#define GIMP_LEVELS_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_LEVELS_TOOL, GimpLevelsTool))
</MACRO>
<MACRO>
<NAME>GIMP_LEVELS_TOOL_CLASS</NAME>
#define GIMP_LEVELS_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_LEVELS_TOOL, GimpLevelsToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LEVELS_TOOL</NAME>
#define GIMP_IS_LEVELS_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LEVELS_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LEVELS_TOOL_CLASS</NAME>
#define GIMP_IS_LEVELS_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_LEVELS_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_LEVELS_TOOL_GET_CLASS</NAME>
#define GIMP_LEVELS_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_LEVELS_TOOL, GimpLevelsToolClass))
</MACRO>
<STRUCT>
<NAME>GimpLevelsTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLevelsToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLevelsTool</NAME>
struct _GimpLevelsTool
{
  GimpImageMapTool      parent_instance;

  GimpLut              *lut;
  Levels               *levels;

  /* dialog */
  gboolean              color;
  gboolean              alpha;
  GimpHistogramChannel  channel;

  gint                  active_slider;
  gint                  slider_pos[5];

  GimpHistogram        *hist;
  GtkWidget            *hist_view;
  GtkWidget            *active_picker;
  GtkAdjustment        *low_input;
  GtkAdjustment        *gamma;
  GtkAdjustment        *low_output;
  GtkAdjustment        *high_input;
  GtkAdjustment        *high_output;
  GtkWidget            *input_area;
  GtkWidget            *input_bar;
  GtkWidget            *output_area;
  GtkWidget            *output_bar;
  GtkWidget            *channel_menu;
};
</STRUCT>
<STRUCT>
<NAME>GimpLevelsToolClass</NAME>
struct _GimpLevelsToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_levels_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_levels_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MAGNIFY_OPTIONS</NAME>
#define GIMP_TYPE_MAGNIFY_OPTIONS            (gimp_magnify_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MAGNIFY_OPTIONS</NAME>
#define GIMP_MAGNIFY_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MAGNIFY_OPTIONS, GimpMagnifyOptions))
</MACRO>
<MACRO>
<NAME>GIMP_MAGNIFY_OPTIONS_CLASS</NAME>
#define GIMP_MAGNIFY_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MAGNIFY_OPTIONS, GimpMagnifyOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MAGNIFY_OPTIONS</NAME>
#define GIMP_IS_MAGNIFY_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MAGNIFY_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MAGNIFY_OPTIONS_CLASS</NAME>
#define GIMP_IS_MAGNIFY_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MAGNIFY_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_MAGNIFY_OPTIONS_GET_CLASS</NAME>
#define GIMP_MAGNIFY_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MAGNIFY_OPTIONS, GimpMagnifyOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpMagnifyOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpMagnifyOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpMagnifyOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpMagnifyOptions</NAME>
struct _GimpMagnifyOptions
{
  GimpToolOptions   parent_instance;

  gboolean          auto_resize;
  GimpZoomType      zoom_type;
  gdouble           threshold;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_magnify_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_magnify_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MAGNIFY_TOOL</NAME>
#define GIMP_TYPE_MAGNIFY_TOOL            (gimp_magnify_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MAGNIFY_TOOL</NAME>
#define GIMP_MAGNIFY_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MAGNIFY_TOOL, GimpMagnifyTool))
</MACRO>
<MACRO>
<NAME>GIMP_MAGNIFY_TOOL_CLASS</NAME>
#define GIMP_MAGNIFY_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MAGNIFY_TOOL, GimpMagnifyToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MAGNIFY_TOOL</NAME>
#define GIMP_IS_MAGNIFY_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MAGNIFY_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MAGNIFY_TOOL_CLASS</NAME>
#define GIMP_IS_MAGNIFY_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MAGNIFY_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_MAGNIFY_TOOL_GET_CLASS</NAME>
#define GIMP_MAGNIFY_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MAGNIFY_TOOL, GimpMagnifyToolClass))
</MACRO>
<STRUCT>
<NAME>GimpMagnifyTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMagnifyToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMagnifyTool</NAME>
struct _GimpMagnifyTool
{
  GimpDrawTool  parent_instance;

  gint          x, y;  /*  upper left hand coordinate  */
  gint          w, h;  /*  width and height            */
};
</STRUCT>
<STRUCT>
<NAME>GimpMagnifyToolClass</NAME>
struct _GimpMagnifyToolClass
{
  GimpDrawToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_magnify_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_magnify_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MEASURE_OPTIONS</NAME>
#define GIMP_TYPE_MEASURE_OPTIONS            (gimp_measure_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MEASURE_OPTIONS</NAME>
#define GIMP_MEASURE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MEASURE_OPTIONS, GimpMeasureOptions))
</MACRO>
<MACRO>
<NAME>GIMP_MEASURE_OPTIONS_CLASS</NAME>
#define GIMP_MEASURE_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MEASURE_OPTIONS, GimpMeasureOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MEASURE_OPTIONS</NAME>
#define GIMP_IS_MEASURE_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MEASURE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MEASURE_OPTIONS_CLASS</NAME>
#define GIMP_IS_MEASURE_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MEASURE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_MEASURE_OPTIONS_GET_CLASS</NAME>
#define GIMP_MEASURE_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MEASURE_OPTIONS, GimpMeasureOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpMeasureOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpMeasureOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpMeasureOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpMeasureOptions</NAME>
struct _GimpMeasureOptions
{
  GimpToolOptions  parent_instance;

  gboolean         use_info_window;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_measure_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_measure_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<ENUM>
<NAME>MeasureFunction</NAME>
typedef enum
{
  CREATING,
  ADDING,
  MOVING,
  MOVING_ALL,
  GUIDING,
  FINISHED
} MeasureFunction;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_MEASURE_TOOL</NAME>
#define GIMP_TYPE_MEASURE_TOOL            (gimp_measure_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MEASURE_TOOL</NAME>
#define GIMP_MEASURE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MEASURE_TOOL, GimpMeasureTool))
</MACRO>
<MACRO>
<NAME>GIMP_MEASURE_TOOL_CLASS</NAME>
#define GIMP_MEASURE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MEASURE_TOOL, GimpMeasureToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MEASURE_TOOL</NAME>
#define GIMP_IS_MEASURE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MEASURE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MEASURE_TOOL_CLASS</NAME>
#define GIMP_IS_MEASURE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MEASURE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_MEASURE_TOOL_GET_CLASS</NAME>
#define GIMP_MEASURE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MEASURE_TOOL, GimpMeasureToolClass))
</MACRO>
<STRUCT>
<NAME>GimpMeasureTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMeasureToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMeasureTool</NAME>
struct _GimpMeasureTool
{
  GimpDrawTool     parent_instance;

  MeasureFunction  function;    /*  function we're performing  */
  gint             last_x;      /*  last x coordinate          */
  gint             last_y;      /*  last y coordinate          */
  gint             point;       /*  what are we manipulating?  */
  gint             num_points;  /*  how many points?           */
  gint             x[3];        /*  three x coordinates        */
  gint             y[3];        /*  three y coordinates        */
  gdouble          angle1;      /*  first angle                */
  gdouble          angle2;      /*  second angle               */

  GtkWidget       *dialog;
  GtkWidget       *distance_label[2];
  GtkWidget       *angle_label[2];
  GtkWidget       *width_label[2];
  GtkWidget       *height_label[2];
  GtkWidget       *unit_label[4];
};
</STRUCT>
<STRUCT>
<NAME>GimpMeasureToolClass</NAME>
struct _GimpMeasureToolClass
{
  GimpDrawToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_measure_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_measure_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MOVE_OPTIONS</NAME>
#define GIMP_TYPE_MOVE_OPTIONS            (gimp_move_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MOVE_OPTIONS</NAME>
#define GIMP_MOVE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MOVE_OPTIONS, GimpMoveOptions))
</MACRO>
<MACRO>
<NAME>GIMP_MOVE_OPTIONS_CLASS</NAME>
#define GIMP_MOVE_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MOVE_OPTIONS, GimpMoveOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MOVE_OPTIONS</NAME>
#define GIMP_IS_MOVE_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MOVE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MOVE_OPTIONS_CLASS</NAME>
#define GIMP_IS_MOVE_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MOVE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_MOVE_OPTIONS_GET_CLASS</NAME>
#define GIMP_MOVE_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MOVE_OPTIONS, GimpMoveOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpMoveOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpMoveOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpMoveOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpMoveOptions</NAME>
struct _GimpMoveOptions
{
  GimpToolOptions    parent_instence;

  GimpTransformType  move_type;
  gboolean           move_current;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_move_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_move_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MOVE_TOOL</NAME>
#define GIMP_TYPE_MOVE_TOOL            (gimp_move_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MOVE_TOOL</NAME>
#define GIMP_MOVE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MOVE_TOOL, GimpMoveTool))
</MACRO>
<MACRO>
<NAME>GIMP_MOVE_TOOL_CLASS</NAME>
#define GIMP_MOVE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MOVE_TOOL, GimpMoveToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MOVE_TOOL</NAME>
#define GIMP_IS_MOVE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MOVE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MOVE_TOOL_CLASS</NAME>
#define GIMP_IS_MOVE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MOVE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_MOVE_TOOL_GET_CLASS</NAME>
#define GIMP_MOVE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MOVE_TOOL, GimpMoveToolClass))
</MACRO>
<STRUCT>
<NAME>GimpMoveTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMoveToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMoveTool</NAME>
struct _GimpMoveTool
{
  GimpDrawTool         parent_instance;

  GimpLayer           *floating_layer;
  GimpGuide           *guide;

  gboolean             moving_guide;
  gint                 guide_position;
  GimpOrientationType  guide_orientation;

  GimpTransformType    saved_type;

  GimpLayer           *old_active_layer;
  GimpVectors         *old_active_vectors;
};
</STRUCT>
<STRUCT>
<NAME>GimpMoveToolClass</NAME>
struct _GimpMoveToolClass
{
  GimpDrawToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_move_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_move_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_move_tool_start_hguide</NAME>
<RETURNS>void    </RETURNS>
GimpTool    *tool,GimpDisplay *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_move_tool_start_vguide</NAME>
<RETURNS>void    </RETURNS>
GimpTool    *tool,GimpDisplay *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_NEW_RECT_SELECT_TOOL</NAME>
#define GIMP_TYPE_NEW_RECT_SELECT_TOOL            (gimp_new_rect_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_NEW_RECT_SELECT_TOOL</NAME>
#define GIMP_NEW_RECT_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_NEW_RECT_SELECT_TOOL, GimpNewRectSelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_NEW_RECT_SELECT_TOOL_CLASS</NAME>
#define GIMP_NEW_RECT_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_NEW_RECT_SELECT_TOOL, GimpNewRectSelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NEW_RECT_SELECT_TOOL</NAME>
#define GIMP_IS_NEW_RECT_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_NEW_RECT_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NEW_RECT_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_NEW_RECT_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_NEW_RECT_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_NEW_RECT_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_NEW_RECT_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_NEW_RECT_SELECT_TOOL, GimpNewRectSelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpNewRectSelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpNewRectSelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpNewRectSelectTool</NAME>
struct _GimpNewRectSelectTool
{
  GimpSelectionTool  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpNewRectSelectToolClass</NAME>
struct _GimpNewRectSelectToolClass
{
  GimpSelectionToolClass parent_class;

  void (* rect_select) (GimpNewRectSelectTool *rect_select,
                        gint                   x,
                        gint                   y,
                        gint                   w,
                        gint                   h);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_new_rect_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_new_rect_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PAINTBRUSH_TOOL</NAME>
#define GIMP_TYPE_PAINTBRUSH_TOOL            (gimp_paintbrush_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PAINTBRUSH_TOOL</NAME>
#define GIMP_PAINTBRUSH_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINTBRUSH_TOOL, GimpPaintbrushTool))
</MACRO>
<MACRO>
<NAME>GIMP_PAINTBRUSH_TOOL_CLASS</NAME>
#define GIMP_PAINTBRUSH_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PAINTBRUSH_TOOL, GimpPaintbrushToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINTBRUSH_TOOL</NAME>
#define GIMP_IS_PAINTBRUSH_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PAINTBRUSH_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINTBRUSH_TOOL_CLASS</NAME>
#define GIMP_IS_PAINTBRUSH_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PAINTBRUSH_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_PAINTBRUSH_TOOL_GET_CLASS</NAME>
#define GIMP_PAINTBRUSH_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PAINTBRUSH_TOOL, GimpPaintbrushToolClass))
</MACRO>
<STRUCT>
<NAME>GimpPaintbrushTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintbrushToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintbrushTool</NAME>
struct _GimpPaintbrushTool
{
  GimpPaintTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaintbrushToolClass</NAME>
struct _GimpPaintbrushToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_paintbrush_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_paintbrush_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_PAINT_OPTIONS_TABLE_KEY</NAME>
#define GIMP_PAINT_OPTIONS_TABLE_KEY "gimp-paint-options-table"
</MACRO>
<FUNCTION>
<NAME>gimp_paint_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PAINT_TOOL</NAME>
#define GIMP_TYPE_PAINT_TOOL            (gimp_paint_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_TOOL</NAME>
#define GIMP_PAINT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PAINT_TOOL, GimpPaintTool))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_TOOL_CLASS</NAME>
#define GIMP_PAINT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PAINT_TOOL, GimpPaintToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_TOOL</NAME>
#define GIMP_IS_PAINT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PAINT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PAINT_TOOL_CLASS</NAME>
#define GIMP_IS_PAINT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PAINT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_PAINT_TOOL_GET_CLASS</NAME>
#define GIMP_PAINT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PAINT_TOOL, GimpPaintToolClass))
</MACRO>
<STRUCT>
<NAME>GimpPaintToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintTool</NAME>
struct _GimpPaintTool
{
  GimpColorTool    parent_instance;

  gboolean         pick_colors;  /*  pick color if ctrl is pressed   */
  gboolean         draw_line;

  gboolean         show_cursor;
  gboolean         draw_brush;
  gdouble          brush_x;
  gdouble          brush_y;

  GimpPaintCore   *core;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaintToolClass</NAME>
struct _GimpPaintToolClass
{
  GimpColorToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_paint_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_tool_enable_color_picker</NAME>
<RETURNS>void    </RETURNS>
GimpPaintTool     *tool,GimpColorPickMode  mode
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PENCIL_TOOL</NAME>
#define GIMP_TYPE_PENCIL_TOOL            (gimp_pencil_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_TOOL</NAME>
#define GIMP_PENCIL_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PENCIL_TOOL, GimpPencilTool))
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_TOOL_CLASS</NAME>
#define GIMP_PENCIL_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PENCIL_TOOL, GimpPencilToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PENCIL_TOOL</NAME>
#define GIMP_IS_PENCIL_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PENCIL_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PENCIL_TOOL_CLASS</NAME>
#define GIMP_IS_PENCIL_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PENCIL_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_PENCIL_TOOL_GET_CLASS</NAME>
#define GIMP_PENCIL_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PENCIL_TOOL, GimpPencilToolClass))
</MACRO>
<STRUCT>
<NAME>GimpPencilTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPencilToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPencilTool</NAME>
struct _GimpPencilTool
{
  GimpPaintbrushTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPencilToolClass</NAME>
struct _GimpPencilToolClass
{
  GimpPaintbrushToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pencil_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_pencil_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PERSPECTIVE_TOOL</NAME>
#define GIMP_TYPE_PERSPECTIVE_TOOL            (gimp_perspective_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PERSPECTIVE_TOOL</NAME>
#define GIMP_PERSPECTIVE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PERSPECTIVE_TOOL, GimpPerspectiveTool))
</MACRO>
<MACRO>
<NAME>GIMP_PERSPECTIVE_TOOL_CLASS</NAME>
#define GIMP_PERSPECTIVE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PERSPECTIVE_TOOL, GimpPerspectiveToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PERSPECTIVE_TOOL</NAME>
#define GIMP_IS_PERSPECTIVE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PERSPECTIVE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PERSPECTIVE_TOOL_CLASS</NAME>
#define GIMP_IS_PERSPECTIVE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PERSPECTIVE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_PERSPECTIVE_TOOL_GET_CLASS</NAME>
#define GIMP_PERSPECTIVE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PERSPECTIVE_TOOL, GimpPerspectiveToolClass))
</MACRO>
<STRUCT>
<NAME>GimpPerspectiveTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPerspectiveToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPerspectiveTool</NAME>
struct _GimpPerspectiveTool
{
  GimpTransformTool  parent_instance;

  GtkWidget         *label[3][3];
};
</STRUCT>
<STRUCT>
<NAME>GimpPerspectiveToolClass</NAME>
struct _GimpPerspectiveToolClass
{
  GimpTransformToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_perspective_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_perspective_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_POSTERIZE_TOOL</NAME>
#define GIMP_TYPE_POSTERIZE_TOOL            (gimp_posterize_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_POSTERIZE_TOOL</NAME>
#define GIMP_POSTERIZE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_POSTERIZE_TOOL, GimpPosterizeTool))
</MACRO>
<MACRO>
<NAME>GIMP_POSTERIZE_TOOL_CLASS</NAME>
#define GIMP_POSTERIZE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_POSTERIZE_TOOL, GimpPosterizeToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_POSTERIZE_TOOL</NAME>
#define GIMP_IS_POSTERIZE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_POSTERIZE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_POSTERIZE_TOOL_CLASS</NAME>
#define GIMP_IS_POSTERIZE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_POSTERIZE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_POSTERIZE_TOOL_GET_CLASS</NAME>
#define GIMP_POSTERIZE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_POSTERIZE_TOOL, GimpPosterizeToolClass))
</MACRO>
<STRUCT>
<NAME>GimpPosterizeTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPosterizeToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPosterizeTool</NAME>
struct _GimpPosterizeTool
{
  GimpImageMapTool  parent_instance;

  gint              levels;
  GimpLut          *lut;

  /*  dialog  */
  GtkAdjustment    *levels_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpPosterizeToolClass</NAME>
struct _GimpPosterizeToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_posterize_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_posterize_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpRectangleOptionsProp</NAME>
typedef enum
{
  GIMP_RECTANGLE_OPTIONS_PROP_0,
  GIMP_RECTANGLE_OPTIONS_PROP_HIGHLIGHT,
  GIMP_RECTANGLE_OPTIONS_PROP_FIXED_WIDTH,
  GIMP_RECTANGLE_OPTIONS_PROP_WIDTH,
  GIMP_RECTANGLE_OPTIONS_PROP_FIXED_HEIGHT,
  GIMP_RECTANGLE_OPTIONS_PROP_HEIGHT,
  GIMP_RECTANGLE_OPTIONS_PROP_FIXED_ASPECT,
  GIMP_RECTANGLE_OPTIONS_PROP_ASPECT,
  GIMP_RECTANGLE_OPTIONS_PROP_FIXED_CENTER,
  GIMP_RECTANGLE_OPTIONS_PROP_CENTER_X,
  GIMP_RECTANGLE_OPTIONS_PROP_CENTER_Y,
  GIMP_RECTANGLE_OPTIONS_PROP_UNIT,
  GIMP_RECTANGLE_OPTIONS_PROP_DIMENSIONS_ENTRY,
  GIMP_RECTANGLE_OPTIONS_PROP_LAST = GIMP_RECTANGLE_OPTIONS_PROP_DIMENSIONS_ENTRY
} GimpRectangleOptionsProp;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_RECTANGLE_OPTIONS</NAME>
#define GIMP_TYPE_RECTANGLE_OPTIONS               (gimp_rectangle_options_interface_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IS_RECTANGLE_OPTIONS</NAME>
#define GIMP_IS_RECTANGLE_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_RECTANGLE_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_RECTANGLE_OPTIONS</NAME>
#define GIMP_RECTANGLE_OPTIONS(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_RECTANGLE_OPTIONS, GimpRectangleOptions))
</MACRO>
<MACRO>
<NAME>GIMP_RECTANGLE_OPTIONS_GET_INTERFACE</NAME>
#define GIMP_RECTANGLE_OPTIONS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GIMP_TYPE_RECTANGLE_OPTIONS, GimpRectangleOptionsInterface))
</MACRO>
<STRUCT>
<NAME>GimpRectangleOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRectangleOptionsInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRectangleOptionsInterface</NAME>
struct _GimpRectangleOptionsInterface
{
  GTypeInterface base_iface;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_rectangle_options_interface_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_options_install_properties</NAME>
<RETURNS>void      </RETURNS>
GObjectClass *klass
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_options_set_property</NAME>
<RETURNS>void      </RETURNS>
GObject      *object,guint         property_id,const GValue *value,GParamSpec   *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_options_get_property</NAME>
<RETURNS>void      </RETURNS>
GObject      *object,guint         property_id,GValue       *value,GParamSpec   *pspec
</FUNCTION>
<ENUM>
<NAME>GimpRectangleToolProp</NAME>
typedef enum
{
  GIMP_RECTANGLE_TOOL_PROP_0,
  GIMP_RECTANGLE_TOOL_PROP_CONTROLS,
  GIMP_RECTANGLE_TOOL_PROP_DIMENSIONS_ENTRY,
  GIMP_RECTANGLE_TOOL_PROP_PRESSX,
  GIMP_RECTANGLE_TOOL_PROP_PRESSY,
  GIMP_RECTANGLE_TOOL_PROP_X1,
  GIMP_RECTANGLE_TOOL_PROP_Y1,
  GIMP_RECTANGLE_TOOL_PROP_X2,
  GIMP_RECTANGLE_TOOL_PROP_Y2,
  GIMP_RECTANGLE_TOOL_PROP_FUNCTION,
  GIMP_RECTANGLE_TOOL_PROP_LAST = GIMP_RECTANGLE_TOOL_PROP_FUNCTION
} GimpRectangleToolProp;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_RECTANGLE_TOOL</NAME>
#define GIMP_TYPE_RECTANGLE_TOOL               (gimp_rectangle_tool_interface_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IS_RECTANGLE_TOOL</NAME>
#define GIMP_IS_RECTANGLE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_RECTANGLE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_RECTANGLE_TOOL</NAME>
#define GIMP_RECTANGLE_TOOL(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_RECTANGLE_TOOL, GimpRectangleTool))
</MACRO>
<MACRO>
<NAME>GIMP_RECTANGLE_TOOL_GET_INTERFACE</NAME>
#define GIMP_RECTANGLE_TOOL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GIMP_TYPE_RECTANGLE_TOOL, GimpRectangleToolInterface))
</MACRO>
<STRUCT>
<NAME>GimpRectangleTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRectangleToolInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRectangleToolInterface</NAME>
struct _GimpRectangleToolInterface
{
  GTypeInterface base_iface;

  gboolean (* execute)     (GimpRectangleTool *rect_tool,
                            gint               x,
                            gint               y,
                            gint               w,
                            gint               h);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_rectangle_tool_interface_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_constructor</NAME>
<RETURNS>void        </RETURNS>
GObject           *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_dispose</NAME>
<RETURNS>void        </RETURNS>
GObject           *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_initialize</NAME>
<RETURNS>gboolean    </RETURNS>
GimpTool          *tool,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_button_press</NAME>
<RETURNS>void        </RETURNS>
GimpTool          *tool,GimpCoords        *coords,guint32            time,GdkModifierType    state,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_button_release</NAME>
<RETURNS>void        </RETURNS>
GimpTool          *tool,GimpCoords        *coords,guint32            time,GdkModifierType    state,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_motion</NAME>
<RETURNS>void        </RETURNS>
GimpTool          *tool,GimpCoords        *coords,guint32            time,GdkModifierType    state,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_key_press</NAME>
<RETURNS>gboolean    </RETURNS>
GimpTool          *tool,GdkEventKey       *kevent,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_modifier_key</NAME>
<RETURNS>void        </RETURNS>
GimpTool          *tool,GdkModifierType    key,gboolean           press,GdkModifierType    state,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_oper_update</NAME>
<RETURNS>void        </RETURNS>
GimpTool          *tool,GimpCoords        *coords,GdkModifierType    state,gboolean           proximity,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_cursor_update</NAME>
<RETURNS>void        </RETURNS>
GimpTool          *tool,GimpCoords        *coords,GdkModifierType    state,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_draw</NAME>
<RETURNS>void        </RETURNS>
GimpDrawTool      *draw
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_execute</NAME>
<RETURNS>gboolean    </RETURNS>
GimpRectangleTool *rect_tool,gint               x,gint               y,gint               w,gint               h
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_response</NAME>
<RETURNS>void        </RETURNS>
GtkWidget         *widget,gint               response_id,GimpRectangleTool *rectangle
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_configure</NAME>
<RETURNS>void        </RETURNS>
GimpRectangleTool *rectangle
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_install_properties</NAME>
<RETURNS>void        </RETURNS>
GObjectClass *klass
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_set_property</NAME>
<RETURNS>void        </RETURNS>
GObject      *object,guint         property_id,const GValue *value,GParamSpec   *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_rectangle_tool_get_property</NAME>
<RETURNS>void        </RETURNS>
GObject      *object,guint         property_id,GValue       *value,GParamSpec   *pspec
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_RECT_SELECT_TOOL</NAME>
#define GIMP_TYPE_RECT_SELECT_TOOL            (gimp_rect_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_RECT_SELECT_TOOL</NAME>
#define GIMP_RECT_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_RECT_SELECT_TOOL, GimpRectSelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_RECT_SELECT_TOOL_CLASS</NAME>
#define GIMP_RECT_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_RECT_SELECT_TOOL, GimpRectSelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_RECT_SELECT_TOOL</NAME>
#define GIMP_IS_RECT_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_RECT_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_RECT_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_RECT_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_RECT_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_RECT_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_RECT_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_RECT_SELECT_TOOL, GimpRectSelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpRectSelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRectSelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRectSelectTool</NAME>
struct _GimpRectSelectTool
{
  GimpSelectionTool  parent_instance;

  gint               sx, sy;      /*  start coordinate where the button is
                                   *  first pressed  */
  gint               x, y;        /*  upper left coordinate of selection  */
  gint               w, h;        /*  width, height of selection always >=0  */
  gint               lx, ly;      /*  last coordinate of mouse cursor  */
  gboolean           center;      /*  is the selection being created from the
                                   *  center out?  */
  GimpRectSelectMode fixed_mode;
  gdouble            fixed_width;
  gdouble            fixed_height;
};
</STRUCT>
<STRUCT>
<NAME>GimpRectSelectToolClass</NAME>
struct _GimpRectSelectToolClass
{
  GimpSelectionToolClass parent_class;

  /*  virtual function  */

  void (* rect_select) (GimpRectSelectTool *rect_tool,
                        gint                x,
                        gint                y,
                        gint                w,
                        gint                h);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_rect_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_rect_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_rect_select_tool_rect_select</NAME>
<RETURNS>void    </RETURNS>
GimpRectSelectTool       *rect_tool,gint                      x,gint                      y,gint                      w,gint                      h
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ROTATE_TOOL</NAME>
#define GIMP_TYPE_ROTATE_TOOL            (gimp_rotate_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ROTATE_TOOL</NAME>
#define GIMP_ROTATE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ROTATE_TOOL, GimpRotateTool))
</MACRO>
<MACRO>
<NAME>GIMP_ROTATE_TOOL_CLASS</NAME>
#define GIMP_ROTATE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ROTATE_TOOL, GimpRotateToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ROTATE_TOOL</NAME>
#define GIMP_IS_ROTATE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ROTATE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ROTATE_TOOL_CLASS</NAME>
#define GIMP_IS_ROTATE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ROTATE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_ROTATE_TOOL_GET_CLASS</NAME>
#define GIMP_ROTATE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ROTATE_TOOL, GimpRotateToolClass))
</MACRO>
<STRUCT>
<NAME>GimpRotateTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRotateToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRotateTool</NAME>
struct _GimpRotateTool
{
  GimpTransformTool  parent_instance;

  GtkObject         *angle_adj;
  GtkWidget         *sizeentry;
};
</STRUCT>
<STRUCT>
<NAME>GimpRotateToolClass</NAME>
struct _GimpRotateToolClass
{
  GimpTransformToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_rotate_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_rotate_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SCALE_TOOL</NAME>
#define GIMP_TYPE_SCALE_TOOL            (gimp_scale_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SCALE_TOOL</NAME>
#define GIMP_SCALE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SCALE_TOOL, GimpScaleTool))
</MACRO>
<MACRO>
<NAME>GIMP_SCALE_TOOL_CLASS</NAME>
#define GIMP_SCALE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SCALE_TOOL, GimpScaleToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SCALE_TOOL</NAME>
#define GIMP_IS_SCALE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SCALE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_SCALE_TOOL_GET_CLASS</NAME>
#define GIMP_SCALE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SCALE_TOOL, GimpScaleToolClass))
</MACRO>
<STRUCT>
<NAME>GimpScaleTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpScaleToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpScaleTool</NAME>
struct _GimpScaleTool
{
  GimpTransformTool  parent_instance;

  GtkWidget         *box;
};
</STRUCT>
<STRUCT>
<NAME>GimpScaleToolClass</NAME>
struct _GimpScaleToolClass
{
  GimpTransformToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_scale_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_scale_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SELECTION_OPTIONS</NAME>
#define GIMP_TYPE_SELECTION_OPTIONS            (gimp_selection_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_OPTIONS</NAME>
#define GIMP_SELECTION_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SELECTION_OPTIONS, GimpSelectionOptions))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_OPTIONS_CLASS</NAME>
#define GIMP_SELECTION_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SELECTION_OPTIONS, GimpSelectionOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_OPTIONS</NAME>
#define GIMP_IS_SELECTION_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SELECTION_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_OPTIONS_CLASS</NAME>
#define GIMP_IS_SELECTION_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SELECTION_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_OPTIONS_GET_CLASS</NAME>
#define GIMP_SELECTION_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SELECTION_OPTIONS, GimpSelectionOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpSelectionOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpSelectionOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpSelectionOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpSelectionOptions</NAME>
struct _GimpSelectionOptions
{
  GimpToolOptions     parent_instance;

  /*  options used by all selection tools  */
  GimpChannelOps      operation;
  gboolean            antialias;
  gboolean            feather;
  gdouble             feather_radius;

  /*  used by fuzzy, by-color selection  */
  gboolean            select_transparent;
  gboolean            sample_merged;
  gdouble             threshold;

  /*  used by rect., ellipse selection  */
  gboolean            auto_shrink;
  gboolean            shrink_merged;

  GimpRectSelectMode  fixed_mode;
  gdouble             fixed_width;
  gdouble             fixed_height;
  GimpUnit            fixed_unit;

  /*  used by iscissors */
  gboolean            interactive;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_selection_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SELECTION_TOOL</NAME>
#define GIMP_TYPE_SELECTION_TOOL            (gimp_selection_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_TOOL</NAME>
#define GIMP_SELECTION_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SELECTION_TOOL, GimpSelectionTool))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_TOOL_CLASS</NAME>
#define GIMP_SELECTION_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SELECTION_TOOL, GimpSelectionToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_TOOL</NAME>
#define GIMP_IS_SELECTION_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SELECTION_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_TOOL_CLASS</NAME>
#define GIMP_IS_SELECTION_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SELECTION_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_TOOL_GET_CLASS</NAME>
#define GIMP_SELECTION_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SELECTION_TOOL, GimpSelectionToolClass))
</MACRO>
<STRUCT>
<NAME>GimpSelectionTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSelectionToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSelectionTool</NAME>
struct _GimpSelectionTool
{
  GimpDrawTool  parent_instance;

  SelectOps     op;       /*  selection operation (SELECTION_ADD etc.)  */
  SelectOps     saved_op; /*  saved tool options state                  */
};
</STRUCT>
<STRUCT>
<NAME>GimpSelectionToolClass</NAME>
struct _GimpSelectionToolClass
{
  GimpDrawToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_selection_tool_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_tool_start_edit</NAME>
<RETURNS>gboolean   </RETURNS>
GimpSelectionTool *sel_tool,GimpCoords        *coords
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SHEAR_TOOL</NAME>
#define GIMP_TYPE_SHEAR_TOOL            (gimp_shear_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SHEAR_TOOL</NAME>
#define GIMP_SHEAR_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SHEAR_TOOL, GimpShearTool))
</MACRO>
<MACRO>
<NAME>GIMP_SHEAR_TOOL_CLASS</NAME>
#define GIMP_SHEAR_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SHEAR_TOOL, GimpShearToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SHEAR_TOOL</NAME>
#define GIMP_IS_SHEAR_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SHEAR_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SHEAR_TOOL_CLASS</NAME>
#define GIMP_IS_SHEAR_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SHEAR_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_SHEAR_TOOL_GET_CLASS</NAME>
#define GIMP_SHEAR_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SHEAR_TOOL, GimpShearToolClass))
</MACRO>
<STRUCT>
<NAME>GimpShearTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpShearToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpShearTool</NAME>
struct _GimpShearTool
{
  GimpTransformTool  parent_instance;

  GtkObject         *x_adj;
  GtkObject         *y_adj;
};
</STRUCT>
<STRUCT>
<NAME>GimpShearToolClass</NAME>
struct _GimpShearToolClass
{
  GimpTransformToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_shear_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_shear_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SMUDGE_TOOL</NAME>
#define GIMP_TYPE_SMUDGE_TOOL            (gimp_smudge_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_TOOL</NAME>
#define GIMP_SMUDGE_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SMUDGE_TOOL, GimpSmudgeTool))
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_TOOL_CLASS</NAME>
#define GIMP_SMUDGE_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SMUDGE_TOOL, GimpSmudgeToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SMUDGE_TOOL</NAME>
#define GIMP_IS_SMUDGE_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SMUDGE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SMUDGE_TOOL_CLASS</NAME>
#define GIMP_IS_SMUDGE_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SMUDGE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_SMUDGE_TOOL_GET_CLASS</NAME>
#define GIMP_SMUDGE_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SMUDGE_TOOL, GimpSmudgeToolClass))
</MACRO>
<STRUCT>
<NAME>GimpSmudgeTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSmudgeToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSmudgeTool</NAME>
struct _GimpSmudgeTool
{
  GimpPaintTool parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpSmudgeToolClass</NAME>
struct _GimpSmudgeToolClass
{
  GimpPaintToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_smudge_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_smudge_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_OPTIONS</NAME>
#define GIMP_TYPE_TEXT_OPTIONS            (gimp_text_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_OPTIONS</NAME>
#define GIMP_TEXT_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT_OPTIONS, GimpTextOptions))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_OPTIONS_CLASS</NAME>
#define GIMP_TEXT_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEXT_OPTIONS, GimpTextOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_OPTIONS</NAME>
#define GIMP_IS_TEXT_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_OPTIONS_CLASS</NAME>
#define GIMP_IS_TEXT_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEXT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_OPTIONS_GET_CLASS</NAME>
#define GIMP_TEXT_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEXT_OPTIONS, GimpTextOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpTextOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpTextOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpTextOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpTextOptions</NAME>
struct _GimpTextOptions
{
  GimpToolOptions        tool_options;

  GimpUnit               unit;
  gdouble                font_size;
  gboolean               hinting;
  gboolean               autohint;
  gboolean               antialias;
  gchar                 *language;
  GimpTextDirection      base_dir;
  GimpTextJustification  justify;
  gdouble                indent;
  gdouble                line_spacing;
  gdouble                letter_spacing;

  GimpViewType           font_view_type;
  GimpViewSize           font_view_size;

  GimpSizeEntry         *size_entry;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_text_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_options_connect_text</NAME>
<RETURNS>void        </RETURNS>
GimpTextOptions *options,GimpText        *text
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_options_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpTextOptions *options,GimpMenuFactory *menu_factory,const gchar     *title
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_TOOL</NAME>
#define GIMP_TYPE_TEXT_TOOL            (gimp_text_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_TOOL</NAME>
#define GIMP_TEXT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT_TOOL, GimpTextTool))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_TOOL</NAME>
#define GIMP_IS_TEXT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_TOOL_CLASS</NAME>
#define GIMP_TEXT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEXT_TOOL, GimpTextToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_TOOL_CLASS</NAME>
#define GIMP_IS_TEXT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEXT_TOOL))
</MACRO>
<STRUCT>
<NAME>GimpTextTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextTool</NAME>
struct _GimpTextTool
{
  GimpTool       parent_instance;

  GimpText      *proxy;
  GList         *pending;
  guint          idle_id;

  gint           x1, y1;
  gint           x2, y2;

  GimpText      *text;
  GimpTextLayer *layer;
  GimpImage     *image;

  GtkWidget     *editor;
  GtkWidget     *confirm_dialog;
};
</STRUCT>
<STRUCT>
<NAME>GimpTextToolClass</NAME>
struct _GimpTextToolClass
{
  GimpToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_text_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_tool_set_layer</NAME>
<RETURNS>void    </RETURNS>
GimpTextTool *text_tool,GimpLayer    *layer
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_THRESHOLD_TOOL</NAME>
#define GIMP_TYPE_THRESHOLD_TOOL            (gimp_threshold_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_THRESHOLD_TOOL</NAME>
#define GIMP_THRESHOLD_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_THRESHOLD_TOOL, GimpThresholdTool))
</MACRO>
<MACRO>
<NAME>GIMP_THRESHOLD_TOOL_CLASS</NAME>
#define GIMP_THRESHOLD_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_THRESHOLD_TOOL, GimpThresholdToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_THRESHOLD_TOOL</NAME>
#define GIMP_IS_THRESHOLD_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_THRESHOLD_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_THRESHOLD_TOOL_CLASS</NAME>
#define GIMP_IS_THRESHOLD_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_THRESHOLD_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_THRESHOLD_TOOL_GET_CLASS</NAME>
#define GIMP_THRESHOLD_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_THRESHOLD_TOOL, GimpThresholdToolClass))
</MACRO>
<STRUCT>
<NAME>GimpThresholdTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpThresholdToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpThresholdTool</NAME>
struct _GimpThresholdTool
{
  GimpImageMapTool  parent_instance;

  Threshold        *threshold;

  /*  dialog  */
  GimpHistogram    *hist;
  GimpHistogramBox *histogram_box;
};
</STRUCT>
<STRUCT>
<NAME>GimpThresholdToolClass</NAME>
struct _GimpThresholdToolClass
{
  GimpImageMapToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_threshold_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_threshold_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL</NAME>
#define GIMP_TYPE_TOOL            (gimp_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL</NAME>
#define GIMP_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL, GimpTool))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_CLASS</NAME>
#define GIMP_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL, GimpToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL</NAME>
#define GIMP_IS_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_CLASS</NAME>
#define GIMP_IS_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_GET_CLASS</NAME>
#define GIMP_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL, GimpToolClass))
</MACRO>
<STRUCT>
<NAME>GimpToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTool</NAME>
struct _GimpTool
{
  GimpObject       parent_instance;

  GimpToolInfo    *tool_info;

  gint             ID;          /*  unique tool ID                         */

  GimpToolControl *control;

  GimpDisplay     *display;     /*  pointer to currently active display    */
  GimpDrawable    *drawable;    /*  pointer to the tool's current drawable */

  /*  focus_display and modifier_state are *private* state of
   *  gimp_tool_set_focus_display() and gimp_tool_set_modifier_state().
   *  ignore them in tool implementations, they don't exist!
   */
  GimpDisplay     *focus_display;
  GdkModifierType  modifier_state;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolClass</NAME>
struct _GimpToolClass
{
  GimpObjectClass  parent_class;

  /*  virtual functions  */

  gboolean (* initialize)     (GimpTool        *tool,
                               GimpDisplay     *display);
  void     (* control)        (GimpTool        *tool,
                               GimpToolAction   action,
                               GimpDisplay     *display);

  void     (* button_press)   (GimpTool        *tool,
                               GimpCoords      *coords,
                               guint32          time,
                               GdkModifierType  state,
                               GimpDisplay     *display);
  void     (* button_release) (GimpTool        *tool,
                               GimpCoords      *coords,
                               guint32          time,
                               GdkModifierType  state,
                               GimpDisplay     *display);
  void     (* motion)         (GimpTool        *tool,
                               GimpCoords      *coords,
                               guint32          time,
                               GdkModifierType  state,
                               GimpDisplay     *display);

  gboolean (* key_press)      (GimpTool        *tool,
                               GdkEventKey     *kevent,
                               GimpDisplay     *display);
  void     (* modifier_key)   (GimpTool        *tool,
                               GdkModifierType  key,
                               gboolean         press,
                               GdkModifierType  state,
                               GimpDisplay     *display);

  void     (* oper_update)    (GimpTool        *tool,
                               GimpCoords      *coords,
                               GdkModifierType  state,
                               gboolean         proximity,
                               GimpDisplay     *display);
  void     (* cursor_update)  (GimpTool        *tool,
                               GimpCoords      *coords,
                               GdkModifierType  state,
                               GimpDisplay     *display);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_initialize</NAME>
<RETURNS>gboolean      </RETURNS>
GimpTool            *tool,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control</NAME>
<RETURNS>void              </RETURNS>
GimpTool            *tool,GimpToolAction       action,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_button_press</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpCoords          *coords,guint32              time,GdkModifierType      state,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_button_release</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpCoords          *coords,guint32              time,GdkModifierType      state,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_motion</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpCoords          *coords,guint32              time,GdkModifierType      state,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_key_press</NAME>
<RETURNS>gboolean      </RETURNS>
GimpTool            *tool,GdkEventKey         *kevent,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_set_focus_display</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_set_modifier_state</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GdkModifierType      state,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_oper_update</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpCoords          *coords,GdkModifierType      state,gboolean             proximity,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_cursor_update</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpCoords          *coords,GdkModifierType      state,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_push_status</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display,const gchar         *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_push_status_coords</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display,const gchar         *title,gdouble              x,const gchar         *separator,gdouble              y
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_push_status_length</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display,const gchar         *title,GimpOrientationType  axis,gdouble              value
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_replace_status</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display,const gchar         *message
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_pop_status</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_set_cursor</NAME>
<RETURNS>void          </RETURNS>
GimpTool            *tool,GimpDisplay         *display,GimpCursorType       cursor,GimpToolCursorType   tool_cursor,GimpCursorModifier   modifier
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL_CONTROL</NAME>
#define GIMP_TYPE_TOOL_CONTROL            (gimp_tool_control_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_CONTROL</NAME>
#define GIMP_TOOL_CONTROL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_CONTROL, GimpToolControl))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_CONTROL_CLASS</NAME>
#define GIMP_TOOL_CONTROL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_CONTROL, GimpToolControlClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_CONTROL</NAME>
#define GIMP_IS_TOOL_CONTROL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_CONTROL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_CONTROL_CLASS</NAME>
#define GIMP_IS_TOOL_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_CONTROL))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_CONTROL_GET_CLASS</NAME>
#define GIMP_TOOL_CONTROL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_CONTROL, GimpToolControlClass))
</MACRO>
<STRUCT>
<NAME>GimpToolControlClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolControl</NAME>
struct _GimpToolControl
{
  GimpObject         parent_instance;

  gboolean           active;             /*  state of tool activity          */
  gint               paused_count;       /*  paused control count            */

  gboolean           preserve;           /*  Preserve this tool across       *
                                          *  drawable changes                */
  gboolean           scroll_lock;        /*  allow scrolling or not          */
  gboolean           handle_empty_image; /*  invoke the tool on images       *
                                          *  without active drawable         */
  GimpDirtyMask      dirty_mask;         /*  if preserve is FALSE, cancel    *
                                          *  the tool on these events        */
  GimpMotionMode     motion_mode;        /*  how to process motion events    *
                                          *  before they go to the tool      */
  gboolean           auto_snap_to;       /*  snap to guides automatically    */
  gint               snap_offset_x;
  gint               snap_offset_y;
  gint               snap_width;
  gint               snap_height;

  gboolean           toggled;

  GimpCursorType     cursor;
  GimpToolCursorType tool_cursor;
  GimpCursorModifier cursor_modifier;

  GimpCursorType     toggle_cursor;
  GimpToolCursorType toggle_tool_cursor;
  GimpCursorModifier toggle_cursor_modifier;

  gchar             *action_value_1;
  gchar             *action_value_2;
  gchar             *action_value_3;
  gchar             *action_value_4;
  gchar             *action_object_1;
  gchar             *action_object_2;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolControlClass</NAME>
struct _GimpToolControlClass
{
  GimpObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_control_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_activate</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_halt</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_is_active</NAME>
<RETURNS>gboolean       </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_pause</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_resume</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_is_paused</NAME>
<RETURNS>gboolean       </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_preserve</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,gboolean         preserve
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_preserve</NAME>
<RETURNS>gboolean       </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_scroll_lock</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,gboolean         scroll_lock
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_scroll_lock</NAME>
<RETURNS>gboolean       </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_handle_empty_image</NAME>
<RETURNS>void     </RETURNS>
GimpToolControl *control,gboolean         handle_empty
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_handle_empty_image</NAME>
<RETURNS>gboolean </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_dirty_mask</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,GimpDirtyMask    dirty_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_dirty_mask</NAME>
<RETURNS>GimpDirtyMask  </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_motion_mode</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,GimpMotionMode   motion_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_motion_mode</NAME>
<RETURNS>GimpMotionMode </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_snap_to</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,gboolean         snap_to
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_snap_to</NAME>
<RETURNS>gboolean       </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_snap_offsets</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,gint             offset_x,gint             offset_y,gint             width,gint             height
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_snap_offsets</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,gint            *offset_x,gint            *offset_y,gint            *width,gint            *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_toggled</NAME>
<RETURNS>void           </RETURNS>
GimpToolControl *control,gboolean         toggled
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_toggled</NAME>
<RETURNS>gboolean       </RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_cursor</NAME>
<RETURNS>void </RETURNS>
GimpToolControl    *control,GimpCursorType      cursor
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_tool_cursor</NAME>
<RETURNS>void </RETURNS>
GimpToolControl    *control,GimpToolCursorType  cursor
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_cursor_modifier</NAME>
<RETURNS>void </RETURNS>
GimpToolControl    *control,GimpCursorModifier cmodifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_toggle_cursor</NAME>
<RETURNS>void </RETURNS>
GimpToolControl    *control,GimpCursorType      cursor
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_toggle_tool_cursor</NAME>
<RETURNS>void </RETURNS>
GimpToolControl    *control,GimpToolCursorType  cursor
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_toggle_cursor_modifier</NAME>
<RETURNS>void </RETURNS>
GimpToolControl    *control,GimpCursorModifier  cmodifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_cursor</NAME>
<RETURNS>GimpCursorType</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_tool_cursor</NAME>
<RETURNS>GimpToolCursorType</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_cursor_modifier</NAME>
<RETURNS>GimpCursorModifier</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_action_value_1</NAME>
<RETURNS>void          </RETURNS>
GimpToolControl *control,const gchar     *action
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_action_value_1</NAME>
<RETURNS>const gchar *</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_action_value_2</NAME>
<RETURNS>void          </RETURNS>
GimpToolControl *control,const gchar     *action
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_action_value_2</NAME>
<RETURNS>const gchar *</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_action_value_3</NAME>
<RETURNS>void          </RETURNS>
GimpToolControl *control,const gchar     *action
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_action_value_3</NAME>
<RETURNS>const gchar *</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_action_value_4</NAME>
<RETURNS>void          </RETURNS>
GimpToolControl *control,const gchar     *action
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_action_value_4</NAME>
<RETURNS>const gchar *</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_action_object_1</NAME>
<RETURNS>void          </RETURNS>
GimpToolControl *control,const gchar     *action
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_action_object_1</NAME>
<RETURNS>const gchar *</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_set_action_object_2</NAME>
<RETURNS>void          </RETURNS>
GimpToolControl *control,const gchar     *action
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_control_get_action_object_2</NAME>
<RETURNS>const gchar *</RETURNS>
GimpToolControl *control
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TRANSFORM_OPTIONS</NAME>
#define GIMP_TYPE_TRANSFORM_OPTIONS            (gimp_transform_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TRANSFORM_OPTIONS</NAME>
#define GIMP_TRANSFORM_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TRANSFORM_OPTIONS, GimpTransformOptions))
</MACRO>
<MACRO>
<NAME>GIMP_TRANSFORM_OPTIONS_CLASS</NAME>
#define GIMP_TRANSFORM_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TRANSFORM_OPTIONS, GimpTransformOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TRANSFORM_OPTIONS</NAME>
#define GIMP_IS_TRANSFORM_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TRANSFORM_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TRANSFORM_OPTIONS_CLASS</NAME>
#define GIMP_IS_TRANSFORM_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TRANSFORM_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_TRANSFORM_OPTIONS_GET_CLASS</NAME>
#define GIMP_TRANSFORM_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TRANSFORM_OPTIONS, GimpTransformOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpTransformOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpTransformOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpTransformOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpTransformOptions</NAME>
struct _GimpTransformOptions
{
  GimpToolOptions           parent_instance;

  GimpTransformType         type;
  GimpTransformDirection    direction;
  GimpInterpolationType     interpolation;
  gboolean                  supersample;
  gint                      recursion_level;
  gboolean                  clip;
  GimpTransformPreviewType  preview_type;
  GimpTransformGridType     grid_type;
  gint                      grid_size;
  gboolean                  constrain_1;
  gboolean                  constrain_2;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_transform_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_tool_push_undo</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage   *image,const gchar *undo_desc,gint         tool_ID,GType        tool_type,gdouble     *trans_info,TileManager *original
</FUNCTION>
<MACRO>
<NAME>MAX_INFO_BUF</NAME>
#define MAX_INFO_BUF   40
</MACRO>
<MACRO>
<NAME>TRAN_INFO_SIZE</NAME>
#define TRAN_INFO_SIZE  8
</MACRO>
<TYPEDEF>
<NAME>TransInfo</NAME>
typedef gdouble TransInfo[TRAN_INFO_SIZE];
</TYPEDEF>
<MACRO>
<NAME>GIMP_TYPE_TRANSFORM_TOOL</NAME>
#define GIMP_TYPE_TRANSFORM_TOOL            (gimp_transform_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TRANSFORM_TOOL</NAME>
#define GIMP_TRANSFORM_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TRANSFORM_TOOL, GimpTransformTool))
</MACRO>
<MACRO>
<NAME>GIMP_TRANSFORM_TOOL_CLASS</NAME>
#define GIMP_TRANSFORM_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TRANSFORM_TOOL, GimpTransformToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TRANSFORM_TOOL</NAME>
#define GIMP_IS_TRANSFORM_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TRANSFORM_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TRANSFORM_TOOL_CLASS</NAME>
#define GIMP_IS_TRANSFORM_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TRANSFORM_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_TRANSFORM_TOOL_GET_CLASS</NAME>
#define GIMP_TRANSFORM_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TRANSFORM_TOOL, GimpTransformToolClass))
</MACRO>
<STRUCT>
<NAME>GimpTransformToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTransformTool</NAME>
struct _GimpTransformTool
{
  GimpDrawTool    parent_instance;

  gdouble         startx;         /*  starting x coord                 */
  gdouble         starty;         /*  starting y coord                 */

  gdouble         curx;           /*  current x coord                  */
  gdouble         cury;           /*  current y coord                  */

  gdouble         lastx;          /*  last x coord                     */
  gdouble         lasty;          /*  last y coord                     */

  GdkModifierType state;          /*  state of buttons and keys        */

  gint            x1, y1;         /*  upper left hand coordinate       */
  gint            x2, y2;         /*  lower right hand coords          */
  gdouble         cx, cy;         /*  center point (for rotation)      */

  gdouble         tx1, ty1;       /*  transformed coords               */
  gdouble         tx2, ty2;
  gdouble         tx3, ty3;
  gdouble         tx4, ty4;
  gdouble         tcx, tcy;

  GimpMatrix3     transform;      /*  transformation matrix            */
  TransInfo       trans_info;     /*  transformation info              */

  TransInfo       old_trans_info; /*  for cancelling a drag operation  */

  TileManager    *original;       /*  pointer to original tiles        */

  TransformAction function;       /*  current tool activity            */

  gboolean        use_grid;       /*  does the tool use the grid       */
  gboolean        use_center;     /*  use the center handle            */

  gint            ngx, ngy;       /*  number of grid lines in original
                                   *  x and y directions
                                   */
  gdouble        *grid_coords;    /*  x and y coordinates of the grid
                                   *  endpoints (a total of (ngx+ngy)*2
                                   *  coordinate pairs)
                                   */
  gdouble        *tgrid_coords;   /*  transformed grid_coords          */

  GimpTransformType       type;
  GimpTransformDirection  direction;

  const gchar    *shell_desc;
  const gchar    *progress_text;

  GtkWidget      *dialog;
};
</STRUCT>
<STRUCT>
<NAME>GimpTransformToolClass</NAME>
struct _GimpTransformToolClass
{
  GimpDrawToolClass parent_class;

  /*  virtual functions  */
  void          (* dialog)        (GimpTransformTool *tool);
  void          (* dialog_update) (GimpTransformTool *tool);
  void          (* prepare)       (GimpTransformTool *tool,
                                   GimpDisplay       *display);
  void          (* motion)        (GimpTransformTool *tool,
                                   GimpDisplay       *display);
  void          (* recalc)        (GimpTransformTool *tool,
                                   GimpDisplay       *display);
  TileManager * (* transform)     (GimpTransformTool *tool,
                                   GimpItem          *item,
                                   gboolean           mask_empty,
                                   GimpDisplay       *display);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_transform_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_tool_recalc</NAME>
<RETURNS>void    </RETURNS>
GimpTransformTool *tr_tool,GimpDisplay       *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_transform_tool_expose_preview</NAME>
<RETURNS>void    </RETURNS>
GimpTransformTool *tr_tool
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VECTOR_OPTIONS</NAME>
#define GIMP_TYPE_VECTOR_OPTIONS            (gimp_vector_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VECTOR_OPTIONS</NAME>
#define GIMP_VECTOR_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VECTOR_OPTIONS, GimpVectorOptions))
</MACRO>
<MACRO>
<NAME>GIMP_VECTOR_OPTIONS_CLASS</NAME>
#define GIMP_VECTOR_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VECTOR_OPTIONS, GimpVectorOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTOR_OPTIONS</NAME>
#define GIMP_IS_VECTOR_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VECTOR_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTOR_OPTIONS_CLASS</NAME>
#define GIMP_IS_VECTOR_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VECTOR_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_VECTOR_OPTIONS_GET_CLASS</NAME>
#define GIMP_VECTOR_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VECTOR_OPTIONS, GimpVectorOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpVectorOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpVectorOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpVectorOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpVectorOptions</NAME>
struct _GimpVectorOptions
{
  GimpToolOptions  parent_instance;

  GimpVectorMode   edit_mode;
  gboolean         polygonal;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_vector_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_vector_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<ENUM>
<NAME>GimpVectorFunction</NAME>
typedef enum
{
  VECTORS_SELECT_VECTOR,
  VECTORS_CREATE_VECTOR,
  VECTORS_CREATE_STROKE,
  VECTORS_ADD_ANCHOR,
  VECTORS_MOVE_ANCHOR,
  VECTORS_MOVE_ANCHORSET,
  VECTORS_MOVE_HANDLE,
  VECTORS_MOVE_CURVE,
  VECTORS_MOVE_STROKE,
  VECTORS_MOVE_VECTORS,
  VECTORS_INSERT_ANCHOR,
  VECTORS_DELETE_ANCHOR,
  VECTORS_CONNECT_STROKES,
  VECTORS_DELETE_SEGMENT,
  VECTORS_CONVERT_EDGE,
  VECTORS_FINISHED
} GimpVectorFunction;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_VECTOR_TOOL</NAME>
#define GIMP_TYPE_VECTOR_TOOL            (gimp_vector_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VECTOR_TOOL</NAME>
#define GIMP_VECTOR_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VECTOR_TOOL, GimpVectorTool))
</MACRO>
<MACRO>
<NAME>GIMP_VECTOR_TOOL_CLASS</NAME>
#define GIMP_VECTOR_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VECTOR_TOOL, GimpVectorToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTOR_TOOL</NAME>
#define GIMP_IS_VECTOR_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VECTOR_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTOR_TOOL_CLASS</NAME>
#define GIMP_IS_VECTOR_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VECTOR_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_VECTOR_TOOL_GET_CLASS</NAME>
#define GIMP_VECTOR_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VECTOR_TOOL, GimpVectorToolClass))
</MACRO>
<STRUCT>
<NAME>GimpVectorTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectorToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectorTool</NAME>
struct _GimpVectorTool
{
  GimpDrawTool          parent_instance;

  GimpVectorFunction    function;       /* function we're performing         */
  GimpAnchorFeatureType restriction;    /* movement restriction              */
  gboolean              modifier_lock;  /* can we toggle the Shift key?      */
  GdkModifierType       saved_state;    /* modifier state at button_press    */
  gdouble               last_x;         /* last x coordinate                 */
  gdouble               last_y;         /* last y coordinate                 */
  gboolean              undo_motion;    /* we need a motion to have an undo  */
  gboolean              have_undo;      /* did we push an undo at            */
                                        /* ..._button_press?                 */

  GimpAnchor           *cur_anchor;     /* the current Anchor                */
  GimpAnchor           *cur_anchor2;    /* secondary Anchor (end on_curve)   */
  GimpStroke           *cur_stroke;     /* the current Stroke                */
  gdouble               cur_position;   /* the current Position on a segment */
  GimpVectors          *cur_vectors;    /* the vectors the tool is hovering  */
                                        /* over (if different from ->vectors */
  GimpVectors          *vectors;        /* the current Vector data           */

  gint                  sel_count;      /* number of selected anchors        */
  GimpAnchor           *sel_anchor;     /* currently selected anchor, NULL   */
                                        /* if multiple anchors are selected  */
  GimpStroke           *sel_stroke;     /* selected stroke                   */

  GimpVectorMode        saved_mode;     /* used by modifier_key()            */
};
</STRUCT>
<STRUCT>
<NAME>GimpVectorToolClass</NAME>
struct _GimpVectorToolClass
{
  GimpDrawToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_vector_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_vector_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_vector_tool_set_vectors</NAME>
<RETURNS>void    </RETURNS>
GimpVectorTool *vector_tool,GimpVectors    *vectors
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_init</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_exit</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_get_active</NAME>
<RETURNS>GimpTool *</RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_select_tool</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpTool         *tool
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_push_tool</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpTool         *tool
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_pop_tool</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_initialize_active</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp             *gimp,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_control_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpToolAction    action,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_button_press_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpCoords       *coords,guint32           time,GdkModifierType   state,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_button_release_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpCoords       *coords,guint32           time,GdkModifierType   state,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_motion_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpCoords       *coords,guint32           time,GdkModifierType   state,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_key_press_active</NAME>
<RETURNS>gboolean   </RETURNS>
Gimp             *gimp,GdkEventKey      *kevent,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_focus_display_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_modifier_state_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GdkModifierType   state,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_oper_update_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpCoords       *coords,GdkModifierType   state,gboolean          proximity,GimpDisplay      *display
</FUNCTION>
<FUNCTION>
<NAME>tool_manager_cursor_update_active</NAME>
<RETURNS>void       </RETURNS>
Gimp             *gimp,GimpCoords       *coords,GdkModifierType   state,GimpDisplay      *display
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_PICK_MODE</NAME>
#define GIMP_TYPE_COLOR_PICK_MODE (gimp_color_pick_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_color_pick_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpColorPickMode</NAME>
typedef enum
{
  GIMP_COLOR_PICK_MODE_NONE,       /*< desc="Pick only"            >*/
  GIMP_COLOR_PICK_MODE_FOREGROUND, /*< desc="Set foreground color" >*/
  GIMP_COLOR_PICK_MODE_BACKGROUND, /*< desc="Set background color" >*/
  GIMP_COLOR_PICK_MODE_PALETTE     /*< desc="Add to palette"       >*/
} GimpColorPickMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CROP_MODE</NAME>
#define GIMP_TYPE_CROP_MODE (gimp_crop_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_crop_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCropMode</NAME>
typedef enum
{
  GIMP_CROP_MODE_CROP,   /*< desc="Crop"   >*/
  GIMP_CROP_MODE_RESIZE  /*< desc="Resize" >*/
} GimpCropMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_RECTANGLE_MODE</NAME>
#define GIMP_TYPE_RECTANGLE_MODE (gimp_rectangle_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_rectangle_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpRectangleMode</NAME>
typedef enum
{
  GIMP_RECTANGLE_MODE_EXECUTE,   /*< desc="Execute"   >*/
  GIMP_RECTANGLE_MODE_RESIZE     /*< desc="Resize" >*/
} GimpRectangleMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_RECT_SELECT_MODE</NAME>
#define GIMP_TYPE_RECT_SELECT_MODE (gimp_rect_select_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_rect_select_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpRectSelectMode</NAME>
typedef enum
{
  GIMP_RECT_SELECT_MODE_FREE,        /*< desc="Free select"        >*/
  GIMP_RECT_SELECT_MODE_FIXED_SIZE,  /*< desc="Fixed size"         >*/
  GIMP_RECT_SELECT_MODE_FIXED_RATIO  /*< desc="Fixed aspect ratio" >*/
} GimpRectSelectMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TRANSFORM_TYPE</NAME>
#define GIMP_TYPE_TRANSFORM_TYPE (gimp_transform_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_transform_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTransformType</NAME>
typedef enum
{
  GIMP_TRANSFORM_TYPE_LAYER,     /*< desc="Transform layer"     >*/
  GIMP_TRANSFORM_TYPE_SELECTION, /*< desc="Transform selection" >*/
  GIMP_TRANSFORM_TYPE_PATH       /*< desc="Transform path"      >*/
} GimpTransformType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_VECTOR_MODE</NAME>
#define GIMP_TYPE_VECTOR_MODE (gimp_vector_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_vector_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpVectorMode</NAME>
typedef enum
{
  GIMP_VECTOR_MODE_DESIGN,      /*< desc="Design" >*/
  GIMP_VECTOR_MODE_EDIT,        /*< desc="Edit"   >*/
  GIMP_VECTOR_MODE_MOVE         /*< desc="Move"   >*/
} GimpVectorMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TRANSFORM_PREVIEW_TYPE</NAME>
#define GIMP_TYPE_TRANSFORM_PREVIEW_TYPE (gimp_transform_preview_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_transform_preview_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTransformPreviewType</NAME>
typedef enum
{
  GIMP_TRANSFORM_PREVIEW_TYPE_OUTLINE,     /*< desc="Outline"      >*/
  GIMP_TRANSFORM_PREVIEW_TYPE_GRID,        /*< desc="Grid"         >*/
  GIMP_TRANSFORM_PREVIEW_TYPE_IMAGE,       /*< desc="Image"        >*/
  GIMP_TRANSFORM_PREVIEW_TYPE_IMAGE_GRID   /*< desc="Image + Grid" >*/
} GimpTransformPreviewType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TRANSFORM_GRID_TYPE</NAME>
#define GIMP_TYPE_TRANSFORM_GRID_TYPE (gimp_transform_grid_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_transform_grid_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTransformGridType</NAME>
typedef enum
{
  GIMP_TRANSFORM_GRID_TYPE_N_LINES,  /*< desc="Number of grid lines" >*/
  GIMP_TRANSFORM_GRID_TYPE_SPACING   /*< desc="Grid line spacing"    >*/
} GimpTransformGridType;
</ENUM>
<ENUM>
<NAME>SelectOps</NAME>
typedef enum /*< skip >*/
{
  SELECTION_ADD       = GIMP_CHANNEL_OP_ADD,
  SELECTION_SUBTRACT  = GIMP_CHANNEL_OP_SUBTRACT,
  SELECTION_REPLACE   = GIMP_CHANNEL_OP_REPLACE,
  SELECTION_INTERSECT = GIMP_CHANNEL_OP_INTERSECT,
  SELECTION_MOVE_MASK,
  SELECTION_MOVE,
  SELECTION_MOVE_COPY,
  SELECTION_ANCHOR
} SelectOps;
</ENUM>
<ENUM>
<NAME>GimpToolAction</NAME>
typedef enum /*< skip >*/
{
  PAUSE,
  RESUME,
  HALT
} GimpToolAction;
</ENUM>
<ENUM>
<NAME>GimpTranslateMode</NAME>
typedef enum /*< skip >*/
{
  GIMP_TRANSLATE_MODE_VECTORS,
  GIMP_TRANSLATE_MODE_CHANNEL,
  GIMP_TRANSLATE_MODE_LAYER_MASK,
  GIMP_TRANSLATE_MODE_MASK,
  GIMP_TRANSLATE_MODE_MASK_TO_LAYER,
  GIMP_TRANSLATE_MODE_MASK_COPY_TO_LAYER,
  GIMP_TRANSLATE_MODE_LAYER,
  GIMP_TRANSLATE_MODE_FLOATING_SEL
} GimpTranslateMode;
</ENUM>
<ENUM>
<NAME>GimpMotionMode</NAME>
typedef enum /*< skip >*/
{
  GIMP_MOTION_MODE_EXACT,
  GIMP_MOTION_MODE_HINT,
  GIMP_MOTION_MODE_COMPRESS
} GimpMotionMode;
</ENUM>
<ENUM>
<NAME>TransformAction</NAME>
typedef enum /*< skip >*/
{
  TRANSFORM_CREATING,
  TRANSFORM_HANDLE_1,
  TRANSFORM_HANDLE_2,
  TRANSFORM_HANDLE_3,
  TRANSFORM_HANDLE_4,
  TRANSFORM_HANDLE_CENTER
} TransformAction;
</ENUM>
<STRUCT>
<NAME>GimpTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolControl</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDrawTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageMapTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaintTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTransformTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorOptions</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageMapOptions</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GimpToolOptionsGUIFunc</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpToolRegisterCallback</NAME>
<RETURNS>void </RETURNS>
GType                     tool_type,
                                           GType                     tool_option_type,
                                           GimpToolOptionsGUIFunc    options_gui_func,
                                           GimpContextPropMask       context_props,
                                           const gchar              *identifier,
                                           const gchar              *blurb,
                                           const gchar              *help,
                                           const gchar              *menu_path,
                                           const gchar              *menu_accel,
                                           const gchar              *help_domain,
                                           const gchar              *help_data,
                                           const gchar              *stock_id,
                                           gpointer                  register_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpToolRegisterFunc</NAME>
<RETURNS>void </RETURNS>
GimpToolRegisterCallback  callback,
                                           gpointer                  register_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_tool_motion_constrain</NAME>
<RETURNS>void  </RETURNS>
gdouble   start_x,gdouble   start_y,gdouble  *end_x,gdouble  *end_y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ALIGN_OPTIONS</NAME>
#define GIMP_TYPE_ALIGN_OPTIONS            (gimp_align_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ALIGN_OPTIONS</NAME>
#define GIMP_ALIGN_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ALIGN_OPTIONS, GimpAlignOptions))
</MACRO>
<MACRO>
<NAME>GIMP_ALIGN_OPTIONS_CLASS</NAME>
#define GIMP_ALIGN_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ALIGN_OPTIONS, GimpAlignOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ALIGN_OPTIONS</NAME>
#define GIMP_IS_ALIGN_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ALIGN_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ALIGN_OPTIONS_CLASS</NAME>
#define GIMP_IS_ALIGN_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ALIGN_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_ALIGN_OPTIONS_GET_CLASS</NAME>
#define GIMP_ALIGN_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ALIGN_OPTIONS, GimpAlignOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpAlignOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpAlignOptionsClass</NAME>
typedef struct _GimpToolOptionsClass GimpAlignOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpAlignOptions</NAME>
struct _GimpAlignOptions
{
  GimpToolOptions    parent_instence;

  GimpTransformType  align_type;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_align_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_align_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ALIGN_TOOL</NAME>
#define GIMP_TYPE_ALIGN_TOOL            (gimp_align_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ALIGN_TOOL</NAME>
#define GIMP_ALIGN_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ALIGN_TOOL, GimpAlignTool))
</MACRO>
<MACRO>
<NAME>GIMP_ALIGN_TOOL_CLASS</NAME>
#define GIMP_ALIGN_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ALIGN_TOOL, GimpAlignToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ALIGN_TOOL</NAME>
#define GIMP_IS_ALIGN_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ALIGN_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ALIGN_TOOL_CLASS</NAME>
#define GIMP_IS_ALIGN_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ALIGN_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_ALIGN_TOOL_GET_CLASS</NAME>
#define GIMP_ALIGN_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ALIGN_TOOL, GimpAlignToolClass))
</MACRO>
<MACRO>
<NAME>ALIGN_TOOL_NUM_BUTTONS</NAME>
#define ALIGN_TOOL_NUM_BUTTONS 6
</MACRO>
<STRUCT>
<NAME>GimpAlignTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAlignToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAlignTool</NAME>
struct _GimpAlignTool
{
  GimpDrawTool         parent_instance;

  GtkWidget           *controls;
  GtkWidget           *button[ALIGN_TOOL_NUM_BUTTONS];

  GimpItem            *target_item;
  GimpItem            *reference_item;

  gboolean             select_reference;

  GimpAlignmentType    target_horz_align_type;
  GimpAlignmentType    target_vert_align_type;
  GimpAlignmentType    ref_horz_align_type;
  GimpAlignmentType    ref_vert_align_type;

  gdouble              horz_offset;
  gdouble              vert_offset;

  GtkObject           *horz_offset_adjustment;
  GtkObject           *vert_offset_adjustment;

};
</STRUCT>
<STRUCT>
<NAME>GimpAlignToolClass</NAME>
struct _GimpAlignToolClass
{
  GimpDrawToolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_align_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_align_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FOREGROUND_SELECT_OPTIONS</NAME>
#define GIMP_TYPE_FOREGROUND_SELECT_OPTIONS            (gimp_foreground_select_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FOREGROUND_SELECT_OPTIONS</NAME>
#define GIMP_FOREGROUND_SELECT_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FOREGROUND_SELECT_OPTIONS, GimpForegroundSelectOptions))
</MACRO>
<MACRO>
<NAME>GIMP_FOREGROUND_SELECT_OPTIONS_CLASS</NAME>
#define GIMP_FOREGROUND_SELECT_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FOREGROUND_SELECT_OPTIONS, GimpForegroundSelectOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FOREGROUND_SELECT_OPTIONS</NAME>
#define GIMP_IS_FOREGROUND_SELECT_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FOREGROUND_SELECT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FOREGROUND_SELECT_OPTIONS_CLASS</NAME>
#define GIMP_IS_FOREGROUND_SELECT_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FOREGROUND_SELECT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_FOREGROUND_SELECT_OPTIONS_GET_CLASS</NAME>
#define GIMP_FOREGROUND_SELECT_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FOREGROUND_SELECT_OPTIONS, GimpForegroundSelectOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpForegroundSelectOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpForegroundSelectOptionsClass</NAME>
typedef GimpSelectionOptionsClass  GimpForegroundSelectOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpForegroundSelectOptions</NAME>
struct _GimpForegroundSelectOptions
{
  GimpSelectionOptions  parent_instance;

  gboolean              contiguous;
  gboolean              background;
  gint                  stroke_width;
  gint                  smoothness;
  GimpChannelType       mask_color;
  gboolean              expanded;
  gdouble               sensitivity[3];
};
</STRUCT>
<FUNCTION>
<NAME>gimp_foreground_select_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_foreground_select_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_foreground_select_tool_push_undo</NAME>
<RETURNS>gboolean   </RETURNS>
GimpImage   *image,const gchar *undo_desc,gint         tool_ID
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FOREGROUND_SELECT_TOOL</NAME>
#define GIMP_TYPE_FOREGROUND_SELECT_TOOL            (gimp_foreground_select_tool_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FOREGROUND_SELECT_TOOL</NAME>
#define GIMP_FOREGROUND_SELECT_TOOL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FOREGROUND_SELECT_TOOL, GimpForegroundSelectTool))
</MACRO>
<MACRO>
<NAME>GIMP_FOREGROUND_SELECT_TOOL_CLASS</NAME>
#define GIMP_FOREGROUND_SELECT_TOOL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FOREGROUND_SELECT_TOOL, GimpForegroundSelectToolClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FOREGROUND_SELECT_TOOL</NAME>
#define GIMP_IS_FOREGROUND_SELECT_TOOL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FOREGROUND_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FOREGROUND_SELECT_TOOL_CLASS</NAME>
#define GIMP_IS_FOREGROUND_SELECT_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FOREGROUND_SELECT_TOOL))
</MACRO>
<MACRO>
<NAME>GIMP_FOREGROUND_SELECT_TOOL_GET_CLASS</NAME>
#define GIMP_FOREGROUND_SELECT_TOOL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FOREGROUND_SELECT_TOOL, GimpForegroundSelectToolClass))
</MACRO>
<STRUCT>
<NAME>GimpForegroundSelectTool</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpForegroundSelectToolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpForegroundSelectTool</NAME>
struct _GimpForegroundSelectTool
{
  GimpFreeSelectTool  parent_instance;

  guint               idle_id;
  GArray             *stroke;
  GList              *strokes;
  GimpChannel        *mask;
  SioxState          *state;
  SioxRefinementType  refinement;
};
</STRUCT>
<STRUCT>
<NAME>GimpForegroundSelectToolClass</NAME>
struct _GimpForegroundSelectToolClass
{
  GimpFreeSelectToolClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_foreground_select_tool_register</NAME>
<RETURNS>void    </RETURNS>
GimpToolRegisterCallback  callback,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>gimp_foreground_select_tool_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_NEW_RECT_SELECT_OPTIONS</NAME>
#define GIMP_TYPE_NEW_RECT_SELECT_OPTIONS            (gimp_new_rect_select_options_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_NEW_RECT_SELECT_OPTIONS</NAME>
#define GIMP_NEW_RECT_SELECT_OPTIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_NEW_RECT_SELECT_OPTIONS, GimpNewRectSelectOptions))
</MACRO>
<MACRO>
<NAME>GIMP_NEW_RECT_SELECT_OPTIONS_CLASS</NAME>
#define GIMP_NEW_RECT_SELECT_OPTIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_NEW_RECT_SELECT_OPTIONS, GimpNewRectSelectOptionsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NEW_RECT_SELECT_OPTIONS</NAME>
#define GIMP_IS_NEW_RECT_SELECT_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_NEW_RECT_SELECT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NEW_RECT_SELECT_OPTIONS_CLASS</NAME>
#define GIMP_IS_NEW_RECT_SELECT_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_NEW_RECT_SELECT_OPTIONS))
</MACRO>
<MACRO>
<NAME>GIMP_NEW_RECT_SELECT_OPTIONS_GET_CLASS</NAME>
#define GIMP_NEW_RECT_SELECT_OPTIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_NEW_RECT_SELECT_OPTIONS, GimpNewRectSelectOptionsClass))
</MACRO>
<STRUCT>
<NAME>GimpNewRectSelectOptions</NAME>
</STRUCT>
<TYPEDEF>
<NAME>GimpNewRectSelectOptionsClass</NAME>
typedef struct _GimpToolOptionsClass     GimpNewRectSelectOptionsClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpNewRectSelectOptions</NAME>
struct _GimpNewRectSelectOptions
{
  GimpSelectionOptions  parent_instence;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_new_rect_select_options_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_new_rect_select_options_gui</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolOptions *tool_options
</FUNCTION>
<MACRO>
<NAME>GIMP_ANCHOR</NAME>
#define GIMP_ANCHOR(anchor)  ((GimpAnchor *) (anchor))
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_ANCHOR</NAME>
#define GIMP_TYPE_ANCHOR               (gimp_anchor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VALUE_HOLDS_ANCHOR</NAME>
#define GIMP_VALUE_HOLDS_ANCHOR(value) (G_TYPE_CHECK_VALUE_TYPE ((value), GIMP_TYPE_ANCHOR))
</MACRO>
<FUNCTION>
<NAME>gimp_anchor_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GimpAnchor</NAME>
struct _GimpAnchor
{
  GimpCoords        position;

  GimpAnchorType    type;   /* Interpretation dependant on GimpStroke type */
  gboolean          selected;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_anchor_new</NAME>
<RETURNS>GimpAnchor  *</RETURNS>
GimpAnchorType    type,const GimpCoords *position
</FUNCTION>
<FUNCTION>
<NAME>gimp_anchor_free</NAME>
<RETURNS>void          </RETURNS>
GimpAnchor       *anchor
</FUNCTION>
<FUNCTION>
<NAME>gimp_anchor_duplicate</NAME>
<RETURNS>GimpAnchor  *</RETURNS>
const GimpAnchor *anchor
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BEZIER_STROKE</NAME>
#define GIMP_TYPE_BEZIER_STROKE            (gimp_bezier_stroke_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BEZIER_STROKE</NAME>
#define GIMP_BEZIER_STROKE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BEZIER_STROKE, GimpBezierStroke))
</MACRO>
<MACRO>
<NAME>GIMP_BEZIER_STROKE_CLASS</NAME>
#define GIMP_BEZIER_STROKE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BEZIER_STROKE, GimpBezierStrokeClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BEZIER_STROKE</NAME>
#define GIMP_IS_BEZIER_STROKE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BEZIER_STROKE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BEZIER_STROKE_CLASS</NAME>
#define GIMP_IS_BEZIER_STROKE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BEZIER_STROKE))
</MACRO>
<MACRO>
<NAME>GIMP_BEZIER_STROKE_GET_CLASS</NAME>
#define GIMP_BEZIER_STROKE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BEZIER_STROKE, GimpBezierStrokeClass))
</MACRO>
<STRUCT>
<NAME>GimpBezierStrokeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBezierStroke</NAME>
struct _GimpBezierStroke
{
  GimpStroke  parent_instance;

  /* Stuff missing? */
};
</STRUCT>
<STRUCT>
<NAME>GimpBezierStrokeClass</NAME>
struct _GimpBezierStrokeClass
{
  GimpStrokeClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_bezier_stroke_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_new</NAME>
<RETURNS>GimpStroke *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_new_from_coords</NAME>
<RETURNS>GimpStroke *</RETURNS>
const GimpCoords *coords,gint              n_coords,gboolean          closed
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_new_moveto</NAME>
<RETURNS>GimpStroke *</RETURNS>
const GimpCoords *start
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_lineto</NAME>
<RETURNS>void         </RETURNS>
GimpStroke       *bez_stroke,const GimpCoords *end
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_conicto</NAME>
<RETURNS>void         </RETURNS>
GimpStroke       *bez_stroke,const GimpCoords *control,const GimpCoords *end
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_cubicto</NAME>
<RETURNS>void         </RETURNS>
GimpStroke       *bez_stroke,const GimpCoords *control1,const GimpCoords *control2,const GimpCoords *end
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_arcto</NAME>
<RETURNS>void         </RETURNS>
GimpStroke       *bez_stroke,gdouble           radius_x,gdouble           radius_y,gdouble           angle_rad,gboolean          large_arc,gboolean          sweep,const GimpCoords *end
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_new_ellipse</NAME>
<RETURNS>GimpStroke *</RETURNS>
const GimpCoords *center,gdouble           radius_x,gdouble           radius_y,gdouble           angle
</FUNCTION>
<FUNCTION>
<NAME>gimp_bezier_stroke_extend</NAME>
<RETURNS>GimpAnchor *</RETURNS>
GimpStroke           *stroke,const GimpCoords     *coords,GimpAnchor           *neighbor,GimpVectorExtendMode  extend_mode
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_STROKE</NAME>
#define GIMP_TYPE_STROKE            (gimp_stroke_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_STROKE</NAME>
#define GIMP_STROKE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_STROKE, GimpStroke))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_CLASS</NAME>
#define GIMP_STROKE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_STROKE, GimpStrokeClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE</NAME>
#define GIMP_IS_STROKE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_STROKE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_CLASS</NAME>
#define GIMP_IS_STROKE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_STROKE))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_GET_CLASS</NAME>
#define GIMP_STROKE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_STROKE, GimpStrokeClass))
</MACRO>
<STRUCT>
<NAME>GimpStrokeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStroke</NAME>
struct _GimpStroke
{
  GimpObject  parent_instance;
  gint        ID;

  GList      *anchors;

  gboolean    closed;
};
</STRUCT>
<STRUCT>
<NAME>GimpStrokeClass</NAME>
struct _GimpStrokeClass
{
  GimpObjectClass  parent_class;

  void          (* changed)              (GimpStroke            *stroke);
  void          (* removed)              (GimpStroke            *stroke);

  GimpAnchor  * (* anchor_get)           (const GimpStroke      *stroke,
                                          const GimpCoords      *coord);
  gdouble       (* nearest_point_get)    (const GimpStroke      *stroke,
                                          const GimpCoords      *coord,
                                          const gdouble          precision,
                                          GimpCoords            *ret_point,
                                          GimpAnchor           **ret_segment_start,
                                          GimpAnchor           **ret_segment_end,
                                          gdouble               *ret_pos);
  gdouble       (* nearest_tangent_get)  (const GimpStroke      *stroke,
                                          const GimpCoords      *coord1,
                                          const GimpCoords      *coord2,
                                          const gdouble          precision,
                                          GimpCoords            *nearest,
                                          GimpAnchor           **ret_segment_start,
                                          GimpAnchor           **ret_segment_end,
                                          gdouble               *ret_pos);
  gdouble       (* nearest_intersection_get)
                                         (const GimpStroke      *stroke,
                                          const GimpCoords      *coord1,
                                          const GimpCoords      *direction,
                                          const gdouble          precision,
                                          GimpCoords            *nearest,
                                          GimpAnchor           **ret_segment_start,
                                          GimpAnchor           **ret_segment_end,
                                          gdouble               *ret_pos);
  GimpAnchor  * (* anchor_get_next)      (const GimpStroke      *stroke,
                                          const GimpAnchor      *prev);
  void          (* anchor_select)        (GimpStroke            *stroke,
                                          GimpAnchor            *anchor,
                                          gboolean               selected,
                                          gboolean               exclusive);
  void          (* anchor_move_relative) (GimpStroke            *stroke,
                                          GimpAnchor            *anchor,
                                          const GimpCoords      *deltacoord,
                                          GimpAnchorFeatureType  feature);
  void          (* anchor_move_absolute) (GimpStroke            *stroke,
                                          GimpAnchor            *anchor,
                                          const GimpCoords      *coord,
                                          GimpAnchorFeatureType  feature);
  void          (* anchor_convert)       (GimpStroke            *stroke,
                                          GimpAnchor            *anchor,
                                          GimpAnchorFeatureType  feature);
  void          (* anchor_delete)        (GimpStroke            *stroke,
                                          GimpAnchor            *anchor);

  gboolean      (* point_is_movable)     (GimpStroke            *stroke,
                                          GimpAnchor            *predec,
                                          gdouble                position);
  void          (* point_move_relative)  (GimpStroke            *stroke,
                                          GimpAnchor            *predec,
                                          gdouble                position,
                                          const GimpCoords      *deltacoord,
                                          GimpAnchorFeatureType  feature);
  void          (* point_move_absolute)  (GimpStroke            *stroke,
                                          GimpAnchor            *predec,
                                          gdouble                position,
                                          const GimpCoords      *coord,
                                          GimpAnchorFeatureType  feature);

  void          (* close)                (GimpStroke            *stroke);
  GimpStroke  * (* open)                 (GimpStroke            *stroke,
                                          GimpAnchor            *end_anchor);
  gboolean      (* anchor_is_insertable) (GimpStroke            *stroke,
                                          GimpAnchor            *predec,
                                          gdouble                position);
  GimpAnchor  * (* anchor_insert)        (GimpStroke            *stroke,
                                          GimpAnchor            *predec,
                                          gdouble                position);
  gboolean      (* is_extendable)        (GimpStroke            *stroke,
                                          GimpAnchor            *neighbor);
  GimpAnchor  * (* extend)               (GimpStroke            *stroke,
                                          const GimpCoords      *coords,
                                          GimpAnchor            *neighbor,
                                          GimpVectorExtendMode   extend_mode);
  gboolean      (* connect_stroke)       (GimpStroke            *stroke,
                                          GimpAnchor            *anchor,
                                          GimpStroke            *extension,
                                          GimpAnchor            *neighbor);

  gboolean      (* is_empty)             (const GimpStroke      *stroke);
  gdouble       (* get_length)           (const GimpStroke      *stroke,
                                          const gdouble          precision);
  gdouble       (* get_distance)         (const GimpStroke      *stroke,
                                          const GimpCoords      *coord);
  gboolean      (* get_point_at_dist)    (const GimpStroke      *stroke,
                                          const gdouble          dist,
                                          const gdouble          precision,
                                          GimpCoords            *position,
                                          gdouble               *slope);

  GArray      * (* interpolate)          (const GimpStroke      *stroke,
                                          const gdouble          precision,
                                          gboolean              *ret_closed);

  GimpStroke  * (* duplicate)            (const GimpStroke      *stroke);

  GimpStroke  * (* make_bezier)          (const GimpStroke      *stroke);

  void          (* translate)            (GimpStroke            *stroke,
                                          gdouble                offset_x,
                                          gdouble                offset_y);
  void          (* scale)                (GimpStroke            *stroke,
                                          gdouble                scale_x,
                                          gdouble                scale_y);
  void          (* transform)            (GimpStroke            *stroke,
                                          const GimpMatrix3     *matrix);

  GList       * (* get_draw_anchors)     (const GimpStroke      *stroke);
  GList       * (* get_draw_controls)    (const GimpStroke      *stroke);
  GArray      * (* get_draw_lines)       (const GimpStroke      *stroke);
  GArray      * (* control_points_get)   (const GimpStroke      *stroke,
                                          gboolean              *ret_closed);

  void          (* art_stroke)           (const GimpStroke      *stroke);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_stroke_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_set_ID</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,gint                   id
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_ID</NAME>
<RETURNS>gint         </RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_control_points_get</NAME>
<RETURNS>GArray     *</RETURNS>
const GimpStroke      *stroke,gboolean              *closed
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_get</NAME>
<RETURNS>GimpAnchor *</RETURNS>
const GimpStroke      *stroke,const GimpCoords      *coord
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_nearest_point_get</NAME>
<RETURNS>gdouble      </RETURNS>
const GimpStroke      *stroke,const GimpCoords      *coord,const gdouble          precision,GimpCoords            *ret_point,GimpAnchor           **ret_segment_start,GimpAnchor           **ret_segment_end,gdouble               *ret_pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_nearest_tangent_get</NAME>
<RETURNS>gdouble     </RETURNS>
const GimpStroke      *stroke,const GimpCoords      *coords1,const GimpCoords      *coords2,gdouble                precision,GimpCoords            *nearest,GimpAnchor           **ret_segment_start,GimpAnchor           **ret_segment_end,gdouble               *ret_pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_nearest_intersection_get</NAME>
<RETURNS>gdouble  </RETURNS>
const GimpStroke      *stroke,const GimpCoords      *coords1,const GimpCoords      *direction,gdouble                precision,GimpCoords            *nearest,GimpAnchor           **ret_segment_start,GimpAnchor           **ret_segment_end,gdouble               *ret_pos
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_get_next</NAME>
<RETURNS>GimpAnchor *</RETURNS>
const GimpStroke      *stroke,const GimpAnchor      *prev
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_select</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *anchor,gboolean               selected,gboolean               exclusive
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_move_relative</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *anchor,const GimpCoords      *delta,GimpAnchorFeatureType  feature
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_move_absolute</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *anchor,const GimpCoords      *coord,GimpAnchorFeatureType  feature
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_point_is_movable</NAME>
<RETURNS>gboolean     </RETURNS>
GimpStroke            *stroke,GimpAnchor            *predec,gdouble                position
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_point_move_relative</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *predec,gdouble                position,const GimpCoords      *deltacoord,GimpAnchorFeatureType  feature
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_point_move_absolute</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *predec,gdouble                position,const GimpCoords      *coord,GimpAnchorFeatureType  feature
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_close</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_convert</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *anchor,GimpAnchorFeatureType  feature
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_delete</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,GimpAnchor            *anchor
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_open</NAME>
<RETURNS>GimpStroke *</RETURNS>
GimpStroke            *stroke,GimpAnchor            *end_anchor
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_is_insertable</NAME>
<RETURNS>gboolean     </RETURNS>
GimpStroke            *stroke,GimpAnchor            *predec,gdouble                position
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_anchor_insert</NAME>
<RETURNS>GimpAnchor *</RETURNS>
GimpStroke            *stroke,GimpAnchor            *predec,gdouble                position
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_is_extendable</NAME>
<RETURNS>gboolean     </RETURNS>
GimpStroke            *stroke,GimpAnchor            *neighbor
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_extend</NAME>
<RETURNS>GimpAnchor *</RETURNS>
GimpStroke            *stroke,const GimpCoords      *coords,GimpAnchor            *neighbor,GimpVectorExtendMode   extend_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_connect_stroke</NAME>
<RETURNS>gboolean     </RETURNS>
GimpStroke            *stroke,GimpAnchor            *anchor,GimpStroke            *extension,GimpAnchor            *neighbor
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_is_empty</NAME>
<RETURNS>gboolean     </RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_length</NAME>
<RETURNS>gdouble      </RETURNS>
const GimpStroke      *stroke,const gdouble          precision
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_distance</NAME>
<RETURNS>gdouble      </RETURNS>
const GimpStroke      *stroke,const GimpCoords      *coord
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_point_at_dist</NAME>
<RETURNS>gboolean     </RETURNS>
const GimpStroke      *stroke,const gdouble          dist,const gdouble          precision,GimpCoords            *position,gdouble               *slope
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_interpolate</NAME>
<RETURNS>GArray     *</RETURNS>
const GimpStroke      *stroke,const gdouble          precision,gboolean              *closed
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_duplicate</NAME>
<RETURNS>GimpStroke *</RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_make_bezier</NAME>
<RETURNS>GimpStroke *</RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_translate</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,gdouble                offset_x,gdouble                offset_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_scale</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,gdouble                scale_x,gdouble                scale_y
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_transform</NAME>
<RETURNS>void         </RETURNS>
GimpStroke            *stroke,const GimpMatrix3     *matrix
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_draw_anchors</NAME>
<RETURNS>GList      *</RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_draw_controls</NAME>
<RETURNS>GList      *</RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_get_draw_lines</NAME>
<RETURNS>GArray     *</RETURNS>
const GimpStroke      *stroke
</FUNCTION>
<STRUCT>
<NAME>GimpVectorsCompatPoint</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectorsCompatPoint</NAME>
struct _GimpVectorsCompatPoint
{
  guint32 type;
  gdouble x;
  gdouble y;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_vectors_compat_new</NAME>
<RETURNS>GimpVectors *</RETURNS>
GimpImage              *image,const gchar            *name,GimpVectorsCompatPoint *points,gint                    n_points,gboolean                closed
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_compat_is_compatible</NAME>
<RETURNS>gboolean              </RETURNS>
GimpImage   *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_compat_get_points</NAME>
<RETURNS>GimpVectorsCompatPoint *</RETURNS>
GimpVectors *vectors,gint32      *n_points,gint32      *closed
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_export_file</NAME>
<RETURNS>gboolean   </RETURNS>
const GimpImage    *image,const GimpVectors  *vectors,const gchar        *filename,GError            **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_export_string</NAME>
<RETURNS>gchar    *</RETURNS>
const GimpImage    *image,const GimpVectors  *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_import_file</NAME>
<RETURNS>gboolean  </RETURNS>
GimpImage    *image,const gchar  *filename,gboolean      merge,gboolean      scale,gint          position,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_import_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GimpImage    *image,const gchar  *buffer,gsize         len,gboolean      merge,gboolean      scale,gint          position,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_get_new_preview</NAME>
<RETURNS>TempBuf *</RETURNS>
GimpViewable *viewable,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_warp_point</NAME>
<RETURNS>void </RETURNS>
const GimpVectors *vectors,GimpCoords        *point,GimpCoords        *point_warped,gdouble            y_offset
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_warp_vectors</NAME>
<RETURNS>void </RETURNS>
const GimpVectors *vectors,GimpVectors       *vectors_in,gdouble            yoffset
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VECTORS</NAME>
#define GIMP_TYPE_VECTORS            (gimp_vectors_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VECTORS</NAME>
#define GIMP_VECTORS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VECTORS, GimpVectors))
</MACRO>
<MACRO>
<NAME>GIMP_VECTORS_CLASS</NAME>
#define GIMP_VECTORS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VECTORS, GimpVectorsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTORS</NAME>
#define GIMP_IS_VECTORS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VECTORS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTORS_CLASS</NAME>
#define GIMP_IS_VECTORS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VECTORS))
</MACRO>
<MACRO>
<NAME>GIMP_VECTORS_GET_CLASS</NAME>
#define GIMP_VECTORS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VECTORS, GimpVectorsClass))
</MACRO>
<STRUCT>
<NAME>GimpVectorsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectors</NAME>
struct _GimpVectors
{
  GimpItem  parent_instance;

  GList    *strokes;            /* The List of GimpStrokes        */
  gint      last_stroke_ID;

  gint      freeze_count;
  gdouble   precision;
};
</STRUCT>
<STRUCT>
<NAME>GimpVectorsClass</NAME>
struct _GimpVectorsClass
{
  GimpItemClass  parent_class;

  /*  signals  */
  void          (* freeze)            (GimpVectors       *vectors);
  void          (* thaw)              (GimpVectors       *vectors);

  /*  virtual functions  */
  void          (* stroke_add)        (GimpVectors       *vectors,
                                       GimpStroke        *stroke);
  void          (* stroke_remove)     (GimpVectors       *vectors,
                                       GimpStroke        *stroke);
  GimpStroke  * (* stroke_get)        (const GimpVectors *vectors,
                                       const GimpCoords  *coord);
  GimpStroke  * (* stroke_get_next)   (const GimpVectors *vectors,
                                       const GimpStroke  *prev);
  gdouble       (* stroke_get_length) (const GimpVectors *vectors,
                                       const GimpStroke  *stroke);
  GimpAnchor  * (* anchor_get)        (const GimpVectors *vectors,
                                       const GimpCoords  *coord,
                                       GimpStroke       **ret_stroke);
  void          (* anchor_delete)     (GimpVectors       *vectors,
                                       GimpAnchor        *anchor);
  gdouble       (* get_length)        (const GimpVectors *vectors,
                                       const GimpAnchor  *start);
  gdouble       (* get_distance)      (const GimpVectors *vectors,
                                       const GimpCoords  *coord);
  gint          (* interpolate)       (const GimpVectors *vectors,
                                       const GimpStroke  *stroke,
                                       gdouble            precision,
                                       gint               max_points,
                                       GimpCoords        *ret_coords);
  GimpVectors * (* make_bezier)       (const GimpVectors *vectors);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_vectors_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_new</NAME>
<RETURNS>GimpVectors   *</RETURNS>
GimpImage         *image,const gchar       *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_freeze</NAME>
<RETURNS>void            </RETURNS>
GimpVectors       *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_thaw</NAME>
<RETURNS>void            </RETURNS>
GimpVectors       *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_copy_strokes</NAME>
<RETURNS>void            </RETURNS>
const GimpVectors *src_vectors,GimpVectors       *dest_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_add_strokes</NAME>
<RETURNS>void            </RETURNS>
const GimpVectors *src_vectors,GimpVectors       *dest_vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_anchor_get</NAME>
<RETURNS>GimpAnchor    *</RETURNS>
const GimpVectors *vectors,const GimpCoords  *coord,GimpStroke       **ret_stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_anchor_get_next</NAME>
<RETURNS>GimpAnchor    *</RETURNS>
const GimpVectors  *vectors,const GimpAnchor   *prev
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_anchor_move_relative</NAME>
<RETURNS>void          </RETURNS>
GimpVectors        *vectors,GimpAnchor         *anchor,const GimpCoords   *deltacoord,gint                type
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_anchor_move_absolute</NAME>
<RETURNS>void          </RETURNS>
GimpVectors        *vectors,GimpAnchor         *anchor,const GimpCoords   *coord,gint                type
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_anchor_delete</NAME>
<RETURNS>void          </RETURNS>
GimpVectors        *vectors,GimpAnchor         *anchor
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_anchor_select</NAME>
<RETURNS>void          </RETURNS>
GimpVectors        *vectors,GimpStroke         *target_stroke,GimpAnchor         *anchor,gboolean            selected,gboolean            exclusive
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_stroke_add</NAME>
<RETURNS>void            </RETURNS>
GimpVectors        *vectors,GimpStroke         *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_stroke_remove</NAME>
<RETURNS>void            </RETURNS>
GimpVectors        *vectors,GimpStroke         *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_get_n_strokes</NAME>
<RETURNS>gint            </RETURNS>
const GimpVectors  *vectors
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_stroke_get</NAME>
<RETURNS>GimpStroke    *</RETURNS>
const GimpVectors  *vectors,const GimpCoords   *coord
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_stroke_get_by_ID</NAME>
<RETURNS>GimpStroke    *</RETURNS>
const GimpVectors  *vectors,gint                id
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_stroke_get_next</NAME>
<RETURNS>GimpStroke    *</RETURNS>
const GimpVectors  *vectors,const GimpStroke   *prev
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_stroke_get_length</NAME>
<RETURNS>gdouble         </RETURNS>
const GimpVectors  *vectors,const GimpStroke   *stroke
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_get_length</NAME>
<RETURNS>gdouble         </RETURNS>
const GimpVectors  *vectors,const GimpAnchor   *start
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_get_distance</NAME>
<RETURNS>gdouble         </RETURNS>
const GimpVectors  *vectors,const GimpCoords   *coord
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_bounds</NAME>
<RETURNS>gboolean        </RETURNS>
const GimpVectors  *vectors,gdouble            *x1,gdouble            *y1,gdouble            *x2,gdouble            *y2
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_interpolate</NAME>
<RETURNS>gint            </RETURNS>
const GimpVectors  *vectors,const GimpStroke   *stroke,gdouble             precision,gint                max_points,GimpCoords         *ret_coords
</FUNCTION>
<FUNCTION>
<NAME>gimp_vectors_make_bezier</NAME>
<RETURNS>GimpVectors   *</RETURNS>
const GimpVectors  *vectors
</FUNCTION>
<ENUM>
<NAME>GimpAnchorType</NAME>
typedef enum
{
  GIMP_ANCHOR_ANCHOR,
  GIMP_ANCHOR_CONTROL
} GimpAnchorType;
</ENUM>
<ENUM>
<NAME>GimpAnchorFeatureType</NAME>
typedef enum
{
  GIMP_ANCHOR_FEATURE_NONE,
  GIMP_ANCHOR_FEATURE_EDGE,
  GIMP_ANCHOR_FEATURE_ALIGNED,
  GIMP_ANCHOR_FEATURE_SYMMETRIC
} GimpAnchorFeatureType;
</ENUM>
<ENUM>
<NAME>GimpVectorExtendMode</NAME>
typedef enum
{
  EXTEND_SIMPLE,
  EXTEND_EDITABLE
} GimpVectorExtendMode;
</ENUM>
<STRUCT>
<NAME>GimpAnchor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectors</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStroke</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBezierStroke</NAME>
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_ACTION</NAME>
#define GIMP_TYPE_ACTION            (gimp_action_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ACTION</NAME>
#define GIMP_ACTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ACTION, GimpAction))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_CLASS</NAME>
#define GIMP_ACTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ACTION, GimpActionClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION</NAME>
#define GIMP_IS_ACTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_CLASS</NAME>
#define GIMP_IS_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), GIMP_TYPE_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_GET_CLASS</NAME>
#define GIMP_ACTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GIMP_TYPE_ACTION, GimpActionClass))
</MACRO>
<STRUCT>
<NAME>GimpActionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAction</NAME>
struct _GimpAction
{
  GtkAction     parent_instance;

  GimpRGB      *color;
  GimpViewable *viewable;
};
</STRUCT>
<STRUCT>
<NAME>GimpActionClass</NAME>
struct _GimpActionClass
{
  GtkActionClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_action_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_new</NAME>
<RETURNS>GimpAction *</RETURNS>
const gchar *name,const gchar *label,const gchar *tooltip,const gchar *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_name_compare</NAME>
<RETURNS>gint         </RETURNS>
GimpAction  *action1,GimpAction  *action2
</FUNCTION>
<STRUCT>
<NAME>GimpActionFactoryEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionFactoryEntry</NAME>
struct _GimpActionFactoryEntry
{
  gchar                     *identifier;
  gchar                     *label;
  gchar                     *stock_id;
  GimpActionGroupSetupFunc   setup_func;
  GimpActionGroupUpdateFunc  update_func;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_ACTION_FACTORY</NAME>
#define GIMP_TYPE_ACTION_FACTORY            (gimp_action_factory_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_FACTORY</NAME>
#define GIMP_ACTION_FACTORY(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ACTION_FACTORY, GimpActionFactory))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_FACTORY_CLASS</NAME>
#define GIMP_ACTION_FACTORY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ACTION_FACTORY, GimpActionFactoryClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_FACTORY</NAME>
#define GIMP_IS_ACTION_FACTORY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ACTION_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_FACTORY_CLASS</NAME>
#define GIMP_IS_ACTION_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ACTION_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_FACTORY_GET_CLASS</NAME>
#define GIMP_ACTION_FACTORY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ACTION_FACTORY, GimpActionFactoryClass))
</MACRO>
<STRUCT>
<NAME>GimpActionFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionFactory</NAME>
struct _GimpActionFactory
{
  GimpObject  parent_instance;

  Gimp       *gimp;
  GList      *registered_groups;

  gboolean    mnemonics;
};
</STRUCT>
<STRUCT>
<NAME>GimpActionFactoryClass</NAME>
struct _GimpActionFactoryClass
{
  GimpObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_action_factory_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_factory_new</NAME>
<RETURNS>GimpActionFactory *</RETURNS>
Gimp              *gimp,gboolean           mnemonics
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_factory_group_register</NAME>
<RETURNS>void          </RETURNS>
GimpActionFactory *factory,const gchar       *identifier,const gchar       *label,const gchar       *stock_id,GimpActionGroupSetupFunc  setup_func,GimpActionGroupUpdateFunc update_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_factory_group_new</NAME>
<RETURNS>GimpActionGroup *</RETURNS>
GimpActionFactory *factory,const gchar       *identifier,gpointer           user_data
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ACTION_GROUP</NAME>
#define GIMP_TYPE_ACTION_GROUP              (gimp_action_group_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_GROUP</NAME>
#define GIMP_ACTION_GROUP(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ACTION_GROUP, GimpActionGroup))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_GROUP_CLASS</NAME>
#define GIMP_ACTION_GROUP_CLASS(vtable)     (G_TYPE_CHECK_CLASS_CAST ((vtable), GIMP_TYPE_ACTION_GROUP, GimpActionGroupClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_GROUP</NAME>
#define GIMP_IS_ACTION_GROUP(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_GROUP_CLASS</NAME>
#define GIMP_IS_ACTION_GROUP_CLASS(vtable)  (G_TYPE_CHECK_CLASS_TYPE ((vtable), GIMP_TYPE_ACTION_GROUP))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_GROUP_GET_CLASS</NAME>
#define GIMP_ACTION_GROUP_GET_CLASS(inst)   (G_TYPE_INSTANCE_GET_CLASS ((inst), GIMP_TYPE_ACTION_GROUP, GimpActionGroupClass))
</MACRO>
<STRUCT>
<NAME>GimpActionGroupClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionGroup</NAME>
struct _GimpActionGroup
{
  GtkActionGroup             parent_instance;

  Gimp                      *gimp;
  gchar                     *label;
  gchar                     *stock_id;
  gboolean                   mnemonics;

  gpointer                   user_data;

  GimpActionGroupUpdateFunc  update_func;
};
</STRUCT>
<STRUCT>
<NAME>GimpActionGroupClass</NAME>
struct _GimpActionGroupClass
{
  GtkActionGroupClass  parent_class;

  GHashTable          *groups;
};
</STRUCT>
<STRUCT>
<NAME>GimpActionEntry</NAME>
struct _GimpActionEntry
{
  const gchar *name;
  const gchar *stock_id;
  const gchar *label;
  const gchar *accelerator;
  const gchar *tooltip;
  GCallback    callback;

  const gchar *help_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpToggleActionEntry</NAME>
struct _GimpToggleActionEntry
{
  const gchar *name;
  const gchar *stock_id;
  const gchar *label;
  const gchar *accelerator;
  const gchar *tooltip;
  GCallback    callback;
  gboolean     is_active;

  const gchar *help_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpRadioActionEntry</NAME>
struct _GimpRadioActionEntry
{
  const gchar *name;
  const gchar *stock_id;
  const gchar *label;
  const gchar *accelerator;
  const gchar *tooltip;
  gint         value;

  const gchar *help_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpEnumActionEntry</NAME>
struct _GimpEnumActionEntry
{
  const gchar *name;
  const gchar *stock_id;
  const gchar *label;
  const gchar *accelerator;
  const gchar *tooltip;
  gint         value;
  gboolean     value_variable;

  const gchar *help_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpStringActionEntry</NAME>
struct _GimpStringActionEntry
{
  const gchar *name;
  const gchar *stock_id;
  const gchar *label;
  const gchar *accelerator;
  const gchar *tooltip;
  const gchar *value;

  const gchar *help_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpPlugInActionEntry</NAME>
struct _GimpPlugInActionEntry
{
  const gchar         *name;
  const gchar         *stock_id;
  const gchar         *label;
  const gchar         *accelerator;
  const gchar         *tooltip;
  GimpPlugInProcedure *procedure;

  const gchar         *help_id;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_action_group_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_new</NAME>
<RETURNS>GimpActionGroup *</RETURNS>
Gimp                  *gimp,const gchar           *name,const gchar           *label,const gchar           *stock_id,gboolean               mnemonics,gpointer               user_data,GimpActionGroupUpdateFunc update_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_groups_from_name</NAME>
<RETURNS>GList *</RETURNS>
const gchar           *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_update</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup       *group,gpointer               update_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_add_actions</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup             *group,const GimpActionEntry       *entries,guint                        n_entries
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_add_toggle_actions</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup             *group,const GimpToggleActionEntry *entries,guint                        n_entries
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_add_radio_actions</NAME>
<RETURNS>GSList *</RETURNS>
GimpActionGroup             *group,const GimpRadioActionEntry  *entries,guint                        n_entries,GSList                      *radio_group,gint                         value,GCallback                    callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_add_enum_actions</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup             *group,const GimpEnumActionEntry   *entries,guint                        n_entries,GCallback                    callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_add_string_actions</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup             *group,const GimpStringActionEntry *entries,guint                         n_entries,GCallback                     callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_add_plug_in_actions</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup             *group,const GimpPlugInActionEntry *entries,guint                        n_entries,GCallback                    callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_visible</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,gboolean             visible
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_sensitive</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,gboolean             sensitive
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_active</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,gboolean             active
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_label</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,const gchar         *label
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_color</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,const GimpRGB       *color,gboolean             set_label
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_viewable</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,GimpViewable        *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_group_set_action_hide_empty</NAME>
<RETURNS>void   </RETURNS>
GimpActionGroup     *group,const gchar         *action_name,gboolean             is_important
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ACTION_VIEW</NAME>
#define GIMP_TYPE_ACTION_VIEW            (gimp_action_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_VIEW</NAME>
#define GIMP_ACTION_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ACTION_VIEW, GimpActionView))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_VIEW_CLASS</NAME>
#define GIMP_ACTION_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ACTION_VIEW, GimpActionViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_VIEW</NAME>
#define GIMP_IS_ACTION_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ACTION_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ACTION_VIEW_CLASS</NAME>
#define GIMP_IS_ACTION_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ACTION_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_ACTION_VIEW_GET_CLASS</NAME>
#define GIMP_ACTION_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ACTION_VIEW, GimpActionViewClass))
</MACRO>
<STRUCT>
<NAME>GimpActionViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionView</NAME>
struct _GimpActionView
{
  GtkTreeView    parent_instance;

  GimpUIManager *manager;
  gboolean       show_shortcuts;
};
</STRUCT>
<STRUCT>
<NAME>GimpActionViewClass</NAME>
struct _GimpActionViewClass
{
  GtkTreeViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_action_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_action_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpUIManager *manager,const gchar   *select_action,gboolean       show_shortcuts
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BLOB_EDITOR</NAME>
#define GIMP_TYPE_BLOB_EDITOR            (gimp_blob_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BLOB_EDITOR</NAME>
#define GIMP_BLOB_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BLOB_EDITOR, GimpBlobEditor))
</MACRO>
<MACRO>
<NAME>GIMP_BLOB_EDITOR_CLASS</NAME>
#define GIMP_BLOB_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BLOB_EDITOR, GimpBlobEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BLOB_EDITOR</NAME>
#define GIMP_IS_BLOB_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BLOB_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BLOB_EDITOR_CLASS</NAME>
#define GIMP_IS_BLOB_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BLOB_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_BLOB_EDITOR_GET_CLASS</NAME>
#define GIMP_BLOB_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BLOB_EDITOR, GimpBlobEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpBlobEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBlobEditor</NAME>
struct _GimpBlobEditor
{
  GtkDrawingArea       parent_instance;

  GimpInkBlobType      type;
  gdouble              aspect;
  gdouble              angle;

  /*<  private  >*/
  gboolean             active;
};
</STRUCT>
<STRUCT>
<NAME>GimpBlobEditorClass</NAME>
struct _GimpBlobEditorClass
{
  GtkDrawingAreaClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_blob_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_blob_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpInkBlobType  type,gdouble          aspect,gdouble          angle
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_EDITOR</NAME>
#define GIMP_TYPE_BRUSH_EDITOR            (gimp_brush_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_EDITOR</NAME>
#define GIMP_BRUSH_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH_EDITOR, GimpBrushEditor))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_EDITOR_CLASS</NAME>
#define GIMP_BRUSH_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH_EDITOR, GimpBrushEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_EDITOR</NAME>
#define GIMP_IS_BRUSH_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_EDITOR_CLASS</NAME>
#define GIMP_IS_BRUSH_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_EDITOR_GET_CLASS</NAME>
#define GIMP_BRUSH_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH_EDITOR, GimpBrushEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpBrushEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushEditor</NAME>
struct _GimpBrushEditor
{
  GimpDataEditor  parent_instance;

  GtkWidget      *view;

  GtkWidget      *shape_group;
  GtkWidget      *options_table;
  GtkAdjustment  *radius_data;
  GtkAdjustment  *spikes_data;
  GtkAdjustment  *hardness_data;
  GtkAdjustment  *angle_data;
  GtkAdjustment  *aspect_ratio_data;
  GtkAdjustment  *spacing_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushEditorClass</NAME>
struct _GimpBrushEditorClass
{
  GimpDataEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp            *gimp,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_FACTORY_VIEW</NAME>
#define GIMP_TYPE_BRUSH_FACTORY_VIEW            (gimp_brush_factory_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_FACTORY_VIEW</NAME>
#define GIMP_BRUSH_FACTORY_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH_FACTORY_VIEW, GimpBrushFactoryView))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_FACTORY_VIEW_CLASS</NAME>
#define GIMP_BRUSH_FACTORY_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH_FACTORY_VIEW, GimpBrushFactoryViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_FACTORY_VIEW</NAME>
#define GIMP_IS_BRUSH_FACTORY_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH_FACTORY_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_FACTORY_VIEW_CLASS</NAME>
#define GIMP_IS_BRUSH_FACTORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH_FACTORY_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_FACTORY_VIEW_GET_CLASS</NAME>
#define GIMP_BRUSH_FACTORY_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH_FACTORY_VIEW, GimpBrushFactoryViewClass))
</MACRO>
<STRUCT>
<NAME>GimpBrushFactoryViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushFactoryView</NAME>
struct _GimpBrushFactoryView
{
  GimpDataFactoryView  parent_instance;

  GtkWidget           *spacing_scale;
  GtkAdjustment       *spacing_adjustment;

  gboolean             change_brush_spacing;
  GQuark               spacing_changed_handler_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushFactoryViewClass</NAME>
struct _GimpBrushFactoryViewClass
{
  GimpDataFactoryViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_factory_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_factory_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpDataFactory *factory,GimpContext     *context,gboolean         change_brush_spacing,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BRUSH_SELECT</NAME>
#define GIMP_TYPE_BRUSH_SELECT            (gimp_brush_select_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_SELECT</NAME>
#define GIMP_BRUSH_SELECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BRUSH_SELECT, GimpBrushSelect))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_SELECT_CLASS</NAME>
#define GIMP_BRUSH_SELECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BRUSH_SELECT, GimpBrushSelectClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_SELECT</NAME>
#define GIMP_IS_BRUSH_SELECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BRUSH_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BRUSH_SELECT_CLASS</NAME>
#define GIMP_IS_BRUSH_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BRUSH_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_BRUSH_SELECT_GET_CLASS</NAME>
#define GIMP_BRUSH_SELECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BRUSH_SELECT, GimpBrushSelectClass))
</MACRO>
<STRUCT>
<NAME>GimpBrushSelectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushSelect</NAME>
struct _GimpBrushSelect
{
  GimpPdbDialog         parent_instance;

  gdouble               initial_opacity;
  GimpLayerModeEffects  initial_mode;

  gint                  spacing;
  GtkAdjustment        *opacity_data;
  GtkWidget            *paint_mode_menu;
};
</STRUCT>
<STRUCT>
<NAME>GimpBrushSelectClass</NAME>
struct _GimpBrushSelectClass
{
  GimpPdbDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_brush_select_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_BUFFER_VIEW</NAME>
#define GIMP_TYPE_BUFFER_VIEW            (gimp_buffer_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_BUFFER_VIEW</NAME>
#define GIMP_BUFFER_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_BUFFER_VIEW, GimpBufferView))
</MACRO>
<MACRO>
<NAME>GIMP_BUFFER_VIEW_CLASS</NAME>
#define GIMP_BUFFER_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_BUFFER_VIEW, GimpBufferViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUFFER_VIEW</NAME>
#define GIMP_IS_BUFFER_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_BUFFER_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_BUFFER_VIEW_CLASS</NAME>
#define GIMP_IS_BUFFER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_BUFFER_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_BUFFER_VIEW_GET_CLASS</NAME>
#define GIMP_BUFFER_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_BUFFER_VIEW, GimpBufferViewClass))
</MACRO>
<STRUCT>
<NAME>GimpBufferViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBufferView</NAME>
struct _GimpBufferView
{
  GimpContainerEditor  parent_instance;

  GtkWidget           *global_view;
  GtkWidget           *global_label;

  GtkWidget           *paste_button;
  GtkWidget           *paste_into_button;
  GtkWidget           *paste_as_new_button;
  GtkWidget           *delete_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpBufferViewClass</NAME>
struct _GimpBufferViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_buffer_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_buffer_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpContainer   *container,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CELL_RENDERER_ACCEL</NAME>
#define GIMP_TYPE_CELL_RENDERER_ACCEL            (gimp_cell_renderer_accel_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_ACCEL</NAME>
#define GIMP_CELL_RENDERER_ACCEL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CELL_RENDERER_ACCEL, GimpCellRendererAccel))
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_ACCEL_CLASS</NAME>
#define GIMP_CELL_RENDERER_ACCEL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CELL_RENDERER_ACCEL, GimpCellRendererAccelClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CELL_RENDERER_ACCEL</NAME>
#define GIMP_IS_CELL_RENDERER_ACCEL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CELL_RENDERER_ACCEL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CELL_RENDERER_ACCEL_CLASS</NAME>
#define GIMP_IS_CELL_RENDERER_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CELL_RENDERER_ACCEL))
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_ACCEL_GET_CLASS</NAME>
#define GIMP_CELL_RENDERER_ACCEL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CELL_RENDERER_ACCEL, GimpCellRendererAccelClass))
</MACRO>
<STRUCT>
<NAME>GimpCellRendererAccelClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererAccel</NAME>
struct _GimpCellRendererAccel
{
  GtkCellRendererText  parent_instance;

  guint                accel_key;
  GdkModifierType      accel_mask;

  GtkWidget           *edit_widget;
  GtkWidget           *grab_widget;
  guint                edit_key;

  GtkWidget           *sizing_label;
};
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererAccelClass</NAME>
struct _GimpCellRendererAccelClass
{
  GtkCellRendererTextClass  parent_class;

  void (* accel_edited) (GimpCellRendererAccel *accel,
                         const char            *path_string,
                         gboolean               delete,
                         guint                  accel_key,
                         GdkModifierType        accel_mask);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_cell_renderer_accel_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_cell_renderer_accel_new</NAME>
<RETURNS>GtkCellRenderer *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_cell_renderer_accel_set_accelerator</NAME>
<RETURNS>void </RETURNS>
GimpCellRendererAccel *accel,guint                  accel_kaey,GdkModifierType        accel_mask
</FUNCTION>
<FUNCTION>
<NAME>gimp_cell_renderer_accel_get_accelerator</NAME>
<RETURNS>void </RETURNS>
GimpCellRendererAccel *accel,guint                 *accel_key,GdkModifierType       *accel_mask
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CELL_RENDERER_VIEWABLE</NAME>
#define GIMP_TYPE_CELL_RENDERER_VIEWABLE            (gimp_cell_renderer_viewable_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_VIEWABLE</NAME>
#define GIMP_CELL_RENDERER_VIEWABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CELL_RENDERER_VIEWABLE, GimpCellRendererViewable))
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_VIEWABLE_CLASS</NAME>
#define GIMP_CELL_RENDERER_VIEWABLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CELL_RENDERER_VIEWABLE, GimpCellRendererViewableClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CELL_RENDERER_VIEWABLE</NAME>
#define GIMP_IS_CELL_RENDERER_VIEWABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CELL_RENDERER_VIEWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CELL_RENDERER_VIEWABLE_CLASS</NAME>
#define GIMP_IS_CELL_RENDERER_VIEWABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CELL_RENDERER_VIEWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_VIEWABLE_GET_CLASS</NAME>
#define GIMP_CELL_RENDERER_VIEWABLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CELL_RENDERER_VIEWABLE, GimpCellRendererViewableClass))
</MACRO>
<STRUCT>
<NAME>GimpCellRendererViewableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererViewable</NAME>
struct _GimpCellRendererViewable
{
  GtkCellRenderer   parent_instance;

  GimpViewRenderer *renderer;
};
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererViewableClass</NAME>
struct _GimpCellRendererViewableClass
{
  GtkCellRendererClass  parent_class;

  void (* clicked) (GimpCellRendererViewable *cell,
                    const gchar              *path,
                    GdkModifierType           state);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_cell_renderer_viewable_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_cell_renderer_viewable_new</NAME>
<RETURNS>GtkCellRenderer *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_cell_renderer_viewable_clicked</NAME>
<RETURNS>void   </RETURNS>
GimpCellRendererViewable *cell,const gchar              *path,GdkModifierType           state
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CHANNEL_TREE_VIEW</NAME>
#define GIMP_TYPE_CHANNEL_TREE_VIEW            (gimp_channel_tree_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CHANNEL_TREE_VIEW</NAME>
#define GIMP_CHANNEL_TREE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CHANNEL_TREE_VIEW, GimpChannelTreeView))
</MACRO>
<MACRO>
<NAME>GIMP_CHANNEL_TREE_VIEW_CLASS</NAME>
#define GIMP_CHANNEL_TREE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CHANNEL_TREE_VIEW, GimpChannelTreeViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CHANNEL_TREE_VIEW</NAME>
#define GIMP_IS_CHANNEL_TREE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CHANNEL_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CHANNEL_TREE_VIEW_CLASS</NAME>
#define GIMP_IS_CHANNEL_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CHANNEL_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_CHANNEL_TREE_VIEW_GET_CLASS</NAME>
#define GIMP_CHANNEL_TREE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CHANNEL_TREE_VIEW, GimpChannelTreeViewClass))
</MACRO>
<STRUCT>
<NAME>GimpChannelTreeViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpChannelTreeView</NAME>
struct _GimpChannelTreeView
{
  GimpDrawableTreeView  parent_instance;

  GtkWidget            *component_editor;

  GtkWidget            *toselection_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpChannelTreeViewClass</NAME>
struct _GimpChannelTreeViewClass
{
  GimpDrawableTreeViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_channel_tree_view_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_init</NAME>
<RETURNS>void         </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_exit</NAME>
<RETURNS>void         </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_has_buffer</NAME>
<RETURNS>gboolean     </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_has_svg</NAME>
<RETURNS>gboolean     </RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_get_buffer</NAME>
<RETURNS>GimpBuffer *</RETURNS>
Gimp        *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_get_svg</NAME>
<RETURNS>gchar      *</RETURNS>
Gimp        *gimp,gsize       *svg_length
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_set_buffer</NAME>
<RETURNS>void         </RETURNS>
Gimp        *gimp,GimpBuffer  *buffer
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_set_svg</NAME>
<RETURNS>void         </RETURNS>
Gimp        *gimp,const gchar *svg
</FUNCTION>
<FUNCTION>
<NAME>gimp_clipboard_set_text</NAME>
<RETURNS>void         </RETURNS>
Gimp        *gimp,const gchar *text
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_BAR</NAME>
#define GIMP_TYPE_COLOR_BAR            (gimp_color_bar_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BAR</NAME>
#define GIMP_COLOR_BAR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_BAR, GimpColorBar))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BAR_CLASS</NAME>
#define GIMP_COLOR_BAR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_BAR, GimpColorBarClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_BAR</NAME>
#define GIMP_IS_COLOR_BAR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_BAR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_BAR_CLASS</NAME>
#define GIMP_IS_COLOR_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_BAR))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_BAR_GET_CLASS</NAME>
#define GIMP_COLOR_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_BAR, GimpColorBarClass))
</MACRO>
<STRUCT>
<NAME>GimpColorBarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorBar</NAME>
struct _GimpColorBar
{
  GtkMisc         parent_class;

  GtkOrientation  orientation;
  guchar          buf[3 * 256];
};
</STRUCT>
<STRUCT>
<NAME>GimpColorBarClass</NAME>
struct _GimpColorBarClass
{
  GtkMiscClass   parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_bar_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_bar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkOrientation        orientation
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_bar_set_color</NAME>
<RETURNS>void        </RETURNS>
GimpColorBar         *bar,const GimpRGB        *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_bar_set_channel</NAME>
<RETURNS>void        </RETURNS>
GimpColorBar         *bar,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_bar_set_buffers</NAME>
<RETURNS>void        </RETURNS>
GimpColorBar         *bar,const guchar         *red,const guchar         *green,const guchar         *blue
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_DIALOG</NAME>
#define GIMP_TYPE_COLOR_DIALOG            (gimp_color_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_DIALOG</NAME>
#define GIMP_COLOR_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_DIALOG, GimpColorDialog))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_DIALOG_CLASS</NAME>
#define GIMP_COLOR_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_DIALOG, GimpColorDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_DIALOG</NAME>
#define GIMP_IS_COLOR_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_DIALOG_CLASS</NAME>
#define GIMP_IS_COLOR_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_DIALOG_GET_CLASS</NAME>
#define GIMP_COLOR_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_DIALOG, GimpColorDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpColorDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorDialog</NAME>
struct _GimpColorDialog
{
  GimpViewableDialog   parent_instance;

  gboolean             wants_updates;

  GtkWidget           *selection;
  GtkWidget           *history[COLOR_HISTORY_SIZE];
};
</STRUCT>
<STRUCT>
<NAME>GimpColorDialogClass</NAME>
struct _GimpColorDialogClass
{
  GimpViewableDialogClass  parent_class;

  void (* update) (GimpColorDialog      *dialog,
                   const GimpRGB        *color,
                   GimpColorDialogState  state);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewable      *viewable,const gchar       *title,const gchar       *stock_id,const gchar       *desc,GtkWidget         *parent,GimpDialogFactory *dialog_factory,const gchar       *dialog_identifier,const GimpRGB     *color,gboolean           wants_update,gboolean           show_alpha
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_dialog_set_color</NAME>
<RETURNS>void        </RETURNS>
GimpColorDialog   *dialog,const GimpRGB     *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_dialog_get_color</NAME>
<RETURNS>void        </RETURNS>
GimpColorDialog   *dialog,GimpRGB           *color
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_DISPLAY_EDITOR</NAME>
#define GIMP_TYPE_COLOR_DISPLAY_EDITOR            (gimp_color_display_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_DISPLAY_EDITOR</NAME>
#define GIMP_COLOR_DISPLAY_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_DISPLAY_EDITOR, GimpColorDisplayEditor))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_DISPLAY_EDITOR_CLASS</NAME>
#define GIMP_COLOR_DISPLAY_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_DISPLAY_EDITOR, GimpColorDisplayEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_DISPLAY_EDITOR</NAME>
#define GIMP_IS_COLOR_DISPLAY_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_DISPLAY_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_DISPLAY_EDITOR_CLASS</NAME>
#define GIMP_IS_COLOR_DISPLAY_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_DISPLAY_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_DISPLAY_EDITOR_GET_CLASS</NAME>
#define GIMP_COLOR_DISPLAY_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_DISPLAY_EDITOR, GimpColorDisplayEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpColorDisplayEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorDisplayEditor</NAME>
struct _GimpColorDisplayEditor
{
  GtkVBox                parent_instance;

  GimpColorDisplayStack *stack;

  GtkListStore          *src;
  GtkListStore          *dest;

  GtkTreeSelection      *src_sel;
  GtkTreeSelection      *dest_sel;

  GimpColorDisplay      *selected;

  GtkWidget             *add_button;

  GtkWidget             *remove_button;
  GtkWidget             *up_button;
  GtkWidget             *down_button;

  GtkWidget             *config_frame;
  GtkWidget             *config_box;
  GtkWidget             *config_widget;

  GtkWidget             *reset_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorDisplayEditorClass</NAME>
struct _GimpColorDisplayEditorClass
{
  GtkVBoxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_display_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_display_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpColorDisplayStack *stack
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_EDITOR</NAME>
#define GIMP_TYPE_COLOR_EDITOR            (gimp_color_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_EDITOR</NAME>
#define GIMP_COLOR_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_EDITOR, GimpColorEditor))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_EDITOR_CLASS</NAME>
#define GIMP_COLOR_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_EDITOR, GimpColorEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_EDITOR</NAME>
#define GIMP_IS_COLOR_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_EDITOR_CLASS</NAME>
#define GIMP_IS_COLOR_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_EDITOR_GET_CLASS</NAME>
#define GIMP_COLOR_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_EDITOR, GimpColorEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpColorEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorEditor</NAME>
struct _GimpColorEditor
{
  GimpEditor   parent_instance;

  GimpContext *context;
  gboolean     edit_bg;

  GtkWidget   *hbox;
  GtkWidget   *notebook;
  GtkWidget   *fg_bg;
  GtkWidget   *hex_entry;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorEditorClass</NAME>
struct _GimpColorEditorClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContext *context
</FUNCTION>
<MACRO>
<NAME>GIMP_COLOR_FRAME_ROWS</NAME>
#define GIMP_COLOR_FRAME_ROWS 5
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_COLOR_FRAME</NAME>
#define GIMP_TYPE_COLOR_FRAME            (gimp_color_frame_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_FRAME</NAME>
#define GIMP_COLOR_FRAME(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_FRAME, GimpColorFrame))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_FRAME_CLASS</NAME>
#define GIMP_COLOR_FRAME_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_FRAME, GimpColorFrameClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_FRAME</NAME>
#define GIMP_IS_COLOR_FRAME(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_FRAME))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_FRAME_CLASS</NAME>
#define GIMP_IS_COLOR_FRAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_FRAME))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_FRAME_GET_CLASS</NAME>
#define GIMP_COLOR_FRAME_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_FRAME, GimpColorFrameClass))
</MACRO>
<STRUCT>
<NAME>GimpColorFrameClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorFrame</NAME>
struct _GimpColorFrame
{
  GimpFrame           parent_instance;

  gboolean            sample_valid;
  GimpImageType       sample_type;
  GimpRGB             color;
  gint                color_index;

  GimpColorFrameMode  frame_mode;

  gboolean            has_number;
  gint                number;

  gboolean            has_color_area;

  GtkWidget          *menu;
  GtkWidget          *number_label;
  GtkWidget          *color_area;
  GtkWidget          *name_labels[GIMP_COLOR_FRAME_ROWS];
  GtkWidget          *value_labels[GIMP_COLOR_FRAME_ROWS];
};
</STRUCT>
<STRUCT>
<NAME>GimpColorFrameClass</NAME>
struct _GimpColorFrameClass
{
  GimpFrameClass      parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_frame_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_set_mode</NAME>
<RETURNS>void        </RETURNS>
GimpColorFrame     *frame,GimpColorFrameMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_set_has_number</NAME>
<RETURNS>void        </RETURNS>
GimpColorFrame     *frame,gboolean            has_number
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_set_number</NAME>
<RETURNS>void        </RETURNS>
GimpColorFrame     *frame,gint                number
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_set_has_color_area</NAME>
<RETURNS>void        </RETURNS>
GimpColorFrame     *frame,gboolean            has_color_area
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_set_color</NAME>
<RETURNS>void        </RETURNS>
GimpColorFrame     *frame,GimpImageType       sample_type,const GimpRGB      *color,gint                color_index
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_frame_set_invalid</NAME>
<RETURNS>void        </RETURNS>
GimpColorFrame     *frame
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLORMAP_EDITOR</NAME>
#define GIMP_TYPE_COLORMAP_EDITOR            (gimp_colormap_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLORMAP_EDITOR</NAME>
#define GIMP_COLORMAP_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLORMAP_EDITOR, GimpColormapEditor))
</MACRO>
<MACRO>
<NAME>GIMP_COLORMAP_EDITOR_CLASS</NAME>
#define GIMP_COLORMAP_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLORMAP_EDITOR, GimpColormapEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLORMAP_EDITOR</NAME>
#define GIMP_IS_COLORMAP_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLORMAP_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLORMAP_EDITOR_CLASS</NAME>
#define GIMP_IS_COLORMAP_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLORMAP_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_COLORMAP_EDITOR_GET_CLASS</NAME>
#define GIMP_COLORMAP_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLORMAP_EDITOR, GimpColormapEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpColormapEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColormapEditor</NAME>
struct _GimpColormapEditor
{
  GimpImageEditor  parent_instance;

  gint             col_index;
  gint             dnd_col_index;
  GtkWidget       *preview;
  gint             xn;
  gint             yn;
  gint             cellsize;

  GtkWidget       *edit_button;
  GtkWidget       *add_button;

  GtkAdjustment   *index_adjustment;
  GtkWidget       *index_spinbutton;
  GtkWidget       *color_entry;

  GtkWidget       *color_dialog;
};
</STRUCT>
<STRUCT>
<NAME>GimpColormapEditorClass</NAME>
struct _GimpColormapEditorClass
{
  GimpImageEditorClass  parent_class;

  void (* selected) (GimpColormapEditor *editor,
                     GdkModifierType     state);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_colormap_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_colormap_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpMenuFactory    *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_colormap_editor_selected</NAME>
<RETURNS>void        </RETURNS>
GimpColormapEditor *editor,GdkModifierType     state
</FUNCTION>
<FUNCTION>
<NAME>gimp_colormap_editor_col_index</NAME>
<RETURNS>gint        </RETURNS>
GimpColormapEditor *editor
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COLOR_PANEL</NAME>
#define GIMP_TYPE_COLOR_PANEL            (gimp_color_panel_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PANEL</NAME>
#define GIMP_COLOR_PANEL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COLOR_PANEL, GimpColorPanel))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PANEL_CLASS</NAME>
#define GIMP_COLOR_PANEL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COLOR_PANEL, GimpColorPanelClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_PANEL</NAME>
#define GIMP_IS_COLOR_PANEL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COLOR_PANEL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COLOR_PANEL_CLASS</NAME>
#define GIMP_IS_COLOR_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COLOR_PANEL))
</MACRO>
<MACRO>
<NAME>GIMP_COLOR_PANEL_GET_CLASS</NAME>
#define GIMP_COLOR_PANEL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COLOR_PANEL, GimpColorPanelClass))
</MACRO>
<STRUCT>
<NAME>GimpColorPanelClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorPanel</NAME>
struct _GimpColorPanel
{
  GimpColorButton  parent_instance;

  GimpContext     *context;
  GtkWidget       *color_dialog;
};
</STRUCT>
<STRUCT>
<NAME>GimpColorPanelClass</NAME>
struct _GimpColorPanelClass
{
  GimpColorButtonClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_color_panel_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_panel_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar       *title,const GimpRGB     *color,GimpColorAreaType  type,gint               width,gint               height
</FUNCTION>
<FUNCTION>
<NAME>gimp_color_panel_set_context</NAME>
<RETURNS>void        </RETURNS>
GimpColorPanel    *panel,GimpContext       *context
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_COMPONENT_EDITOR</NAME>
#define GIMP_TYPE_COMPONENT_EDITOR            (gimp_component_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_COMPONENT_EDITOR</NAME>
#define GIMP_COMPONENT_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_COMPONENT_EDITOR, GimpComponentEditor))
</MACRO>
<MACRO>
<NAME>GIMP_COMPONENT_EDITOR_CLASS</NAME>
#define GIMP_COMPONENT_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_COMPONENT_EDITOR, GimpComponentEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COMPONENT_EDITOR</NAME>
#define GIMP_IS_COMPONENT_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_COMPONENT_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_COMPONENT_EDITOR_CLASS</NAME>
#define GIMP_IS_COMPONENT_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_COMPONENT_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_COMPONENT_EDITOR_GET_CLASS</NAME>
#define GIMP_COMPONENT_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_COMPONENT_EDITOR, GimpComponentEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpComponentEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpComponentEditor</NAME>
struct _GimpComponentEditor
{
  GimpImageEditor    parent_instance;

  gint               view_size;

  GtkTreeModel      *model;
  GtkTreeView       *view;
  GtkTreeSelection  *selection;

  GtkTreeViewColumn *eye_column;
  GtkCellRenderer   *eye_cell;
  GtkCellRenderer   *renderer_cell;

  GimpChannelType    clicked_component;
};
</STRUCT>
<STRUCT>
<NAME>GimpComponentEditorClass</NAME>
struct _GimpComponentEditorClass
{
  GimpImageEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_component_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_component_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gint                 view_size,GimpMenuFactory     *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_component_editor_set_view_size</NAME>
<RETURNS>void        </RETURNS>
GimpComponentEditor *editor,gint                 view_size
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_BOX</NAME>
#define GIMP_TYPE_CONTAINER_BOX            (gimp_container_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_BOX</NAME>
#define GIMP_CONTAINER_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_BOX, GimpContainerBox))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_BOX_CLASS</NAME>
#define GIMP_CONTAINER_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_BOX, GimpContainerBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_BOX</NAME>
#define GIMP_IS_CONTAINER_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_BOX_CLASS</NAME>
#define GIMP_IS_CONTAINER_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_BOX_GET_CLASS</NAME>
#define GIMP_CONTAINER_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_BOX, GimpContainerBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerBox</NAME>
struct _GimpContainerBox
{
  GimpEditor  parent_instance;

  GtkWidget  *scrolled_win;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerBoxClass</NAME>
struct _GimpContainerBoxClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_box_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_box_set_size_request</NAME>
<RETURNS>void      </RETURNS>
GimpContainerBox *box,gint              width,gint              height
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_COMBO_BOX</NAME>
#define GIMP_TYPE_CONTAINER_COMBO_BOX            (gimp_container_combo_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_COMBO_BOX</NAME>
#define GIMP_CONTAINER_COMBO_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_COMBO_BOX, GimpContainerComboBox))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_COMBO_BOX_CLASS</NAME>
#define GIMP_CONTAINER_COMBO_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_COMBO_BOX, GimpContainerComboBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_COMBO_BOX</NAME>
#define GIMP_IS_CONTAINER_COMBO_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_COMBO_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_COMBO_BOX_CLASS</NAME>
#define GIMP_IS_CONTAINER_COMBO_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_COMBO_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_COMBO_BOX_GET_CLASS</NAME>
#define GIMP_CONTAINER_COMBO_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_COMBO_BOX, GimpContainerComboBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerComboBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerComboBox</NAME>
struct _GimpContainerComboBox
{
  GtkComboBox      parent_instance;

  GtkCellRenderer *viewable_renderer;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerComboBoxClass</NAME>
struct _GimpContainerComboBoxClass
{
  GtkComboBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_combo_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_combo_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           view_size,gint           view_border_width
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_EDITOR</NAME>
#define GIMP_TYPE_CONTAINER_EDITOR            (gimp_container_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_EDITOR</NAME>
#define GIMP_CONTAINER_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_EDITOR, GimpContainerEditor))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_EDITOR_CLASS</NAME>
#define GIMP_CONTAINER_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_EDITOR, GimpContainerEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_EDITOR</NAME>
#define GIMP_IS_CONTAINER_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_EDITOR_CLASS</NAME>
#define GIMP_IS_CONTAINER_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_EDITOR_GET_CLASS</NAME>
#define GIMP_CONTAINER_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_EDITOR, GimpContainerEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerEditor</NAME>
struct _GimpContainerEditor
{
  GtkVBox            parent_instance;

  GimpContainerView *view;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerEditorClass</NAME>
struct _GimpContainerEditorClass
{
  GtkVBoxClass  parent_class;

  void (* select_item)   (GimpContainerEditor *editor,
                          GimpViewable        *object);
  void (* activate_item) (GimpContainerEditor *editor,
                          GimpViewable        *object);
  void (* context_item)  (GimpContainerEditor *editor,
                          GimpViewable        *object);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_editor_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_editor_construct</NAME>
<RETURNS>gboolean  </RETURNS>
GimpContainerEditor *editor,GimpViewType         view_type,GimpContainer       *container,GimpContext         *context,gint                 view_size,gint                 view_border_width,GimpMenuFactory     *menu_factory,const gchar         *menu_identifier,const gchar         *ui_path
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_ENTRY</NAME>
#define GIMP_TYPE_CONTAINER_ENTRY            (gimp_container_entry_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_ENTRY</NAME>
#define GIMP_CONTAINER_ENTRY(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_ENTRY, GimpContainerEntry))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_ENTRY_CLASS</NAME>
#define GIMP_CONTAINER_ENTRY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_ENTRY, GimpContainerEntryClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_ENTRY</NAME>
#define GIMP_IS_CONTAINER_ENTRY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_ENTRY))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_ENTRY_CLASS</NAME>
#define GIMP_IS_CONTAINER_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_ENTRY))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_ENTRY_GET_CLASS</NAME>
#define GIMP_CONTAINER_ENTRY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_ENTRY, GimpContainerEntryClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerEntry</NAME>
struct _GimpContainerEntry
{
  GtkEntry        parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerEntryClass</NAME>
struct _GimpContainerEntryClass
{
  GtkEntryClass   parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_entry_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_entry_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           view_size,gint           view_border_width
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_GRID_VIEW</NAME>
#define GIMP_TYPE_CONTAINER_GRID_VIEW            (gimp_container_grid_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_GRID_VIEW</NAME>
#define GIMP_CONTAINER_GRID_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_GRID_VIEW, GimpContainerGridView))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_GRID_VIEW_CLASS</NAME>
#define GIMP_CONTAINER_GRID_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_GRID_VIEW, GimpContainerGridViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_GRID_VIEW</NAME>
#define GIMP_IS_CONTAINER_GRID_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_GRID_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_GRID_VIEW_CLASS</NAME>
#define GIMP_IS_CONTAINER_GRID_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_GRID_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_GRID_VIEW_GET_CLASS</NAME>
#define GIMP_CONTAINER_GRID_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_GRID_VIEW, GimpContainerGridViewClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerGridViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerGridView</NAME>
struct _GimpContainerGridView
{
  GimpContainerBox  parent_instance;

  GtkWidget        *wrap_box;

  gint              rows;
  gint              columns;
  gint              visible_rows;

  GimpView         *selected_item;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerGridViewClass</NAME>
struct _GimpContainerGridViewClass
{
  GimpContainerBoxClass  parent_class;

  gboolean (* move_cursor) (GimpContainerGridView *grid_view,
                            GtkMovementStep        step,
                            gint                   count);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_grid_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_grid_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           view_size,gint           view_border_width
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_POPUP</NAME>
#define GIMP_TYPE_CONTAINER_POPUP            (gimp_container_popup_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_POPUP</NAME>
#define GIMP_CONTAINER_POPUP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_POPUP, GimpContainerPopup))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_POPUP_CLASS</NAME>
#define GIMP_CONTAINER_POPUP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_POPUP, GimpContainerPopupClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_POPUP</NAME>
#define GIMP_IS_CONTAINER_POPUP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_POPUP))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_POPUP_CLASS</NAME>
#define GIMP_IS_CONTAINER_POPUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_POPUP))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_POPUP_GET_CLASS</NAME>
#define GIMP_CONTAINER_POPUP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_POPUP, GimpContainerPopupClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerPopupClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerPopup</NAME>
struct _GimpContainerPopup
{
  GtkWindow            parent_instance;

  GimpContainer       *container;
  GimpContext         *orig_context;
  GimpContext         *context;

  GimpViewType         view_type;
  gint                 default_view_size;
  gint                 view_size;
  gint                 view_border_width;

  GtkWidget           *frame;
  GimpContainerEditor *editor;

  GimpDialogFactory   *dialog_factory;
  gchar               *dialog_identifier;
  gchar               *dialog_stock_id;
  gchar               *dialog_tooltip;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerPopupClass</NAME>
struct _GimpContainerPopupClass
{
  GtkWindowClass  parent_instance;

  void (* cancel)  (GimpContainerPopup *popup);
  void (* confirm) (GimpContainerPopup *popup);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_popup_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_popup_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer      *container,GimpContext        *context,GimpViewType        view_type,gint                default_view_size,gint                view_size,gint                view_border_width,GimpDialogFactory  *dialog_factory,const gchar        *dialog_identifier,const gchar        *dialog_stock_id,const gchar        *dialog_tooltip
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_popup_show</NAME>
<RETURNS>void        </RETURNS>
GimpContainerPopup *popup,GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_popup_get_view_type</NAME>
<RETURNS>GimpViewType </RETURNS>
GimpContainerPopup *popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_popup_set_view_type</NAME>
<RETURNS>void         </RETURNS>
GimpContainerPopup *popup,GimpViewType        view_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_popup_get_view_size</NAME>
<RETURNS>gint         </RETURNS>
GimpContainerPopup *popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_popup_set_view_size</NAME>
<RETURNS>void         </RETURNS>
GimpContainerPopup *popup,gint                view_size
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_drag_leave</NAME>
<RETURNS>void     </RETURNS>
GtkWidget             *widget,GdkDragContext        *context,guint                  time,GimpContainerTreeView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_drag_motion</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget             *widget,GdkDragContext        *context,gint                   x,gint                   y,guint                  time,GimpContainerTreeView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_drag_drop</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget             *widget,GdkDragContext        *context,gint                   x,gint                   y,guint                  time,GimpContainerTreeView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_drag_data_received</NAME>
<RETURNS>void  </RETURNS>
GtkWidget             *widget,GdkDragContext        *context,gint                   x,gint                   y,GtkSelectionData      *selection_data,guint                  info,guint                  time,GimpContainerTreeView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_real_drop_possible</NAME>
<RETURNS>gboolean</RETURNS>
GimpContainerTreeView   *tree_view,GimpDndType              src_type,GimpViewable            *src_viewable,GimpViewable            *dest_viewable,GtkTreeViewDropPosition  drop_pos,GtkTreeViewDropPosition *return_drop_pos,GdkDragAction           *return_drag_action
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_real_drop_viewable</NAME>
<RETURNS>void</RETURNS>
GimpContainerTreeView   *tree_view,GimpViewable            *src_viewable,GimpViewable            *dest_viewable,GtkTreeViewDropPosition  drop_pos
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_TREE_VIEW</NAME>
#define GIMP_TYPE_CONTAINER_TREE_VIEW            (gimp_container_tree_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_TREE_VIEW</NAME>
#define GIMP_CONTAINER_TREE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_TREE_VIEW, GimpContainerTreeView))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_TREE_VIEW_CLASS</NAME>
#define GIMP_CONTAINER_TREE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTAINER_TREE_VIEW, GimpContainerTreeViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_TREE_VIEW</NAME>
#define GIMP_IS_CONTAINER_TREE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_TREE_VIEW_CLASS</NAME>
#define GIMP_IS_CONTAINER_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTAINER_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_TREE_VIEW_GET_CLASS</NAME>
#define GIMP_CONTAINER_TREE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTAINER_TREE_VIEW, GimpContainerTreeViewClass))
</MACRO>
<STRUCT>
<NAME>GimpContainerTreeViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerTreeView</NAME>
struct _GimpContainerTreeView
{
  GimpContainerBox   parent_instance;

  GtkTreeModel      *model;
  gint               n_model_columns;
  GType              model_columns[16];

  gint               model_column_renderer;
  gint               model_column_name;
  gint               model_column_name_attributes;

  GtkTreeView       *view;
  GtkTreeSelection  *selection;

  GtkTreeViewColumn *main_column;
  GtkCellRenderer   *renderer_cell;
  GtkCellRenderer   *name_cell;

  GList             *toggle_cells;
  GList             *renderer_cells;
  GList             *editable_cells;

  GQuark             invalidate_preview_handler_id;

  gboolean           dnd_drop_to_empty;
  Gimp              *dnd_gimp; /* eek */
  GimpViewable      *dnd_viewable;

  guint              scroll_timeout_id;
  guint              scroll_timeout_interval;
  GdkScrollDirection scroll_dir;
};
</STRUCT>
<STRUCT>
<NAME>GimpContainerTreeViewClass</NAME>
struct _GimpContainerTreeViewClass
{
  GimpContainerBoxClass  parent_class;

  gboolean (* drop_possible)  (GimpContainerTreeView   *tree_view,
                               GimpDndType              src_type,
                               GimpViewable            *src_viewable,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos,
                               GtkTreeViewDropPosition *return_drop_pos,
                               GdkDragAction           *return_drag_action);
  void     (* drop_viewable)  (GimpContainerTreeView   *tree_view,
                               GimpViewable            *src_viewable,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos);
  void     (* drop_color)     (GimpContainerTreeView   *tree_view,
                               const GimpRGB           *src_color,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos);
  void     (* drop_uri_list)  (GimpContainerTreeView   *tree_view,
                               GList                   *uri_list,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos);
  void     (* drop_svg)       (GimpContainerTreeView   *tree_view,
                               const gchar             *svg_data,
                               gsize                    svg_data_length,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos);
  void     (* drop_component) (GimpContainerTreeView   *tree_view,
                               GimpImage               *image,
                               GimpChannelType          component,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos);
  void     (* drop_pixbuf)    (GimpContainerTreeView   *tree_view,
                               GdkPixbuf               *pixbuf,
                               GimpViewable            *dest_viewable,
                               GtkTreeViewDropPosition  drop_pos);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_tree_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_tree_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           view_size,gint           view_border_width
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_by_dockable</NAME>
<RETURNS>GimpContainerView *</RETURNS>
GimpDockable *dockable
</FUNCTION>
<ENUM>
<NAME>GimpContainerViewProp</NAME>
typedef enum
{
  GIMP_CONTAINER_VIEW_PROP_0,
  GIMP_CONTAINER_VIEW_PROP_CONTAINER,
  GIMP_CONTAINER_VIEW_PROP_CONTEXT,
  GIMP_CONTAINER_VIEW_PROP_REORDERABLE,
  GIMP_CONTAINER_VIEW_PROP_VIEW_SIZE,
  GIMP_CONTAINER_VIEW_PROP_VIEW_BORDER_WIDTH,
  GIMP_CONTAINER_VIEW_PROP_LAST = GIMP_CONTAINER_VIEW_PROP_VIEW_BORDER_WIDTH
} GimpContainerViewProp;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CONTAINER_VIEW</NAME>
#define GIMP_TYPE_CONTAINER_VIEW               (gimp_container_view_interface_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_VIEW</NAME>
#define GIMP_CONTAINER_VIEW(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTAINER_VIEW, GimpContainerView))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTAINER_VIEW</NAME>
#define GIMP_IS_CONTAINER_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTAINER_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_CONTAINER_VIEW_GET_INTERFACE</NAME>
#define GIMP_CONTAINER_VIEW_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GIMP_TYPE_CONTAINER_VIEW, GimpContainerViewInterface))
</MACRO>
<STRUCT>
<NAME>GimpContainerViewInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerViewInterface</NAME>
struct _GimpContainerViewInterface
{
  GTypeInterface base_iface;

  /*  signals  */
  gboolean (* select_item)   (GimpContainerView *view,
                              GimpViewable      *object,
                              gpointer           insert_data);
  void     (* activate_item) (GimpContainerView *view,
                              GimpViewable      *object,
                              gpointer           insert_data);
  void     (* context_item)  (GimpContainerView *view,
                              GimpViewable      *object,
                              gpointer           insert_data);

  /*  virtual functions  */
  void     (* set_container) (GimpContainerView *view,
                              GimpContainer     *container);
  gpointer (* insert_item)   (GimpContainerView *view,
                              GimpViewable      *object,
                              gint               index);
  void     (* remove_item)   (GimpContainerView *view,
                              GimpViewable      *object,
                              gpointer           insert_data);
  void     (* reorder_item)  (GimpContainerView *view,
                              GimpViewable      *object,
                              gint               new_index,
                              gpointer           insert_data);
  void     (* rename_item)   (GimpContainerView *view,
                              GimpViewable      *object,
                              gpointer           insert_data);
  void     (* clear_items)   (GimpContainerView *view);
  void     (* set_view_size) (GimpContainerView *view);

  /*  the destroy notifier for private->hash_table's values  */
  GDestroyNotify  insert_data_free;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_container_view_interface_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_container</NAME>
<RETURNS>GimpContainer *</RETURNS>
GimpContainerView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_set_container</NAME>
<RETURNS>void            </RETURNS>
GimpContainerView *view,GimpContainer     *container
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_context</NAME>
<RETURNS>GimpContext   *</RETURNS>
GimpContainerView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_set_context</NAME>
<RETURNS>void            </RETURNS>
GimpContainerView *view,GimpContext       *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_view_size</NAME>
<RETURNS>gint         </RETURNS>
GimpContainerView *view,gint              *view_border_width
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_set_view_size</NAME>
<RETURNS>void         </RETURNS>
GimpContainerView *view,gint               view_size,gint               view_border_width
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_reorderable</NAME>
<RETURNS>gboolean  </RETURNS>
GimpContainerView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_set_reorderable</NAME>
<RETURNS>void      </RETURNS>
GimpContainerView *view,gboolean           reorderable
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_dnd_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainerView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_set_dnd_widget</NAME>
<RETURNS>void        </RETURNS>
GimpContainerView *view,GtkWidget         *dnd_widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_enable_dnd</NAME>
<RETURNS>void      </RETURNS>
GimpContainerView *editor,GtkButton         *button,GType              children_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_select_item</NAME>
<RETURNS>gboolean  </RETURNS>
GimpContainerView *view,GimpViewable      *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_activate_item</NAME>
<RETURNS>void      </RETURNS>
GimpContainerView *view,GimpViewable      *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_context_item</NAME>
<RETURNS>void      </RETURNS>
GimpContainerView *view,GimpViewable      *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_lookup</NAME>
<RETURNS>gpointer  </RETURNS>
GimpContainerView *view,GimpViewable      *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_item_selected</NAME>
<RETURNS>gboolean  </RETURNS>
GimpContainerView *view,GimpViewable      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_item_activated</NAME>
<RETURNS>void      </RETURNS>
GimpContainerView *view,GimpViewable      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_item_context</NAME>
<RETURNS>void      </RETURNS>
GimpContainerView *view,GimpViewable      *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_install_properties</NAME>
<RETURNS>void      </RETURNS>
GObjectClass *klass
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_set_property</NAME>
<RETURNS>void      </RETURNS>
GObject      *object,guint         property_id,const GValue *value,GParamSpec   *pspec
</FUNCTION>
<FUNCTION>
<NAME>gimp_container_view_get_property</NAME>
<RETURNS>void      </RETURNS>
GObject      *object,guint         property_id,GValue       *value,GParamSpec   *pspec
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTROLLER_EDITOR</NAME>
#define GIMP_TYPE_CONTROLLER_EDITOR            (gimp_controller_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_EDITOR</NAME>
#define GIMP_CONTROLLER_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTROLLER_EDITOR, GimpControllerEditor))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_EDITOR_CLASS</NAME>
#define GIMP_CONTROLLER_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTROLLER_EDITOR, GimpControllerEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_EDITOR</NAME>
#define GIMP_IS_CONTROLLER_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTROLLER_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_EDITOR_CLASS</NAME>
#define GIMP_IS_CONTROLLER_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTROLLER_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_EDITOR_GET_CLASS</NAME>
#define GIMP_CONTROLLER_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTROLLER_EDITOR, GimpControllerEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpControllerEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerEditor</NAME>
struct _GimpControllerEditor
{
  GtkVBox             parent_instance;

  GimpControllerInfo *info;

  GtkTreeSelection   *sel;

  GtkWidget          *grab_button;
  GtkWidget          *edit_button;
  GtkWidget          *delete_button;

  GtkWidget          *edit_dialog;
  GtkTreeSelection   *edit_sel;
};
</STRUCT>
<STRUCT>
<NAME>GimpControllerEditorClass</NAME>
struct _GimpControllerEditorClass
{
  GtkVBoxClass   parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_controller_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpControllerInfo *info
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpControllerEventSnooper</NAME>
<RETURNS>gboolean </RETURNS>
GimpControllerInfo        *info,
                                                 GimpController            *controller,
                                                 const GimpControllerEvent *event,
                                                 gpointer                   user_data
</USER_FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTROLLER_INFO</NAME>
#define GIMP_TYPE_CONTROLLER_INFO            (gimp_controller_info_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_INFO</NAME>
#define GIMP_CONTROLLER_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTROLLER_INFO, GimpControllerInfo))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_INFO_CLASS</NAME>
#define GIMP_CONTROLLER_INFO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTROLLER_INFO, GimpControllerInfoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_INFO</NAME>
#define GIMP_IS_CONTROLLER_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTROLLER_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_INFO_CLASS</NAME>
#define GIMP_IS_CONTROLLER_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTROLLER_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_INFO_GET_CLASS</NAME>
#define GIMP_CONTROLLER_INFO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTROLLER_INFO, GimpControllerInfoClass))
</MACRO>
<STRUCT>
<NAME>GimpControllerInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerInfo</NAME>
struct _GimpControllerInfo
{
  GimpViewable                parent_instance;

  gboolean                    enabled;
  gboolean                    debug_events;

  GimpController             *controller;
  GHashTable                 *mapping;

  GimpControllerEventSnooper  snooper;
  gpointer                    snooper_data;
};
</STRUCT>
<STRUCT>
<NAME>GimpControllerInfoClass</NAME>
struct _GimpControllerInfoClass
{
  GimpViewableClass  parent_class;

  gboolean (* event_mapped) (GimpControllerInfo        *info,
                             GimpController            *controller,
                             const GimpControllerEvent *event,
                             const gchar               *action_name);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_controller_info_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_info_new</NAME>
<RETURNS>GimpControllerInfo *</RETURNS>
GType                       type
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_info_set_enabled</NAME>
<RETURNS>void     </RETURNS>
GimpControllerInfo         *info,gboolean                    enabled
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_info_get_enabled</NAME>
<RETURNS>gboolean </RETURNS>
GimpControllerInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_info_set_event_snooper</NAME>
<RETURNS>void     </RETURNS>
GimpControllerInfo         *info,GimpControllerEventSnooper  snooper,gpointer                    snooper_data
</FUNCTION>
<MACRO>
<NAME>GIMP_ENABLE_CONTROLLER_UNDER_CONSTRUCTION</NAME>
#define GIMP_ENABLE_CONTROLLER_UNDER_CONSTRUCTION
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_CONTROLLER_KEYBOARD</NAME>
#define GIMP_TYPE_CONTROLLER_KEYBOARD            (gimp_controller_keyboard_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_KEYBOARD</NAME>
#define GIMP_CONTROLLER_KEYBOARD(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTROLLER_KEYBOARD, GimpControllerKeyboard))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_KEYBOARD_CLASS</NAME>
#define GIMP_CONTROLLER_KEYBOARD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTROLLER_KEYBOARD, GimpControllerKeyboardClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_KEYBOARD</NAME>
#define GIMP_IS_CONTROLLER_KEYBOARD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTROLLER_KEYBOARD))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_KEYBOARD_CLASS</NAME>
#define GIMP_IS_CONTROLLER_KEYBOARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTROLLER_KEYBOARD))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_KEYBOARD_GET_CLASS</NAME>
#define GIMP_CONTROLLER_KEYBOARD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTROLLER_KEYBOARD, GimpControllerKeyboardClass))
</MACRO>
<STRUCT>
<NAME>GimpControllerKeyboardClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerKeyboard</NAME>
struct _GimpControllerKeyboard
{
  GimpController parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpControllerKeyboardClass</NAME>
struct _GimpControllerKeyboardClass
{
  GimpControllerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_controller_keyboard_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_keyboard_key_press</NAME>
<RETURNS>gboolean   </RETURNS>
GimpControllerKeyboard *keyboard,const GdkEventKey      *kevent
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CONTROLLER_LIST</NAME>
#define GIMP_TYPE_CONTROLLER_LIST            (gimp_controller_list_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_LIST</NAME>
#define GIMP_CONTROLLER_LIST(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTROLLER_LIST, GimpControllerList))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_LIST_CLASS</NAME>
#define GIMP_CONTROLLER_LIST_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTROLLER_LIST, GimpControllerListClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_LIST</NAME>
#define GIMP_IS_CONTROLLER_LIST(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTROLLER_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_LIST_CLASS</NAME>
#define GIMP_IS_CONTROLLER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTROLLER_LIST))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_LIST_GET_CLASS</NAME>
#define GIMP_CONTROLLER_LIST_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTROLLER_LIST, GimpControllerListClass))
</MACRO>
<STRUCT>
<NAME>GimpControllerListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerList</NAME>
struct _GimpControllerList
{
  GtkVBox             parent_instance;

  Gimp               *gimp;

  GtkWidget          *hbox;

  GtkListStore       *src;
  GtkTreeSelection   *src_sel;
  GType               src_gtype;

  GtkWidget          *dest;
  GimpControllerInfo *dest_info;

  GtkWidget          *add_button;
  GtkWidget          *remove_button;
  GtkWidget          *edit_button;
  GtkWidget          *up_button;
  GtkWidget          *down_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpControllerListClass</NAME>
struct _GimpControllerListClass
{
  GtkVBoxClass   parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_controller_list_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_list_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_init</NAME>
<RETURNS>void             </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_exit</NAME>
<RETURNS>void             </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_restore</NAME>
<RETURNS>void             </RETURNS>
Gimp          *gimp,GimpUIManager *ui_manager
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_save</NAME>
<RETURNS>void             </RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_get_list</NAME>
<RETURNS>GimpContainer  *</RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_get_ui_manager</NAME>
<RETURNS>GimpUIManager  *</RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_get_wheel</NAME>
<RETURNS>GimpController *</RETURNS>
Gimp          *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_controllers_get_keyboard</NAME>
<RETURNS>GimpController *</RETURNS>
Gimp          *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_ENABLE_CONTROLLER_UNDER_CONSTRUCTION</NAME>
#define GIMP_ENABLE_CONTROLLER_UNDER_CONSTRUCTION
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_CONTROLLER_WHEEL</NAME>
#define GIMP_TYPE_CONTROLLER_WHEEL            (gimp_controller_wheel_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_WHEEL</NAME>
#define GIMP_CONTROLLER_WHEEL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CONTROLLER_WHEEL, GimpControllerWheel))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_WHEEL_CLASS</NAME>
#define GIMP_CONTROLLER_WHEEL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CONTROLLER_WHEEL, GimpControllerWheelClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_WHEEL</NAME>
#define GIMP_IS_CONTROLLER_WHEEL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTROLLER_WHEEL))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CONTROLLER_WHEEL_CLASS</NAME>
#define GIMP_IS_CONTROLLER_WHEEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CONTROLLER_WHEEL))
</MACRO>
<MACRO>
<NAME>GIMP_CONTROLLER_WHEEL_GET_CLASS</NAME>
#define GIMP_CONTROLLER_WHEEL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CONTROLLER_WHEEL, GimpControllerWheelClass))
</MACRO>
<STRUCT>
<NAME>GimpControllerWheelClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerWheel</NAME>
struct _GimpControllerWheel
{
  GimpController parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpControllerWheelClass</NAME>
struct _GimpControllerWheelClass
{
  GimpControllerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_controller_wheel_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_controller_wheel_scroll</NAME>
<RETURNS>gboolean   </RETURNS>
GimpControllerWheel  *wheel,const GdkEventScroll *sevent
</FUNCTION>
<FUNCTION>
<NAME>gimp_cursor_new</NAME>
<RETURNS>GdkCursor *</RETURNS>
GdkDisplay         *display,GimpCursorFormat    cursor_format,GimpCursorType      cursor_type,GimpToolCursorType  tool_cursor,GimpCursorModifier  modifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_cursor_set</NAME>
<RETURNS>void        </RETURNS>
GtkWidget          *widget,GimpCursorFormat    cursor_format,GimpCursorType      cursor_type,GimpToolCursorType  tool_cursor,GimpCursorModifier  modifier
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CURSOR_VIEW</NAME>
#define GIMP_TYPE_CURSOR_VIEW            (gimp_cursor_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CURSOR_VIEW</NAME>
#define GIMP_CURSOR_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CURSOR_VIEW, GimpCursorView))
</MACRO>
<MACRO>
<NAME>GIMP_CURSOR_VIEW_CLASS</NAME>
#define GIMP_CURSOR_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CURSOR_VIEW, GimpCursorViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CURSOR_VIEW</NAME>
#define GIMP_IS_CURSOR_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CURSOR_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CURSOR_VIEW_CLASS</NAME>
#define GIMP_IS_CURSOR_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CURSOR_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_CURSOR_VIEW_GET_CLASS</NAME>
#define GIMP_CURSOR_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CURSOR_VIEW, GimpCursorViewClass))
</MACRO>
<STRUCT>
<NAME>GimpCursorViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCursorView</NAME>
struct _GimpCursorView
{
  GimpEditor   parent_instance;

  GtkWidget   *coord_hbox;
  GtkWidget   *color_hbox;

  GtkWidget   *pixel_x_label;
  GtkWidget   *pixel_y_label;
  GtkWidget   *unit_x_label;
  GtkWidget   *unit_y_label;
  GtkWidget   *color_frame_1;
  GtkWidget   *color_frame_2;

  gboolean     sample_merged;
};
</STRUCT>
<STRUCT>
<NAME>GimpCursorViewClass</NAME>
struct _GimpCursorViewClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_cursor_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_cursor_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpMenuFactory *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_cursor_view_set_sample_merged</NAME>
<RETURNS>void        </RETURNS>
GimpCursorView  *view,gboolean         sample_merged
</FUNCTION>
<FUNCTION>
<NAME>gimp_cursor_view_get_sample_merged</NAME>
<RETURNS>gboolean    </RETURNS>
GimpCursorView  *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_cursor_view_update_cursor</NAME>
<RETURNS>void        </RETURNS>
GimpCursorView  *view,GimpImage       *image,GimpUnit         unit,gdouble          x,gdouble          y
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DASH_EDITOR</NAME>
#define GIMP_TYPE_DASH_EDITOR            (gimp_dash_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DASH_EDITOR</NAME>
#define GIMP_DASH_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DASH_EDITOR, GimpDashEditor))
</MACRO>
<MACRO>
<NAME>GIMP_DASH_EDITOR_CLASS</NAME>
#define GIMP_DASH_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DASH_EDITOR, GimpDashEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DASH_EDITOR</NAME>
#define GIMP_IS_DASH_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DASH_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DASH_EDITOR_CLASS</NAME>
#define GIMP_IS_DASH_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DASH_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_DASH_EDITOR_GET_CLASS</NAME>
#define GIMP_DASH_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DASH_EDITOR, GimpDashEditor))
</MACRO>
<STRUCT>
<NAME>GimpDashEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDashEditor</NAME>
struct _GimpDashEditor
{
  GtkDrawingArea     parent_instance;

  GimpStrokeOptions *stroke_options;
  gdouble            dash_length;

  /* GUI stuff */
  gint               n_segments;
  gboolean          *segments;

  /* coordinates of the first block main dash pattern */
  gint               x0;
  gint               y0;
  gint               block_width;
  gint               block_height;

  gboolean           edit_mode;
  gint               edit_button_x0;
};
</STRUCT>
<STRUCT>
<NAME>GimpDashEditorClass</NAME>
struct _GimpDashEditorClass
{
  GtkDrawingAreaClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dash_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpStrokeOptions *stroke_options
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_editor_shift_left</NAME>
<RETURNS>void        </RETURNS>
GimpDashEditor    *editor
</FUNCTION>
<FUNCTION>
<NAME>gimp_dash_editor_shift_right</NAME>
<RETURNS>void        </RETURNS>
GimpDashEditor    *editor
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DATA_EDITOR</NAME>
#define GIMP_TYPE_DATA_EDITOR            (gimp_data_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DATA_EDITOR</NAME>
#define GIMP_DATA_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DATA_EDITOR, GimpDataEditor))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_EDITOR_CLASS</NAME>
#define GIMP_DATA_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DATA_EDITOR, GimpDataEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_EDITOR</NAME>
#define GIMP_IS_DATA_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DATA_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_EDITOR_CLASS</NAME>
#define GIMP_IS_DATA_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DATA_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_EDITOR_GET_CLASS</NAME>
#define GIMP_DATA_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DATA_EDITOR, GimpDataEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpDataEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataEditor</NAME>
struct _GimpDataEditor
{
  GimpEditor       parent_instance;

  GimpDataFactory *data_factory;
  gboolean         edit_active;

  GimpData        *data;
  gboolean         data_editable;

  GtkWidget       *name_entry;

  GtkWidget       *save_button;
  GtkWidget       *revert_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpDataEditorClass</NAME>
struct _GimpDataEditorClass
{
  GimpEditorClass  parent_class;

  /*  virtual functions  */
  void (* set_data) (GimpDataEditor *editor,
                     GimpData       *data);

  const gchar *title;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_data_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_editor_set_data</NAME>
<RETURNS>void        </RETURNS>
GimpDataEditor *editor,GimpData       *data
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_editor_get_data</NAME>
<RETURNS>GimpData  *</RETURNS>
GimpDataEditor *editor
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_editor_set_edit_active</NAME>
<RETURNS>void        </RETURNS>
GimpDataEditor *editor,gboolean        edit_active
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_editor_get_edit_active</NAME>
<RETURNS>gboolean    </RETURNS>
GimpDataEditor *editor
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DATA_FACTORY_VIEW</NAME>
#define GIMP_TYPE_DATA_FACTORY_VIEW            (gimp_data_factory_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DATA_FACTORY_VIEW</NAME>
#define GIMP_DATA_FACTORY_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DATA_FACTORY_VIEW, GimpDataFactoryView))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_FACTORY_VIEW_CLASS</NAME>
#define GIMP_DATA_FACTORY_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DATA_FACTORY_VIEW, GimpDataFactoryViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_FACTORY_VIEW</NAME>
#define GIMP_IS_DATA_FACTORY_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DATA_FACTORY_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DATA_FACTORY_VIEW_CLASS</NAME>
#define GIMP_IS_DATA_FACTORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DATA_FACTORY_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_DATA_FACTORY_VIEW_GET_CLASS</NAME>
#define GIMP_DATA_FACTORY_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DATA_FACTORY_VIEW, GimpDataFactoryViewClass))
</MACRO>
<STRUCT>
<NAME>GimpDataFactoryViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataFactoryView</NAME>
struct _GimpDataFactoryView
{
  GimpContainerEditor  parent_instance;

  GimpDataFactory     *factory;

  GtkWidget           *edit_button;
  GtkWidget           *new_button;
  GtkWidget           *duplicate_button;
  GtkWidget           *delete_button;
  GtkWidget           *refresh_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpDataFactoryViewClass</NAME>
struct _GimpDataFactoryViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_data_factory_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType      view_type,GimpDataFactory  *factory,GimpContext      *context,gint              view_size,gint              view_border_width,GimpMenuFactory  *menu_factory,const gchar      *menu_identifier,const gchar      *ui_identifier,const gchar      *action_group
</FUNCTION>
<FUNCTION>
<NAME>gimp_data_factory_view_construct</NAME>
<RETURNS>gboolean    </RETURNS>
GimpDataFactoryView *factory_view,GimpViewType         view_type,GimpDataFactory     *factory,GimpContext         *context,gint                 view_size,gint                 view_border_width,GimpMenuFactory     *menu_factory,const gchar         *menu_identifier,const gchar         *ui_identifier,const gchar         *action_group
</FUNCTION>
<MACRO>
<NAME>GIMP_DEVICE_INFO_CONTEXT_MASK</NAME>
#define GIMP_DEVICE_INFO_CONTEXT_MASK (GIMP_CONTEXT_TOOL_MASK       | \
                                       GIMP_CONTEXT_PAINT_INFO_MASK | \
                                       GIMP_CONTEXT_FOREGROUND_MASK | \
                                       GIMP_CONTEXT_BACKGROUND_MASK | \
                                       GIMP_CONTEXT_BRUSH_MASK      | \
                                       GIMP_CONTEXT_PATTERN_MASK    | \
                                       GIMP_CONTEXT_GRADIENT_MASK)
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_DEVICE_INFO</NAME>
#define GIMP_TYPE_DEVICE_INFO            (gimp_device_info_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DEVICE_INFO</NAME>
#define GIMP_DEVICE_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DEVICE_INFO, GimpDeviceInfo))
</MACRO>
<MACRO>
<NAME>GIMP_DEVICE_INFO_CLASS</NAME>
#define GIMP_DEVICE_INFO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DEVICE_INFO, GimpDeviceInfoClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DEVICE_INFO</NAME>
#define GIMP_IS_DEVICE_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DEVICE_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DEVICE_INFO_CLASS</NAME>
#define GIMP_IS_DEVICE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DEVICE_INFO))
</MACRO>
<MACRO>
<NAME>GIMP_DEVICE_INFO_GET_CLASS</NAME>
#define GIMP_DEVICE_INFO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DEVICE_INFO, GimpDeviceInfoClass))
</MACRO>
<STRUCT>
<NAME>GimpDeviceInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDeviceInfo</NAME>
struct _GimpDeviceInfo
{
  GimpContext    parent_instance;

  GdkDevice     *device;
  GdkDisplay    *display;

  /*  either "device" or the options below are set  */

  GdkInputMode   mode;
  gint           num_axes;
  GdkAxisUse    *axes;
  gint           num_keys;
  GdkDeviceKey  *keys;
};
</STRUCT>
<STRUCT>
<NAME>GimpDeviceInfoClass</NAME>
struct _GimpDeviceInfoClass
{
  GimpContextClass  parent_class;

  void (* changed) (GimpDeviceInfo *device_info);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_device_info_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_info_new</NAME>
<RETURNS>GimpDeviceInfo *</RETURNS>
Gimp           *gimp,const gchar    *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_info_set_from_device</NAME>
<RETURNS>GimpDeviceInfo *</RETURNS>
GimpDeviceInfo *device_info,GdkDevice      *device,GdkDisplay     *display
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_info_changed</NAME>
<RETURNS>void             </RETURNS>
GimpDeviceInfo *device_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_info_get_by_device</NAME>
<RETURNS>GimpDeviceInfo *</RETURNS>
GdkDevice      *device
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_info_changed_by_device</NAME>
<RETURNS>void             </RETURNS>
GdkDevice      *device
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDeviceChangeNotify</NAME>
<RETURNS>void </RETURNS>
Gimp *gimp
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_devices_init</NAME>
<RETURNS>void            </RETURNS>
Gimp                   *gimp,GimpDeviceChangeNotify  callback
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_exit</NAME>
<RETURNS>void            </RETURNS>
Gimp                   *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_restore</NAME>
<RETURNS>void            </RETURNS>
Gimp                   *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_save</NAME>
<RETURNS>void            </RETURNS>
Gimp                   *gimp,gboolean                always_save
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_clear</NAME>
<RETURNS>gboolean        </RETURNS>
Gimp                   *gimp,GError                **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_get_list</NAME>
<RETURNS>GimpContainer *</RETURNS>
Gimp                   *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_get_current</NAME>
<RETURNS>GdkDevice     *</RETURNS>
Gimp                   *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_check_change</NAME>
<RETURNS>gboolean        </RETURNS>
Gimp                   *gimp,GdkEvent               *event
</FUNCTION>
<FUNCTION>
<NAME>gimp_devices_select_device</NAME>
<RETURNS>void            </RETURNS>
Gimp                   *gimp,GdkDevice              *device
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DEVICE_STATUS</NAME>
#define GIMP_TYPE_DEVICE_STATUS            (gimp_device_status_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DEVICE_STATUS</NAME>
#define GIMP_DEVICE_STATUS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DEVICE_STATUS, GimpDeviceStatus))
</MACRO>
<MACRO>
<NAME>GIMP_DEVICE_STATUS_CLASS</NAME>
#define GIMP_DEVICE_STATUS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DEVICE_STATUS, GimpDeviceStatusClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DEVICE_STATUS</NAME>
#define GIMP_IS_DEVICE_STATUS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DEVICE_STATUS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DEVICE_STATUS_CLASS</NAME>
#define GIMP_IS_DEVICE_STATUS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DEVICE_STATUS))
</MACRO>
<MACRO>
<NAME>GIMP_DEVICE_STATUS_GET_CLASS</NAME>
#define GIMP_DEVICE_STATUS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DEVICE_STATUS, GimpDeviceStatusClass))
</MACRO>
<STRUCT>
<NAME>GimpDeviceStatusEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDeviceStatusClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDeviceStatus</NAME>
struct _GimpDeviceStatus
{
  GimpEditor  parent_instance;

  Gimp       *gimp;
  GdkDevice  *current_device;

  GList      *devices;

  GtkWidget  *vbox;

  GtkWidget  *save_button;
  GtkWidget  *edit_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpDeviceStatusClass</NAME>
struct _GimpDeviceStatusClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_device_status_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_status_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_device_status_update</NAME>
<RETURNS>void        </RETURNS>
GimpDeviceStatus *status
</FUNCTION>
<MACRO>
<NAME>GIMP_DIALOG_VISIBILITY_KEY</NAME>
#define GIMP_DIALOG_VISIBILITY_KEY "gimp-dialog-visibility"
</MACRO>
<ENUM>
<NAME>GimpDialogVisibilityState</NAME>
typedef enum
{
  GIMP_DIALOG_VISIBILITY_UNKNOWN = 0,
  GIMP_DIALOG_VISIBILITY_INVISIBLE,
  GIMP_DIALOG_VISIBILITY_VISIBLE
} GimpDialogVisibilityState;
</ENUM>
<USER_FUNCTION>
<NAME>GimpDialogNewFunc</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory      *factory,
                                               GimpContext            *context,
                                               gint                    view_size
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDialogConstructor</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory      *factory,
                                               GimpDialogFactoryEntry *entry,
                                               GimpContext            *context,
                                               gint                    view_size
</USER_FUNCTION>
<STRUCT>
<NAME>GimpDialogFactoryEntry</NAME>
struct _GimpDialogFactoryEntry
{
  gchar             *identifier;
  gchar             *name;
  gchar             *blurb;
  gchar             *stock_id;
  gchar             *help_id;

  GimpDialogNewFunc  new_func;
  gint               view_size;

  gboolean           singleton;
  gboolean           session_managed;
  gboolean           remember_size;
  gboolean           remember_if_open;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_DIALOG_FACTORY</NAME>
#define GIMP_TYPE_DIALOG_FACTORY            (gimp_dialog_factory_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DIALOG_FACTORY</NAME>
#define GIMP_DIALOG_FACTORY(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DIALOG_FACTORY, GimpDialogFactory))
</MACRO>
<MACRO>
<NAME>GIMP_DIALOG_FACTORY_CLASS</NAME>
#define GIMP_DIALOG_FACTORY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DIALOG_FACTORY, GimpDialogFactoryClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DIALOG_FACTORY</NAME>
#define GIMP_IS_DIALOG_FACTORY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DIALOG_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DIALOG_FACTORY_CLASS</NAME>
#define GIMP_IS_DIALOG_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DIALOG_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_DIALOG_FACTORY_GET_CLASS</NAME>
#define GIMP_DIALOG_FACTORY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DIALOG_FACTORY, GimpDialogFactoryClass))
</MACRO>
<STRUCT>
<NAME>GimpDialogFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDialogFactory</NAME>
struct _GimpDialogFactory
{
  GimpObject             parent_instance;

  GimpContext           *context;
  GimpMenuFactory       *menu_factory;

  /*< private >*/
  GimpDialogNewFunc      new_dock_func;
  GimpDialogConstructor  constructor;

  GList                 *registered_dialogs;
  GList                 *session_infos;

  GList                 *open_dialogs;
};
</STRUCT>
<STRUCT>
<NAME>GimpDialogFactoryClass</NAME>
struct _GimpDialogFactoryClass
{
  GimpObjectClass  parent_class;

  GHashTable      *factories;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dialog_factory_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_new</NAME>
<RETURNS>GimpDialogFactory *</RETURNS>
const gchar       *name,GimpContext       *context,GimpMenuFactory   *menu_factory,GimpDialogNewFunc  new_dock_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_from_name</NAME>
<RETURNS>GimpDialogFactory *</RETURNS>
const gchar       *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_set_constructor</NAME>
<RETURNS>void        </RETURNS>
GimpDialogFactory *factory,GimpDialogConstructor constructor
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_register_entry</NAME>
<RETURNS>void        </RETURNS>
GimpDialogFactory *factory,const gchar       *identifier,const gchar       *name,const gchar       *blurb,const gchar       *stock_id,const gchar       *help_id,GimpDialogNewFunc  new_func,gint               view_size,gboolean           singleton,gboolean           session_managed,gboolean           remember_size,gboolean           remember_if_open
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_find_entry</NAME>
<RETURNS>GimpDialogFactoryEntry  *</RETURNS>
GimpDialogFactory *factory,const gchar       *identifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_find_session_info</NAME>
<RETURNS>GimpSessionInfo  *</RETURNS>
GimpDialogFactory *factory,const gchar       *identifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GdkScreen         *screen,const gchar       *identifier,gint               view_size,gboolean           present
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_dialog_raise</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GdkScreen         *screen,const gchar       *identifiers,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_dockable_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GimpDock          *dock,const gchar       *identifier,gint               view_size
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_dock_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,GdkScreen         *screen
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_add_dialog</NAME>
<RETURNS>void        </RETURNS>
GimpDialogFactory *factory,GtkWidget         *dialog
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_add_foreign</NAME>
<RETURNS>void        </RETURNS>
GimpDialogFactory *factory,const gchar       *identifier,GtkWidget         *dialog
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_remove_dialog</NAME>
<RETURNS>void        </RETURNS>
GimpDialogFactory *factory,GtkWidget         *dialog
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_show_toolbox</NAME>
<RETURNS>void        </RETURNS>
GimpDialogFactory *toolbox_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factories_session_save</NAME>
<RETURNS>void        </RETURNS>
GimpConfigWriter  *writer
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factories_session_restore</NAME>
<RETURNS>void        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factories_session_clear</NAME>
<RETURNS>void        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factories_toggle</NAME>
<RETURNS>void        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factories_set_busy</NAME>
<RETURNS>void        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factories_unset_busy</NAME>
<RETURNS>void        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_factory_from_widget</NAME>
<RETURNS>GimpDialogFactory  *</RETURNS>
GtkWidget               *dialog,GimpDialogFactoryEntry **entry
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_xds_source_set</NAME>
<RETURNS>void  </RETURNS>
GdkDragContext   *context,GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_xds_save_image</NAME>
<RETURNS>void  </RETURNS>
GdkDragContext   *context,GimpImage        *image,GtkSelectionData *selection
</FUNCTION>
<MACRO>
<NAME>GIMP_TARGET_URI_LIST</NAME>
#define GIMP_TARGET_URI_LIST \
        { "text/uri-list", 0, GIMP_DND_TYPE_URI_LIST }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_TEXT_PLAIN</NAME>
#define GIMP_TARGET_TEXT_PLAIN \
        { "text/plain", 0, GIMP_DND_TYPE_TEXT_PLAIN }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_NETSCAPE_URL</NAME>
#define GIMP_TARGET_NETSCAPE_URL \
        { "_NETSCAPE_URL", 0, GIMP_DND_TYPE_NETSCAPE_URL }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_XDS</NAME>
#define GIMP_TARGET_XDS \
        { "XdndDirectSave0", 0, GIMP_DND_TYPE_XDS }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_COLOR</NAME>
#define GIMP_TARGET_COLOR \
        { "application/x-color", 0, GIMP_DND_TYPE_COLOR }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_SVG</NAME>
#define GIMP_TARGET_SVG \
        { "image/svg", 0, GIMP_DND_TYPE_SVG }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_SVG_XML</NAME>
#define GIMP_TARGET_SVG_XML \
        { "image/svg+xml", 0, GIMP_DND_TYPE_SVG_XML }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_PIXBUF</NAME>
#define GIMP_TARGET_PIXBUF \
        { NULL, 0, GIMP_DND_TYPE_PIXBUF }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_IMAGE</NAME>
#define GIMP_TARGET_IMAGE \
        { "application/x-gimp-image-id", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_IMAGE }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_COMPONENT</NAME>
#define GIMP_TARGET_COMPONENT \
        { "application/x-gimp-component", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_COMPONENT }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_LAYER</NAME>
#define GIMP_TARGET_LAYER \
        { "application/x-gimp-layer-id", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_LAYER }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_CHANNEL</NAME>
#define GIMP_TARGET_CHANNEL \
        { "application/x-gimp-channel-id", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_CHANNEL }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_LAYER_MASK</NAME>
#define GIMP_TARGET_LAYER_MASK \
        { "application/x-gimp-layer-mask-id", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_LAYER_MASK }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_VECTORS</NAME>
#define GIMP_TARGET_VECTORS \
        { "application/x-gimp-vectors-id", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_VECTORS }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_BRUSH</NAME>
#define GIMP_TARGET_BRUSH \
        { "application/x-gimp-brush-name", 0, GIMP_DND_TYPE_BRUSH }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_PATTERN</NAME>
#define GIMP_TARGET_PATTERN \
        { "application/x-gimp-pattern-name", 0, GIMP_DND_TYPE_PATTERN }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_GRADIENT</NAME>
#define GIMP_TARGET_GRADIENT \
        { "application/x-gimp-gradient-name", 0, GIMP_DND_TYPE_GRADIENT }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_PALETTE</NAME>
#define GIMP_TARGET_PALETTE \
        { "application/x-gimp-palette-name", 0, GIMP_DND_TYPE_PALETTE }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_FONT</NAME>
#define GIMP_TARGET_FONT \
        { "application/x-gimp-font-name", 0, GIMP_DND_TYPE_FONT }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_BUFFER</NAME>
#define GIMP_TARGET_BUFFER \
        { "application/x-gimp-buffer-name", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_BUFFER }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_IMAGEFILE</NAME>
#define GIMP_TARGET_IMAGEFILE \
        { "application/x-gimp-imagefile-name", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_IMAGEFILE }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_TEMPLATE</NAME>
#define GIMP_TARGET_TEMPLATE \
        { "application/x-gimp-template-name", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_TEMPLATE }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_TOOL_INFO</NAME>
#define GIMP_TARGET_TOOL_INFO \
        { "application/x-gimp-tool-info-name", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_TOOL_INFO }
</MACRO>
<MACRO>
<NAME>GIMP_TARGET_DIALOG</NAME>
#define GIMP_TARGET_DIALOG \
        { "application/x-gimp-dialog", GTK_TARGET_SAME_APP, GIMP_DND_TYPE_DIALOG }
</MACRO>
<FUNCTION>
<NAME>gimp_dnd_init</NAME>
<RETURNS>void  </RETURNS>
Gimp *gimp
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDragUriListFunc</NAME>
<RETURNS>GList *</RETURNS>
GtkWidget *widget,
                                            gpointer   data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDropUriListFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget *widget,
                                            gint       x,
                                            gint       y,
                                            GList     *uri_list,
                                            gpointer   data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_uri_list_source_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget,GimpDndDragUriListFunc  get_uri_list_func,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_uri_list_source_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_uri_list_dest_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget,GimpDndDropUriListFunc  set_uri_list_func,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_uri_list_dest_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDragColorFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget     *widget,
                                       GimpRGB       *color,
                                       gpointer       data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDropColorFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget     *widget,
                                       gint           x,
                                       gint           y,
                                       const GimpRGB *color,
                                       gpointer       data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_color_source_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget,GimpDndDragColorFunc  get_color_func,gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_color_source_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_color_dest_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget,GimpDndDropColorFunc  set_color_func,gpointer              data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_color_dest_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDragStreamFunc</NAME>
<RETURNS>guchar *</RETURNS>
GtkWidget    *widget,
                                            gsize        *stream_len,
                                            gpointer      data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDropStreamFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget    *widget,
                                            gint          x,
                                            gint          y,
                                            const guchar *stream,
                                            gsize         stream_len,
                                            gpointer      data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_svg_source_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget,GimpDndDragStreamFunc   get_svg_func,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_svg_source_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_svg_dest_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget,GimpDndDropStreamFunc   set_svg_func,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_svg_dest_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDragPixbufFunc</NAME>
<RETURNS>GdkPixbuf *</RETURNS>
GtkWidget    *widget,
                                               gpointer      data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDropPixbufFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget    *widget,
                                               gint          x,
                                               gint          y,
                                               GdkPixbuf    *pixbuf,
                                               gpointer      data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_pixbuf_source_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget,GimpDndDragPixbufFunc   get_pixbuf_func,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_pixbuf_source_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_pixbuf_dest_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget,GimpDndDropPixbufFunc   set_pixbuf_func,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_pixbuf_dest_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget              *widget
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDragComponentFunc</NAME>
<RETURNS>GimpImage *</RETURNS>
GtkWidget       *widget,
                                                  GimpChannelType *channel,
                                                  gpointer         data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDropComponentFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget       *widget,
                                                  gint             x,
                                                  gint             y,
                                                  GimpImage       *image,
                                                  GimpChannelType  channel,
                                                  gpointer         data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_component_source_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget                 *widget,GimpDndDragComponentFunc   get_comp_func,gpointer                   data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_component_source_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget                 *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_component_dest_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget                 *widget,GimpDndDropComponentFunc   set_comp_func,gpointer                   data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_component_dest_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget                 *widget
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDragViewableFunc</NAME>
<RETURNS>GimpViewable *</RETURNS>
GtkWidget     *widget,
                                                    gpointer       data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpDndDropViewableFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget     *widget,
                                                    gint           x,
                                                    gint           y,
                                                    GimpViewable  *viewable,
                                                    gpointer       data
</USER_FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_drag_source_set_by_type</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget               *widget,GdkModifierType          start_button_mask,GType                    type,GdkDragAction            actions
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_viewable_source_add</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget               *widget,GType                    type,GimpDndDragViewableFunc  get_viewable_func,gpointer                 data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_viewable_source_remove</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget               *widget,GType                    type
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_drag_dest_set_by_type</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget               *widget,GtkDestDefaults          flags,GType                    type,GdkDragAction            actions
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_viewable_dest_add</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget               *widget,GType                    type,GimpDndDropViewableFunc  set_viewable_func,gpointer                 data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_viewable_dest_remove</NAME>
<RETURNS>gboolean </RETURNS>
GtkWidget               *widget,GType                    type
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_get_drag_data</NAME>
<RETURNS>GimpViewable *</RETURNS>
GtkWidget               *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_xds_source_add</NAME>
<RETURNS>void  </RETURNS>
GtkWidget               *widget,GimpDndDragViewableFunc  get_image_func,gpointer                 data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dnd_xds_source_remove</NAME>
<RETURNS>void  </RETURNS>
GtkWidget               *widget
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DOCK</NAME>
#define GIMP_TYPE_DOCK            (gimp_dock_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DOCK</NAME>
#define GIMP_DOCK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCK, GimpDock))
</MACRO>
<MACRO>
<NAME>GIMP_DOCK_CLASS</NAME>
#define GIMP_DOCK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DOCK, GimpDockClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCK</NAME>
#define GIMP_IS_DOCK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCK_CLASS</NAME>
#define GIMP_IS_DOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DOCK))
</MACRO>
<MACRO>
<NAME>GIMP_DOCK_GET_CLASS</NAME>
#define GIMP_DOCK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DOCK, GimpDockClass))
</MACRO>
<STRUCT>
<NAME>GimpDockClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDock</NAME>
struct _GimpDock
{
  GtkWindow          parent_instance;

  GimpDialogFactory *dialog_factory;
  GimpContext       *context;

  GtkWidget         *main_vbox;
  GtkWidget         *vbox;

  GList             *dockbooks;
};
</STRUCT>
<STRUCT>
<NAME>GimpDockClass</NAME>
struct _GimpDockClass
{
  GtkWindowClass parent_class;

  /*  virtual functions  */
  void    (* setup)        (GimpDock       *dock,
                            const GimpDock *template);
  void    (* set_aux_info) (GimpDock       *dock,
                            GList          *aux_info);
  GList * (* get_aux_info) (GimpDock       *dock);

  /*  signals  */
  void    (* book_added)   (GimpDock       *dock,
                            GimpDockbook   *dockbook);
  void    (* book_removed) (GimpDock       *dock,
                            GimpDockbook   *dockbook);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dock_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_setup</NAME>
<RETURNS>void    </RETURNS>
GimpDock       *dock,const GimpDock *template
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_set_aux_info</NAME>
<RETURNS>void    </RETURNS>
GimpDock       *dock,GList          *aux_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_get_aux_info</NAME>
<RETURNS>GList *</RETURNS>
GimpDock       *dock
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_add</NAME>
<RETURNS>void    </RETURNS>
GimpDock       *dock,GimpDockable   *dockable,gint            book,gint            index
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_remove</NAME>
<RETURNS>void    </RETURNS>
GimpDock       *dock,GimpDockable   *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_add_book</NAME>
<RETURNS>void    </RETURNS>
GimpDock       *dock,GimpDockbook   *dockbook,gint            index
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_remove_book</NAME>
<RETURNS>void    </RETURNS>
GimpDock       *dock,GimpDockbook   *dockbook
</FUNCTION>
<MACRO>
<NAME>GIMP_DOCKABLE_DRAG_OFFSET</NAME>
#define GIMP_DOCKABLE_DRAG_OFFSET (-6)
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_DOCKABLE</NAME>
#define GIMP_TYPE_DOCKABLE            (gimp_dockable_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DOCKABLE</NAME>
#define GIMP_DOCKABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCKABLE, GimpDockable))
</MACRO>
<MACRO>
<NAME>GIMP_DOCKABLE_CLASS</NAME>
#define GIMP_DOCKABLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DOCKABLE, GimpDockableClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCKABLE</NAME>
#define GIMP_IS_DOCKABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCKABLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCKABLE_CLASS</NAME>
#define GIMP_IS_DOCKABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DOCKABLE))
</MACRO>
<MACRO>
<NAME>GIMP_DOCKABLE_GET_CLASS</NAME>
#define GIMP_DOCKABLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DOCKABLE, GimpDockableClass))
</MACRO>
<STRUCT>
<NAME>GimpDockableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockable</NAME>
struct _GimpDockable
{
  GtkBin        parent_instance;

  gchar        *name;
  gchar        *blurb;
  gchar        *stock_id;
  gchar        *help_id;
  GimpTabStyle  tab_style;

  GimpDockbook *dockbook;

  GimpContext  *context;

  PangoLayout  *title_layout;
  GdkWindow    *title_window;
  GtkWidget    *menu_button;

  guint         blink_timeout_id;
  gint          blink_counter;

  /*  drag icon hotspot  */
  gint          drag_x;
  gint          drag_y;
};
</STRUCT>
<STRUCT>
<NAME>GimpDockableClass</NAME>
struct _GimpDockableClass
{
  GtkBinClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dockable_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_new</NAME>
<RETURNS>GtkWidget     *</RETURNS>
const gchar    *name,const gchar    *blurb,const gchar    *stock_id,const gchar    *help_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_set_aux_info</NAME>
<RETURNS>void            </RETURNS>
GimpDockable   *dockable,GList          *aux_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_get_aux_info</NAME>
<RETURNS>GList         *</RETURNS>
GimpDockable   *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_set_tab_style</NAME>
<RETURNS>void            </RETURNS>
GimpDockable   *dockable,GimpTabStyle    tab_style
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_get_tab_widget</NAME>
<RETURNS>GtkWidget     *</RETURNS>
GimpDockable   *dockable,GimpContext    *context,GimpTabStyle    tab_style,GtkIconSize     size
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_set_context</NAME>
<RETURNS>void            </RETURNS>
GimpDockable   *dockable,GimpContext    *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_get_menu</NAME>
<RETURNS>GimpUIManager *</RETURNS>
GimpDockable   *dockable,const gchar   **ui_path,gpointer       *popup_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_detach</NAME>
<RETURNS>void            </RETURNS>
GimpDockable   *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_blink</NAME>
<RETURNS>void            </RETURNS>
GimpDockable   *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockable_blink_cancel</NAME>
<RETURNS>void            </RETURNS>
GimpDockable   *dockable
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DOCKBOOK</NAME>
#define GIMP_TYPE_DOCKBOOK            (gimp_dockbook_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DOCKBOOK</NAME>
#define GIMP_DOCKBOOK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCKBOOK, GimpDockbook))
</MACRO>
<MACRO>
<NAME>GIMP_DOCKBOOK_CLASS</NAME>
#define GIMP_DOCKBOOK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DOCKBOOK, GimpDockbookClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCKBOOK</NAME>
#define GIMP_IS_DOCKBOOK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCKBOOK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCKBOOK_CLASS</NAME>
#define GIMP_IS_DOCKBOOK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DOCKBOOK))
</MACRO>
<MACRO>
<NAME>GIMP_DOCKBOOK_GET_CLASS</NAME>
#define GIMP_DOCKBOOK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DOCKBOOK, GimpDockbookClass))
</MACRO>
<STRUCT>
<NAME>GimpDockbookClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockbook</NAME>
struct _GimpDockbook
{
  GtkNotebook    parent_instance;

  GimpDock      *dock;
  GimpUIManager *ui_manager;
};
</STRUCT>
<STRUCT>
<NAME>GimpDockbookClass</NAME>
struct _GimpDockbookClass
{
  GtkNotebookClass parent_class;

  void (* dockable_added)     (GimpDockbook *dockbook,
                               GimpDockable *dockable);
  void (* dockable_removed)   (GimpDockbook *dockbook,
                               GimpDockable *dockable);
  void (* dockable_reordered) (GimpDockbook *dockbook,
                               GimpDockable *dockable);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dockbook_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockbook_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpMenuFactory  *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockbook_add</NAME>
<RETURNS>void        </RETURNS>
GimpDockbook     *dockbook,GimpDockable     *dockable,gint              position
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockbook_remove</NAME>
<RETURNS>void        </RETURNS>
GimpDockbook     *dockbook,GimpDockable     *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockbook_get_tab_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDockbook     *dockbook,GimpDockable     *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_dockbook_drop_dockable</NAME>
<RETURNS>gboolean    </RETURNS>
GimpDockbook     *dockbook,GtkWidget        *drag_source
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DOCKED</NAME>
#define GIMP_TYPE_DOCKED               (gimp_docked_interface_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCKED</NAME>
#define GIMP_IS_DOCKED(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCKED))
</MACRO>
<MACRO>
<NAME>GIMP_DOCKED</NAME>
#define GIMP_DOCKED(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCKED, GimpDocked))
</MACRO>
<MACRO>
<NAME>GIMP_DOCKED_GET_INTERFACE</NAME>
#define GIMP_DOCKED_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GIMP_TYPE_DOCKED, GimpDockedInterface))
</MACRO>
<STRUCT>
<NAME>GimpDockedInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockedInterface</NAME>
struct _GimpDockedInterface
{
  GTypeInterface base_iface;

  /*  signals  */
  void            (* title_changed)       (GimpDocked   *docked);

  /*  virtual functions  */
  void            (* set_aux_info)        (GimpDocked   *docked,
                                           GList        *aux_info);
  GList         * (* get_aux_info)        (GimpDocked   *docked);

  GtkWidget     * (* get_preview)         (GimpDocked   *docked,
                                           GimpContext  *context,
                                           GtkIconSize   size);
  GimpUIManager * (* get_menu)            (GimpDocked   *docked,
                                           const gchar **ui_path,
                                           gpointer     *popup_data);
  gchar         * (* get_title)           (GimpDocked   *docked);

  void            (* set_context)         (GimpDocked   *docked,
                                           GimpContext  *context);

  gboolean        (* has_button_bar)      (GimpDocked   *docked);
  void            (* set_show_button_bar) (GimpDocked   *docked,
                                           gboolean      show);
  gboolean        (* get_show_button_bar) (GimpDocked   *docked);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_docked_interface_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_title_changed</NAME>
<RETURNS>void            </RETURNS>
GimpDocked   *docked
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_set_aux_info</NAME>
<RETURNS>void            </RETURNS>
GimpDocked   *docked,GList        *aux_info
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_get_aux_info</NAME>
<RETURNS>GList         *</RETURNS>
GimpDocked   *docked
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_get_preview</NAME>
<RETURNS>GtkWidget     *</RETURNS>
GimpDocked   *docked,GimpContext  *context,GtkIconSize   size
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_get_menu</NAME>
<RETURNS>GimpUIManager *</RETURNS>
GimpDocked   *docked,const gchar **ui_path,gpointer     *popup_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_get_title</NAME>
<RETURNS>gchar         *</RETURNS>
GimpDocked   *docked
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_set_context</NAME>
<RETURNS>void            </RETURNS>
GimpDocked   *docked,GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_has_button_bar</NAME>
<RETURNS>gboolean        </RETURNS>
GimpDocked   *docked
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_set_show_button_bar</NAME>
<RETURNS>void            </RETURNS>
GimpDocked   *docked,gboolean      show
</FUNCTION>
<FUNCTION>
<NAME>gimp_docked_get_show_button_bar</NAME>
<RETURNS>gboolean        </RETURNS>
GimpDocked   *docked
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DOCUMENT_VIEW</NAME>
#define GIMP_TYPE_DOCUMENT_VIEW            (gimp_document_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DOCUMENT_VIEW</NAME>
#define GIMP_DOCUMENT_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCUMENT_VIEW, GimpDocumentView))
</MACRO>
<MACRO>
<NAME>GIMP_DOCUMENT_VIEW_CLASS</NAME>
#define GIMP_DOCUMENT_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DOCUMENT_VIEW, GimpDocumentViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCUMENT_VIEW</NAME>
#define GIMP_IS_DOCUMENT_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCUMENT_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCUMENT_VIEW_CLASS</NAME>
#define GIMP_IS_DOCUMENT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DOCUMENT_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_DOCUMENT_VIEW_GET_CLASS</NAME>
#define GIMP_DOCUMENT_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DOCUMENT_VIEW, GimpDocumentViewClass))
</MACRO>
<STRUCT>
<NAME>GimpDocumentViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDocumentView</NAME>
struct _GimpDocumentView
{
  GimpContainerEditor  parent_instance;

  GtkWidget           *open_button;
  GtkWidget           *remove_button;
  GtkWidget           *refresh_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpDocumentViewClass</NAME>
struct _GimpDocumentViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_document_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_document_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpContainer   *container,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DRAWABLE_TREE_VIEW</NAME>
#define GIMP_TYPE_DRAWABLE_TREE_VIEW            (gimp_drawable_tree_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DRAWABLE_TREE_VIEW</NAME>
#define GIMP_DRAWABLE_TREE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DRAWABLE_TREE_VIEW, GimpDrawableTreeView))
</MACRO>
<MACRO>
<NAME>GIMP_DRAWABLE_TREE_VIEW_CLASS</NAME>
#define GIMP_DRAWABLE_TREE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DRAWABLE_TREE_VIEW, GimpDrawableTreeViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DRAWABLE_TREE_VIEW</NAME>
#define GIMP_IS_DRAWABLE_TREE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DRAWABLE_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DRAWABLE_TREE_VIEW_CLASS</NAME>
#define GIMP_IS_DRAWABLE_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DRAWABLE_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_DRAWABLE_TREE_VIEW_GET_CLASS</NAME>
#define GIMP_DRAWABLE_TREE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DRAWABLE_TREE_VIEW, GimpDrawableTreeViewClass))
</MACRO>
<STRUCT>
<NAME>GimpDrawableTreeViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDrawableTreeView</NAME>
struct _GimpDrawableTreeView
{
  GimpItemTreeView  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpDrawableTreeViewClass</NAME>
struct _GimpDrawableTreeViewClass
{
  GimpItemTreeViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_drawable_tree_view_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_EDITOR</NAME>
#define GIMP_TYPE_EDITOR            (gimp_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_EDITOR</NAME>
#define GIMP_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_EDITOR, GimpEditor))
</MACRO>
<MACRO>
<NAME>GIMP_EDITOR_CLASS</NAME>
#define GIMP_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_EDITOR, GimpEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_EDITOR</NAME>
#define GIMP_IS_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_EDITOR_CLASS</NAME>
#define GIMP_IS_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_EDITOR_GET_CLASS</NAME>
#define GIMP_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_EDITOR, GimpEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEditor</NAME>
struct _GimpEditor
{
  GtkVBox          parent_instance;

  GimpMenuFactory *menu_factory;
  gchar           *menu_identifier;
  GimpUIManager   *ui_manager;
  gchar           *ui_path;
  gpointer         popup_data;

  gboolean         show_button_bar;
  GtkWidget       *name_label;
  GtkWidget       *button_box;
};
</STRUCT>
<STRUCT>
<NAME>GimpEditorClass</NAME>
struct _GimpEditorClass
{
  GtkVBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_create_menu</NAME>
<RETURNS>void        </RETURNS>
GimpEditor           *editor,GimpMenuFactory      *menu_factory,const gchar          *menu_identifier,const gchar          *ui_path,gpointer              popup_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_popup_menu</NAME>
<RETURNS>gboolean    </RETURNS>
GimpEditor           *editor,GimpMenuPositionFunc  position_func,gpointer              position_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_add_button</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpEditor           *editor,const gchar          *stock_id,const gchar          *tooltip,const gchar          *help_id,GCallback             callback,GCallback             extended_callback,gpointer              callback_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_add_stock_box</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpEditor           *editor,GType                 enum_type,const gchar          *stock_prefix,GCallback             callback,gpointer              callback_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_add_action_button</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpEditor           *editor,const gchar          *group_name,const gchar          *action_name,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_set_show_name</NAME>
<RETURNS>void        </RETURNS>
GimpEditor         *editor,gboolean            show
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_set_name</NAME>
<RETURNS>void        </RETURNS>
GimpEditor         *editor,const gchar        *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_editor_set_box_style</NAME>
<RETURNS>void        </RETURNS>
GimpEditor         *editor,GtkBox             *box
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ENUM_ACTION</NAME>
#define GIMP_TYPE_ENUM_ACTION            (gimp_enum_action_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ENUM_ACTION</NAME>
#define GIMP_ENUM_ACTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ENUM_ACTION, GimpEnumAction))
</MACRO>
<MACRO>
<NAME>GIMP_ENUM_ACTION_CLASS</NAME>
#define GIMP_ENUM_ACTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ENUM_ACTION, GimpEnumActionClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ENUM_ACTION</NAME>
#define GIMP_IS_ENUM_ACTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ENUM_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ENUM_ACTION_CLASS</NAME>
#define GIMP_IS_ENUM_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), GIMP_TYPE_ENUM_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_ENUM_ACTION_GET_CLASS</NAME>
#define GIMP_ENUM_ACTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GIMP_TYPE_ENUM_ACTION, GimpEnumActionClass))
</MACRO>
<STRUCT>
<NAME>GimpEnumActionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEnumAction</NAME>
struct _GimpEnumAction
{
  GimpAction parent_instance;

  gint       value;
  gboolean   value_variable;
};
</STRUCT>
<STRUCT>
<NAME>GimpEnumActionClass</NAME>
struct _GimpEnumActionClass
{
  GimpActionClass parent_class;

  void (* selected) (GimpEnumAction *action,
                     gint            value);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_enum_action_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_enum_action_new</NAME>
<RETURNS>GimpEnumAction *</RETURNS>
const gchar    *name,const gchar    *label,const gchar    *tooltip,const gchar    *stock_id,gint            value,gboolean        value_variable
</FUNCTION>
<FUNCTION>
<NAME>gimp_enum_action_selected</NAME>
<RETURNS>void             </RETURNS>
GimpEnumAction *action,gint            value
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ERROR_CONSOLE</NAME>
#define GIMP_TYPE_ERROR_CONSOLE            (gimp_error_console_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ERROR_CONSOLE</NAME>
#define GIMP_ERROR_CONSOLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ERROR_CONSOLE, GimpErrorConsole))
</MACRO>
<MACRO>
<NAME>GIMP_ERROR_CONSOLE_CLASS</NAME>
#define GIMP_ERROR_CONSOLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ERROR_CONSOLE, GimpErrorConsoleClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERROR_CONSOLE</NAME>
#define GIMP_IS_ERROR_CONSOLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ERROR_CONSOLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERROR_CONSOLE_CLASS</NAME>
#define GIMP_IS_ERROR_CONSOLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ERROR_CONSOLE))
</MACRO>
<MACRO>
<NAME>GIMP_ERROR_CONSOLE_GET_CLASS</NAME>
#define GIMP_ERROR_CONSOLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ERROR_CONSOLE, GimpErrorConsoleClass))
</MACRO>
<STRUCT>
<NAME>GimpErrorConsoleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpErrorConsole</NAME>
struct _GimpErrorConsole
{
  GimpEditor     parent_instance;

  Gimp          *gimp;

  GtkTextBuffer *text_buffer;
  GtkWidget     *text_view;

  GtkWidget     *clear_button;
  GtkWidget     *save_button;

  GtkWidget     *file_dialog;
  gboolean       save_selection;
};
</STRUCT>
<STRUCT>
<NAME>GimpErrorConsoleClass</NAME>
struct _GimpErrorConsoleClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_error_console_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_error_console_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp             *gimp,GimpMenuFactory  *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_error_console_add</NAME>
<RETURNS>void        </RETURNS>
GimpErrorConsole *console,const gchar      *stock_id,const gchar      *domain,const gchar      *message
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ERROR_DIALOG</NAME>
#define GIMP_TYPE_ERROR_DIALOG            (gimp_error_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ERROR_DIALOG</NAME>
#define GIMP_ERROR_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ERROR_DIALOG, GimpErrorDialog))
</MACRO>
<MACRO>
<NAME>GIMP_ERROR_DIALOG_CLASS</NAME>
#define GIMP_ERROR_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ERROR_DIALOG, GimpErrorDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERROR_DIALOG</NAME>
#define GIMP_IS_ERROR_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ERROR_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ERROR_DIALOG_CLASS</NAME>
#define GIMP_IS_ERROR_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ERROR_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_ERROR_DIALOG_GET_CLASS</NAME>
#define GIMP_ERROR_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ERROR_DIALOG, GimpErrorDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpErrorDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpErrorDialog</NAME>
struct _GimpErrorDialog
{
  GimpDialog       parent_instance;

  GtkWidget       *vbox;

  GtkWidget       *last_box;
  gchar           *last_domain;
  gchar           *last_message;
  gint             num_messages;
};
</STRUCT>
<STRUCT>
<NAME>GimpErrorDialogClass</NAME>
struct _GimpErrorDialogClass
{
  GimpDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_error_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_error_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar     *title
</FUNCTION>
<FUNCTION>
<NAME>gimp_error_dialog_add</NAME>
<RETURNS>void        </RETURNS>
GimpErrorDialog *dialog,const gchar     *stock_id,const gchar     *domain,const gchar     *message
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FG_BG_EDITOR</NAME>
#define GIMP_TYPE_FG_BG_EDITOR            (gimp_fg_bg_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FG_BG_EDITOR</NAME>
#define GIMP_FG_BG_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FG_BG_EDITOR, GimpFgBgEditor))
</MACRO>
<MACRO>
<NAME>GIMP_FG_BG_EDITOR_CLASS</NAME>
#define GIMP_FG_BG_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FG_BG_EDITOR, GimpFgBgEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FG_BG_EDITOR</NAME>
#define GIMP_IS_FG_BG_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FG_BG_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FG_BG_EDITOR_CLASS</NAME>
#define GIMP_IS_FG_BG_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FG_BG_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_FG_BG_EDITOR_GET_CLASS</NAME>
#define GIMP_FG_BG_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FG_BG_EDITOR, GimpFgBgEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpFgBgEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFgBgEditor</NAME>
struct _GimpFgBgEditor
{
  GtkDrawingArea   parent_instance;

  GimpContext     *context;
  GimpActiveColor  active_color;

  guchar          *render_buf;
  gint             render_buf_size;

  GdkPixbuf       *default_icon;
  GdkPixbuf       *swap_icon;

  gint             rect_width;
  gint             rect_height;
  gint             click_target;
};
</STRUCT>
<STRUCT>
<NAME>GimpFgBgEditorClass</NAME>
struct _GimpFgBgEditorClass
{
  GtkDrawingAreaClass  parent_class;

  /*  signals  */

  void (* color_clicked) (GimpFgBgEditor  *editor,
                          GimpActiveColor  color);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_fg_bg_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_fg_bg_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_fg_bg_editor_set_context</NAME>
<RETURNS>void        </RETURNS>
GimpFgBgEditor  *editor,GimpContext     *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_fg_bg_editor_set_active</NAME>
<RETURNS>void        </RETURNS>
GimpFgBgEditor  *editor,GimpActiveColor  active
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FG_BG_VIEW</NAME>
#define GIMP_TYPE_FG_BG_VIEW            (gimp_fg_bg_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FG_BG_VIEW</NAME>
#define GIMP_FG_BG_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FG_BG_VIEW, GimpFgBgView))
</MACRO>
<MACRO>
<NAME>GIMP_FG_BG_VIEW_CLASS</NAME>
#define GIMP_FG_BG_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FG_BG_VIEW, GimpFgBgViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FG_BG_VIEW</NAME>
#define GIMP_IS_FG_BG_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FG_BG_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FG_BG_VIEW_CLASS</NAME>
#define GIMP_IS_FG_BG_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FG_BG_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_FG_BG_VIEW_GET_CLASS</NAME>
#define GIMP_FG_BG_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FG_BG_VIEW, GimpFgBgViewClass))
</MACRO>
<STRUCT>
<NAME>GimpFgBgViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFgBgView</NAME>
struct _GimpFgBgView
{
  GtkDrawingArea   parent_instance;

  GimpContext     *context;

  guchar          *render_buf;
  gint             render_buf_size;
};
</STRUCT>
<STRUCT>
<NAME>GimpFgBgViewClass</NAME>
struct _GimpFgBgViewClass
{
  GtkDrawingAreaClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_fg_bg_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_fg_bg_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContext  *context
</FUNCTION>
<FUNCTION>
<NAME>gimp_fg_bg_view_set_context</NAME>
<RETURNS>void        </RETURNS>
GimpFgBgView *view,GimpContext  *context
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FILE_DIALOG</NAME>
#define GIMP_TYPE_FILE_DIALOG            (gimp_file_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FILE_DIALOG</NAME>
#define GIMP_FILE_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FILE_DIALOG, GimpFileDialog))
</MACRO>
<MACRO>
<NAME>GIMP_FILE_DIALOG_CLASS</NAME>
#define GIMP_FILE_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FILE_DIALOG, GimpFileDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FILE_DIALOG</NAME>
#define GIMP_IS_FILE_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FILE_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FILE_DIALOG_CLASS</NAME>
#define GIMP_IS_FILE_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FILE_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_FILE_DIALOG_GET_CLASS</NAME>
#define GIMP_FILE_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FILE_DIALOG, GimpFileDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpFileDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFileDialog</NAME>
struct _GimpFileDialog
{
  GtkFileChooserDialog  parent_instance;

  GimpPlugInProcedure  *file_proc;

  GimpImage            *image;
  gboolean              save_a_copy;

  GtkWidget            *thumb_box;
  GtkWidget            *proc_expander;
  GtkWidget            *proc_view;
  GtkWidget            *progress;

  gboolean              busy;
  gboolean              canceled;
};
</STRUCT>
<STRUCT>
<NAME>GimpFileDialogClass</NAME>
struct _GimpFileDialogClass
{
  GtkFileChooserDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_file_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp                 *gimp,GtkFileChooserAction  action,const gchar          *title,const gchar          *role,const gchar          *stock_id,const gchar          *help_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_dialog_set_sensitive</NAME>
<RETURNS>void        </RETURNS>
GimpFileDialog       *dialog,gboolean              sensitive
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_dialog_set_file_proc</NAME>
<RETURNS>void        </RETURNS>
GimpFileDialog       *dialog,GimpPlugInProcedure  *file_proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_dialog_set_image</NAME>
<RETURNS>void        </RETURNS>
GimpFileDialog       *dialog,GimpImage            *image,gboolean              save_a_copy
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FILE_PROC_VIEW</NAME>
#define GIMP_TYPE_FILE_PROC_VIEW            (gimp_file_proc_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FILE_PROC_VIEW</NAME>
#define GIMP_FILE_PROC_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FILE_PROC_VIEW, GimpFileProcView))
</MACRO>
<MACRO>
<NAME>GIMP_FILE_PROC_VIEW_CLASS</NAME>
#define GIMP_FILE_PROC_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FILE_PROC_VIEW, GimpFileProcViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FILE_PROC_VIEW</NAME>
#define GIMP_IS_FILE_PROC_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FILE_PROC_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FILE_PROC_VIEW_CLASS</NAME>
#define GIMP_IS_FILE_PROC_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FILE_PROC_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_FILE_PROC_VIEW_GET_CLASS</NAME>
#define GIMP_FILE_PROC_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FILE_PROC_VIEW, GimpFileProcViewClass))
</MACRO>
<STRUCT>
<NAME>GimpFileProcViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFileProcView</NAME>
struct _GimpFileProcView
{
  GtkTreeView        parent_instance;

  GList             *meta_extensions;
};
</STRUCT>
<STRUCT>
<NAME>GimpFileProcViewClass</NAME>
struct _GimpFileProcViewClass
{
  GtkTreeViewClass   parent_class;

  void (* changed) (GimpFileProcView *view);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_file_proc_view_get_type</NAME>
<RETURNS>GType                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_proc_view_new</NAME>
<RETURNS>GtkWidget           *</RETURNS>
Gimp                 *gimp,GSList               *procedures,const gchar          *automatic,const gchar          *automatic_help_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_proc_view_get_proc</NAME>
<RETURNS>GimpPlugInProcedure *</RETURNS>
GimpFileProcView     *view,gchar               **label
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_proc_view_set_proc</NAME>
<RETURNS>gboolean              </RETURNS>
GimpFileProcView     *view,GimpPlugInProcedure  *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_file_proc_view_get_help_id</NAME>
<RETURNS>gchar               *</RETURNS>
GimpFileProcView     *view
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FONT_SELECT</NAME>
#define GIMP_TYPE_FONT_SELECT            (gimp_font_select_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FONT_SELECT</NAME>
#define GIMP_FONT_SELECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FONT_SELECT, GimpFontSelect))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_SELECT_CLASS</NAME>
#define GIMP_FONT_SELECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FONT_SELECT, GimpFontSelectClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_SELECT</NAME>
#define GIMP_IS_FONT_SELECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FONT_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_SELECT_CLASS</NAME>
#define GIMP_IS_FONT_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FONT_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_SELECT_GET_CLASS</NAME>
#define GIMP_FONT_SELECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FONT_SELECT, GimpFontSelectClass))
</MACRO>
<STRUCT>
<NAME>GimpFontSelectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFontSelect</NAME>
struct _GimpFontSelect
{
  GimpPdbDialog  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpFontSelectClass</NAME>
struct _GimpFontSelectClass
{
  GimpPdbDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_font_select_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_FONT_VIEW</NAME>
#define GIMP_TYPE_FONT_VIEW            (gimp_font_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_FONT_VIEW</NAME>
#define GIMP_FONT_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_FONT_VIEW, GimpFontView))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_VIEW_CLASS</NAME>
#define GIMP_FONT_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_FONT_VIEW, GimpFontViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_VIEW</NAME>
#define GIMP_IS_FONT_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_FONT_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_FONT_VIEW_CLASS</NAME>
#define GIMP_IS_FONT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_FONT_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_FONT_VIEW_GET_CLASS</NAME>
#define GIMP_FONT_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_FONT_VIEW, GimpFontViewClass))
</MACRO>
<STRUCT>
<NAME>GimpFontViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFontView</NAME>
struct _GimpFontView
{
  GimpContainerEditor  parent_instance;

  GtkWidget           *refresh_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpFontViewClass</NAME>
struct _GimpFontViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_font_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_font_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpContainer   *container,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GRAD_NUM_COLORS</NAME>
#define GRAD_NUM_COLORS 10
</MACRO>
<ENUM>
<NAME>GradientEditorDragMode</NAME>
typedef enum
{
  GRAD_DRAG_NONE = 0,
  GRAD_DRAG_LEFT,
  GRAD_DRAG_MIDDLE,
  GRAD_DRAG_ALL
} GradientEditorDragMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_GRADIENT_EDITOR</NAME>
#define GIMP_TYPE_GRADIENT_EDITOR            (gimp_gradient_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_EDITOR</NAME>
#define GIMP_GRADIENT_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GRADIENT_EDITOR, GimpGradientEditor))
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_EDITOR_CLASS</NAME>
#define GIMP_GRADIENT_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GRADIENT_EDITOR, GimpGradientEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRADIENT_EDITOR</NAME>
#define GIMP_IS_GRADIENT_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GRADIENT_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRADIENT_EDITOR_CLASS</NAME>
#define GIMP_IS_GRADIENT_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GRADIENT_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_EDITOR_GET_CLASS</NAME>
#define GIMP_GRADIENT_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_GRADIENT_EDITOR, GimpGradientEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpGradientEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradientEditor</NAME>
struct _GimpGradientEditor
{
  GimpDataEditor  parent_instance;

  GtkWidget      *hint_label1;
  GtkWidget      *hint_label2;
  GtkWidget      *hint_label3;
  GtkWidget      *hint_label4;
  GtkWidget      *scrollbar;
  GtkWidget      *view;
  GtkWidget      *control;

  /*  Zoom and scrollbar  */
  guint           zoom_factor;
  GtkObject      *scroll_data;

  /*  Instant update  */
  gboolean        instant_update;

  /*  Color dialog  */
  GtkWidget      *color_dialog;

  /*  Gradient view  */
  gint            view_last_x;
  gboolean        view_button_down;

  /*  Gradient control  */
  GdkPixmap              *control_pixmap;
  GimpGradientSegment    *control_drag_segment; /* Segment which is being dragged */
  GimpGradientSegment    *control_sel_l;        /* Left segment of selection */
  GimpGradientSegment    *control_sel_r;        /* Right segment of selection */
  GradientEditorDragMode  control_drag_mode;    /* What is being dragged? */
  guint32                 control_click_time;   /* Time when mouse was pressed */
  gboolean                control_compress;     /* Compressing/expanding handles */
  gint                    control_last_x;       /* Last mouse position when dragging */
  gdouble                 control_last_gx;      /* Last position (wrt gradient) when dragging */
  gdouble                 control_orig_pos;     /* Original click position when dragging */

  /*  Split uniformly dialog  */
  gint          split_parts;

  /*  Replicate dialog  */
  gint          replicate_times;

  /*  Saved colors  */
  GimpRGB       saved_colors[GRAD_NUM_COLORS];

  /*  Color dialogs  */
  GimpGradientSegment *left_saved_segments;
  gboolean             left_saved_dirty;

  GimpGradientSegment *right_saved_segments;
  gboolean             right_saved_dirty;
};
</STRUCT>
<STRUCT>
<NAME>GimpGradientEditorClass</NAME>
struct _GimpGradientEditorClass
{
  GimpDataEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_gradient_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp               *gimp,GimpMenuFactory    *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_editor_update</NAME>
<RETURNS>void        </RETURNS>
GimpGradientEditor *editor
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_editor_zoom</NAME>
<RETURNS>void        </RETURNS>
GimpGradientEditor *editor,GimpZoomType        zoom_type
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_GRADIENT_SELECT</NAME>
#define GIMP_TYPE_GRADIENT_SELECT            (gimp_gradient_select_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_SELECT</NAME>
#define GIMP_GRADIENT_SELECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GRADIENT_SELECT, GimpGradientSelect))
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_SELECT_CLASS</NAME>
#define GIMP_GRADIENT_SELECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GRADIENT_SELECT, GimpGradientSelectClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRADIENT_SELECT</NAME>
#define GIMP_IS_GRADIENT_SELECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GRADIENT_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRADIENT_SELECT_CLASS</NAME>
#define GIMP_IS_GRADIENT_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GRADIENT_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_GRADIENT_SELECT_GET_CLASS</NAME>
#define GIMP_GRADIENT_SELECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_GRADIENT_SELECT, GimpGradientSelectClass))
</MACRO>
<STRUCT>
<NAME>GimpGradientSelectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradientSelect</NAME>
struct _GimpGradientSelect
{
  GimpPdbDialog  parent_instance;

  gint           sample_size;
};
</STRUCT>
<STRUCT>
<NAME>GimpGradientSelectClass</NAME>
struct _GimpGradientSelectClass
{
  GimpPdbDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_gradient_select_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_GRID_EDITOR</NAME>
#define GIMP_TYPE_GRID_EDITOR            (gimp_grid_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_GRID_EDITOR</NAME>
#define GIMP_GRID_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_GRID_EDITOR, GimpGridEditor))
</MACRO>
<MACRO>
<NAME>GIMP_GRID_EDITOR_CLASS</NAME>
#define GIMP_GRID_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_GRID_EDITOR, GimpGridEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRID_EDITOR</NAME>
#define GIMP_IS_GRID_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_GRID_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_GRID_EDITOR_CLASS</NAME>
#define GIMP_IS_GRID_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_GRID_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_GRID_EDITOR_GET_CLASS</NAME>
#define GIMP_GRID_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_GRID_EDITOR, GimpGridEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpGridEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGridEditor</NAME>
struct _GimpGridEditor
{
  GtkVBox       parent_instance;

  GimpGrid     *grid;
  gdouble       xresolution;
  gdouble       yresolution;
};
</STRUCT>
<STRUCT>
<NAME>GimpGridEditorClass</NAME>
struct _GimpGridEditorClass
{
  GtkVBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_grid_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_grid_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpGrid *grid,gdouble   xresolution,gdouble   yresolution
</FUNCTION>
<FUNCTION>
<NAME>gimp_help_show</NAME>
<RETURNS>void   </RETURNS>
Gimp        *gimp,const gchar *help_domain,const gchar *help_id
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_HISTOGRAM_BOX</NAME>
#define GIMP_TYPE_HISTOGRAM_BOX            (gimp_histogram_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_BOX</NAME>
#define GIMP_HISTOGRAM_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_HISTOGRAM_BOX, GimpHistogramBox))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_BOX_CLASS</NAME>
#define GIMP_HISTOGRAM_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_HISTOGRAM_BOX, GimpHistogramBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_BOX</NAME>
#define GIMP_IS_HISTOGRAM_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_HISTOGRAM_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_BOX_CLASS</NAME>
#define GIMP_IS_HISTOGRAM_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_HISTOGRAM_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_BOX_GET_CLASS</NAME>
#define GIMP_HISTOGRAM_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_HISTOGRAM_BOX, GimpHistogramBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpHistogramBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogramBox</NAME>
struct _GimpHistogramBox
{
  GtkVBox            parent_instance;

  GtkWidget         *slider_area;
  GimpHistogramView *view;

  GtkAdjustment     *low_adj;
  GtkAdjustment     *high_adj;

  gint              slider_pos[2];
  gint              active_slider;
  gint              low_slider_val;
  gint              high_slider_val;
};
</STRUCT>
<STRUCT>
<NAME>GimpHistogramBoxClass</NAME>
struct _GimpHistogramBoxClass
{
  GtkVBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_histogram_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_box_set_channel</NAME>
<RETURNS>void        </RETURNS>
GimpHistogramBox     *box,GimpHistogramChannel  channel
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_HISTOGRAM_EDITOR</NAME>
#define GIMP_TYPE_HISTOGRAM_EDITOR            (gimp_histogram_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_EDITOR</NAME>
#define GIMP_HISTOGRAM_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_HISTOGRAM_EDITOR, GimpHistogramEditor))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_EDITOR_CLASS</NAME>
#define GIMP_HISTOGRAM_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_HISTOGRAM_EDITOR, GimpHistogramEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_EDITOR</NAME>
#define GIMP_IS_HISTOGRAM_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_HISTOGRAM_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_EDITOR_CLASS</NAME>
#define GIMP_IS_HISTOGRAM_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_HISTOGRAM_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_EDITOR_GET_CLASS</NAME>
#define GIMP_HISTOGRAM_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_HISTOGRAM_EDITOR, GimpHistogramEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpHistogramEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogramEditor</NAME>
struct _GimpHistogramEditor
{
  GimpImageEditor       parent_instance;

  GimpDrawable         *drawable;
  GimpHistogram        *histogram;

  guint                 idle_id;
  gboolean              valid;

  GtkWidget            *menu;
  GtkWidget            *box;
  GtkWidget            *labels[6];
};
</STRUCT>
<STRUCT>
<NAME>GimpHistogramEditorClass</NAME>
struct _GimpHistogramEditorClass
{
  GimpImageEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_histogram_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_HISTOGRAM_VIEW</NAME>
#define GIMP_TYPE_HISTOGRAM_VIEW            (gimp_histogram_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_VIEW</NAME>
#define GIMP_HISTOGRAM_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_HISTOGRAM_VIEW, GimpHistogramView))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_VIEW_CLASS</NAME>
#define GIMP_HISTOGRAM_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_HISTOGRAM_VIEW, GimpHistogramViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_VIEW</NAME>
#define GIMP_IS_HISTOGRAM_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_HISTOGRAM_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_HISTOGRAM_VIEW_CLASS</NAME>
#define GIMP_IS_HISTOGRAM_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_HISTOGRAM_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_HISTOGRAM_VIEW_GET_CLASS</NAME>
#define GIMP_HISTOGRAM_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_HISTOGRAM_VIEW, GimpHistogramView))
</MACRO>
<STRUCT>
<NAME>GimpHistogramViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogramView</NAME>
struct _GimpHistogramView
{
  GtkDrawingArea         parent_instance;

  GimpHistogram         *histogram;
  GimpHistogramChannel   channel;
  GimpHistogramScale     scale;
  gint                   start;
  gint                   end;

  gint                   border_width;
  gint                   subdivisions;

  /* hack */
  gboolean               light_histogram;
};
</STRUCT>
<STRUCT>
<NAME>GimpHistogramViewClass</NAME>
struct _GimpHistogramViewClass
{
  GtkDrawingAreaClass  parent_class;

  void (* range_changed) (GimpHistogramView *view,
                          gint               start,
                          gint               end);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_histogram_view_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_new</NAME>
<RETURNS>GtkWidget     *</RETURNS>
gboolean              range
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_set_histogram</NAME>
<RETURNS>void            </RETURNS>
GimpHistogramView    *view,GimpHistogram        *histogram
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_get_histogram</NAME>
<RETURNS>GimpHistogram *</RETURNS>
GimpHistogramView    *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_set_channel</NAME>
<RETURNS>void            </RETURNS>
GimpHistogramView    *view,GimpHistogramChannel  channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_get_channel</NAME>
<RETURNS>GimpHistogramChannel </RETURNS>
GimpHistogramView *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_set_scale</NAME>
<RETURNS>void            </RETURNS>
GimpHistogramView    *view,GimpHistogramScale    scale
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_get_scale</NAME>
<RETURNS>GimpHistogramScale </RETURNS>
GimpHistogramView    *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_set_range</NAME>
<RETURNS>void            </RETURNS>
GimpHistogramView    *view,gint                  start,gint                  end
</FUNCTION>
<FUNCTION>
<NAME>gimp_histogram_view_get_range</NAME>
<RETURNS>void            </RETURNS>
GimpHistogramView    *view,gint                 *start,gint                 *end
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_DOCK</NAME>
#define GIMP_TYPE_IMAGE_DOCK            (gimp_image_dock_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_DOCK</NAME>
#define GIMP_IMAGE_DOCK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_DOCK, GimpImageDock))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_DOCK_CLASS</NAME>
#define GIMP_IMAGE_DOCK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_DOCK, GimpImageDockClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_DOCK</NAME>
#define GIMP_IS_IMAGE_DOCK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_DOCK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_DOCK_CLASS</NAME>
#define GIMP_IS_IMAGE_DOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_DOCK))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_DOCK_GET_CLASS</NAME>
#define GIMP_IMAGE_DOCK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_DOCK, GimpImageDockClass))
</MACRO>
<STRUCT>
<NAME>GimpImageDockClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageDock</NAME>
struct _GimpImageDock
{
  GimpDock       parent_instance;

  GimpUIManager *ui_manager;
  GQuark         image_flush_handler_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpImageDockClass</NAME>
struct _GimpImageDockClass
{
  GimpDockClass  parent_class;

  const gchar   *ui_manager_name;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_dock_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_EDITOR</NAME>
#define GIMP_TYPE_IMAGE_EDITOR            (gimp_image_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_EDITOR</NAME>
#define GIMP_IMAGE_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_EDITOR, GimpImageEditor))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_EDITOR_CLASS</NAME>
#define GIMP_IMAGE_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_EDITOR, GimpImageEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_EDITOR</NAME>
#define GIMP_IS_IMAGE_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_EDITOR_CLASS</NAME>
#define GIMP_IS_IMAGE_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_EDITOR_GET_CLASS</NAME>
#define GIMP_IMAGE_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_EDITOR, GimpImageEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpImageEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageEditor</NAME>
struct _GimpImageEditor
{
  GimpEditor   parent_instance;

  GimpContext *context;
  GimpImage   *image;
};
</STRUCT>
<STRUCT>
<NAME>GimpImageEditorClass</NAME>
struct _GimpImageEditorClass
{
  GimpEditorClass  parent_class;

  /*  virtual function  */
  void (* set_image) (GimpImageEditor *editor,
                      GimpImage       *image);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_editor_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_editor_set_image</NAME>
<RETURNS>void    </RETURNS>
GimpImageEditor *editor,GimpImage       *image
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_PROP_VIEW</NAME>
#define GIMP_TYPE_IMAGE_PROP_VIEW            (gimp_image_prop_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_PROP_VIEW</NAME>
#define GIMP_IMAGE_PROP_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_PROP_VIEW, GimpImagePropView))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_PROP_VIEW_CLASS</NAME>
#define GIMP_IMAGE_PROP_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_PROP_VIEW, GimpImagePropViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_PROP_VIEW</NAME>
#define GIMP_IS_IMAGE_PROP_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_PROP_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_PROP_VIEW_CLASS</NAME>
#define GIMP_IS_IMAGE_PROP_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_PROP_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_PROP_VIEW_GET_CLASS</NAME>
#define GIMP_IMAGE_PROP_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_PROP_VIEW, GimpImagePropViewClass))
</MACRO>
<STRUCT>
<NAME>GimpImagePropViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImagePropView</NAME>
struct _GimpImagePropView
{
  GtkTable   parent_instance;

  GimpImage *image;

  GtkWidget *pixel_size_label;
  GtkWidget *print_size_label;
  GtkWidget *resolution_label;
  GtkWidget *colorspace_label;
  GtkWidget *memsize_label;
  GtkWidget *undo_label;
  GtkWidget *redo_label;
  GtkWidget *pixels_label;
  GtkWidget *layers_label;
  GtkWidget *channels_label;
  GtkWidget *vectors_label;
};
</STRUCT>
<STRUCT>
<NAME>GimpImagePropViewClass</NAME>
struct _GimpImagePropViewClass
{
  GtkTableClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_prop_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_prop_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpImage *image
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_IMAGE_VIEW</NAME>
#define GIMP_TYPE_IMAGE_VIEW            (gimp_image_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_VIEW</NAME>
#define GIMP_IMAGE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_IMAGE_VIEW, GimpImageView))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_VIEW_CLASS</NAME>
#define GIMP_IMAGE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_IMAGE_VIEW, GimpImageViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_VIEW</NAME>
#define GIMP_IS_IMAGE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_IMAGE_VIEW_CLASS</NAME>
#define GIMP_IS_IMAGE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_IMAGE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IMAGE_VIEW_GET_CLASS</NAME>
#define GIMP_IMAGE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_IMAGE_VIEW, GimpImageViewClass))
</MACRO>
<STRUCT>
<NAME>GimpImageViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageView</NAME>
struct _GimpImageView
{
  GimpContainerEditor  parent_instance;

  GtkWidget           *raise_button;
  GtkWidget           *new_button;
  GtkWidget           *delete_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpImageViewClass</NAME>
struct _GimpImageViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_image_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_image_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpContainer   *container,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<USER_FUNCTION>
<NAME>GimpGetContainerFunc</NAME>
<RETURNS>GimpContainer *</RETURNS>
const GimpImage *image
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpGetItemFunc</NAME>
<RETURNS>GimpItem *</RETURNS>
const GimpImage *image
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpSetItemFunc</NAME>
<RETURNS>void </RETURNS>
GimpImage       *image,
                                                  GimpItem        *item
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpReorderItemFunc</NAME>
<RETURNS>void </RETURNS>
GimpImage       *image,
                                                  GimpItem        *item,
                                                  gint             new_index,
                                                  gboolean         push_undo,
                                                  const gchar     *undo_desc
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpAddItemFunc</NAME>
<RETURNS>void </RETURNS>
GimpImage       *image,
                                                  GimpItem        *item,
                                                  gint             index
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpRemoveItemFunc</NAME>
<RETURNS>void </RETURNS>
GimpImage       *image,
                                                  GimpItem        *item
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpNewItemFunc</NAME>
<RETURNS>GimpItem *</RETURNS>
GimpImage       *image
</USER_FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ITEM_TREE_VIEW</NAME>
#define GIMP_TYPE_ITEM_TREE_VIEW            (gimp_item_tree_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_TREE_VIEW</NAME>
#define GIMP_ITEM_TREE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ITEM_TREE_VIEW, GimpItemTreeView))
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_TREE_VIEW_CLASS</NAME>
#define GIMP_ITEM_TREE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_ITEM_TREE_VIEW, GimpItemTreeViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ITEM_TREE_VIEW</NAME>
#define GIMP_IS_ITEM_TREE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_ITEM_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_ITEM_TREE_VIEW_CLASS</NAME>
#define GIMP_IS_ITEM_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_ITEM_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_ITEM_TREE_VIEW_GET_CLASS</NAME>
#define GIMP_ITEM_TREE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_ITEM_TREE_VIEW, GimpItemTreeViewClass))
</MACRO>
<STRUCT>
<NAME>GimpItemTreeViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpItemTreeView</NAME>
struct _GimpItemTreeView
{
  GimpContainerTreeView  parent_instance;

  GimpContext           *context;
  GimpImage             *image;

  GtkWidget             *edit_button;
  GtkWidget             *new_button;
  GtkWidget             *raise_button;
  GtkWidget             *lower_button;
  GtkWidget             *duplicate_button;
  GtkWidget             *delete_button;

  gint                   model_column_visible;
  gint                   model_column_linked;
  GtkCellRenderer       *eye_cell;
  GtkCellRenderer       *chain_cell;

  /*< private >*/
  GQuark                 visible_changed_handler_id;
  GQuark                 linked_changed_handler_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpItemTreeViewClass</NAME>
struct _GimpItemTreeViewClass
{
  GimpContainerTreeViewClass  parent_class;

  /*  signals  */
  void (* set_image) (GimpItemTreeView *view,
                      GimpImage        *image);

  GType                 item_type;
  const gchar          *signal_name;

  /*  virtual functions for manipulating the image's item tree  */
  GimpGetContainerFunc  get_container;
  GimpGetItemFunc       get_active_item;
  GimpSetItemFunc       set_active_item;
  GimpReorderItemFunc   reorder_item;
  GimpAddItemFunc       add_item;
  GimpRemoveItemFunc    remove_item;
  GimpNewItemFunc       new_item;

  /*  action names  */
  const gchar          *action_group;
  const gchar          *activate_action;
  const gchar          *edit_action;
  const gchar          *new_action;
  const gchar          *new_default_action;
  const gchar          *raise_action;
  const gchar          *raise_top_action;
  const gchar          *lower_action;
  const gchar          *lower_bottom_action;
  const gchar          *duplicate_action;
  const gchar          *delete_action;

  /*  undo descriptions  */
  const gchar          *reorder_desc;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_item_tree_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_tree_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GType            view_type,gint             view_size,gint             view_border_width,GimpImage       *image,GimpMenuFactory *menu_facotry,const gchar     *menu_identifier,const gchar     *ui_identifier
</FUNCTION>
<FUNCTION>
<NAME>gimp_item_tree_view_set_image</NAME>
<RETURNS>void       </RETURNS>
GimpItemTreeView *view,GimpImage        *image
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_LAYER_TREE_VIEW</NAME>
#define GIMP_TYPE_LAYER_TREE_VIEW            (gimp_layer_tree_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_TREE_VIEW</NAME>
#define GIMP_LAYER_TREE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_LAYER_TREE_VIEW, GimpLayerTreeView))
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_TREE_VIEW_CLASS</NAME>
#define GIMP_LAYER_TREE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_LAYER_TREE_VIEW, GimpLayerTreeViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LAYER_TREE_VIEW</NAME>
#define GIMP_IS_LAYER_TREE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LAYER_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_LAYER_TREE_VIEW_CLASS</NAME>
#define GIMP_IS_LAYER_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_LAYER_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_LAYER_TREE_VIEW_GET_CLASS</NAME>
#define GIMP_LAYER_TREE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_LAYER_TREE_VIEW, GimpLayerTreeViewClass))
</MACRO>
<STRUCT>
<NAME>GimpLayerTreeViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLayerTreeView</NAME>
struct _GimpLayerTreeView
{
  GimpDrawableTreeView  parent_instance;

  GtkWidget            *options_box;
  GtkWidget            *paint_mode_menu;
  GtkAdjustment        *opacity_adjustment;
  GtkWidget            *lock_alpha_toggle;

  gint                  model_column_mask;
  gint                  model_column_mask_visible;

  GtkCellRenderer      *mask_cell;

  PangoAttrList        *italic_attrs;
  PangoAttrList        *bold_attrs;

  /*< private >*/
  GQuark                mode_changed_handler_id;
  GQuark                opacity_changed_handler_id;
  GQuark                lock_alpha_changed_handler_id;
  GQuark                mask_changed_handler_id;
  GQuark                alpha_changed_handler_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpLayerTreeViewClass</NAME>
struct _GimpLayerTreeViewClass
{
  GimpDrawableTreeViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_layer_tree_view_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MENU_DOCK</NAME>
#define GIMP_TYPE_MENU_DOCK            (gimp_menu_dock_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MENU_DOCK</NAME>
#define GIMP_MENU_DOCK(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MENU_DOCK, GimpMenuDock))
</MACRO>
<MACRO>
<NAME>GIMP_MENU_DOCK_CLASS</NAME>
#define GIMP_MENU_DOCK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MENU_DOCK, GimpMenuDockClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MENU_DOCK</NAME>
#define GIMP_IS_MENU_DOCK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MENU_DOCK))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MENU_DOCK_CLASS</NAME>
#define GIMP_IS_MENU_DOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MENU_DOCK))
</MACRO>
<MACRO>
<NAME>GIMP_MENU_DOCK_GET_CLASS</NAME>
#define GIMP_MENU_DOCK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MENU_DOCK, GimpMenuDockClass))
</MACRO>
<STRUCT>
<NAME>GimpMenuDockClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMenuDock</NAME>
struct _GimpMenuDock
{
  GimpImageDock  parent_instance;

  GimpContainer *image_container;
  GimpContainer *display_container;

  gboolean       show_image_menu;
  gboolean       auto_follow_active;

  GtkWidget     *image_combo;
  GtkWidget     *auto_button;

  guint          update_title_idle_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpMenuDockClass</NAME>
struct _GimpMenuDockClass
{
  GimpImageDockClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_menu_dock_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_dock_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *dialog_factory,GimpContainer     *image_container,GimpContainer     *display_container
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_dock_set_auto_follow_active</NAME>
<RETURNS>void        </RETURNS>
GimpMenuDock *menu_dock,gboolean      show
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_dock_set_show_image_menu</NAME>
<RETURNS>void        </RETURNS>
GimpMenuDock *menu_dock,gboolean      show
</FUNCTION>
<STRUCT>
<NAME>GimpMenuFactoryEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMenuFactoryEntry</NAME>
struct _GimpMenuFactoryEntry
{
  gchar *identifier;
  GList *action_groups;
  GList *managed_uis;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_MENU_FACTORY</NAME>
#define GIMP_TYPE_MENU_FACTORY            (gimp_menu_factory_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MENU_FACTORY</NAME>
#define GIMP_MENU_FACTORY(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MENU_FACTORY, GimpMenuFactory))
</MACRO>
<MACRO>
<NAME>GIMP_MENU_FACTORY_CLASS</NAME>
#define GIMP_MENU_FACTORY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MENU_FACTORY, GimpMenuFactoryClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MENU_FACTORY</NAME>
#define GIMP_IS_MENU_FACTORY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MENU_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MENU_FACTORY_CLASS</NAME>
#define GIMP_IS_MENU_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MENU_FACTORY))
</MACRO>
<MACRO>
<NAME>GIMP_MENU_FACTORY_GET_CLASS</NAME>
#define GIMP_MENU_FACTORY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MENU_FACTORY, GimpMenuFactoryClass))
</MACRO>
<STRUCT>
<NAME>GimpMenuFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMenuFactory</NAME>
struct _GimpMenuFactory
{
  GimpObject         parent_instance;

  Gimp              *gimp;
  GimpActionFactory *action_factory;
  GList             *registered_menus;
};
</STRUCT>
<STRUCT>
<NAME>GimpMenuFactoryClass</NAME>
struct _GimpMenuFactoryClass
{
  GimpObjectClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_menu_factory_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_factory_new</NAME>
<RETURNS>GimpMenuFactory *</RETURNS>
Gimp              *gimp,GimpActionFactory *action_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_factory_manager_register</NAME>
<RETURNS>void           </RETURNS>
GimpMenuFactory *factory,const gchar     *identifier,const gchar     *first_group,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_factory_manager_new</NAME>
<RETURNS>GimpUIManager *</RETURNS>
GimpMenuFactory *factory,const gchar     *identifier,gpointer         callback_data,gboolean         create_tearoff
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MESSAGE_BOX</NAME>
#define GIMP_TYPE_MESSAGE_BOX            (gimp_message_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MESSAGE_BOX</NAME>
#define GIMP_MESSAGE_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MESSAGE_BOX, GimpMessageBox))
</MACRO>
<MACRO>
<NAME>GIMP_MESSAGE_BOX_CLASS</NAME>
#define GIMP_MESSAGE_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MESSAGE_BOX, GimpMessageBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MESSAGE_BOX</NAME>
#define GIMP_IS_MESSAGE_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MESSAGE_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MESSAGE_BOX_CLASS</NAME>
#define GIMP_IS_MESSAGE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MESSAGE_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_MESSAGE_BOX_GET_CLASS</NAME>
#define GIMP_MESSAGE_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MESSAGE_BOX, GimpMessageBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpMessageBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMessageBox</NAME>
struct _GimpMessageBox
{
  GtkVBox       parent_instance;

  gchar        *stock_id;
  gint          repeat;
  GtkWidget    *label[3];
  GtkWidget    *image;
};
</STRUCT>
<STRUCT>
<NAME>GimpMessageBoxClass</NAME>
struct _GimpMessageBoxClass
{
  GtkVBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_message_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar    *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_box_set_primary_text</NAME>
<RETURNS>void        </RETURNS>
GimpMessageBox *box,const gchar    *format,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_box_set_text</NAME>
<RETURNS>void        </RETURNS>
GimpMessageBox *box,const gchar    *format,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_box_set_markup</NAME>
<RETURNS>void        </RETURNS>
GimpMessageBox *box,const gchar    *format,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_box_repeat</NAME>
<RETURNS>gint        </RETURNS>
GimpMessageBox *box
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_MESSAGE_DIALOG</NAME>
#define GIMP_TYPE_MESSAGE_DIALOG            (gimp_message_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_MESSAGE_DIALOG</NAME>
#define GIMP_MESSAGE_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_MESSAGE_DIALOG, GimpMessageDialog))
</MACRO>
<MACRO>
<NAME>GIMP_MESSAGE_DIALOG_CLASS</NAME>
#define GIMP_MESSAGE_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_MESSAGE_DIALOG, GimpMessageDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MESSAGE_DIALOG</NAME>
#define GIMP_IS_MESSAGE_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_MESSAGE_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_MESSAGE_DIALOG_CLASS</NAME>
#define GIMP_IS_MESSAGE_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_MESSAGE_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_MESSAGE_DIALOG_GET_CLASS</NAME>
#define GIMP_MESSAGE_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_MESSAGE_DIALOG, GimpMessageDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpMessageDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMessageDialog</NAME>
struct _GimpMessageDialog
{
  GimpDialog       parent_instance;

  GimpMessageBox  *box;
};
</STRUCT>
<STRUCT>
<NAME>GimpMessageDialogClass</NAME>
struct _GimpMessageDialogClass
{
  GimpDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_message_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_message_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar       *title,const gchar       *stock_id,GtkWidget         *parent,GtkDialogFlags     flags,GimpHelpFunc       help_func,const gchar       *help_id,...
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_NAVIGATION_VIEW</NAME>
#define GIMP_TYPE_NAVIGATION_VIEW            (gimp_navigation_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_NAVIGATION_VIEW</NAME>
#define GIMP_NAVIGATION_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_NAVIGATION_VIEW, GimpNavigationView))
</MACRO>
<MACRO>
<NAME>GIMP_NAVIGATION_VIEW_CLASS</NAME>
#define GIMP_NAVIGATION_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_NAVIGATION_VIEW, GimpNavigationViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NAVIGATION_VIEW</NAME>
#define GIMP_IS_NAVIGATION_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_NAVIGATION_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_NAVIGATION_VIEW_CLASS</NAME>
#define GIMP_IS_NAVIGATION_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_NAVIGATION_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_NAVIGATION_VIEW_GET_CLASS</NAME>
#define GIMP_NAVIGATION_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_NAVIGATION_VIEW, GimpNavigationViewClass))
</MACRO>
<STRUCT>
<NAME>GimpNavigationViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpNavigationView</NAME>
struct _GimpNavigationView
{
  GimpView     parent_instance;

  /*  values in image coordinates  */
  gdouble      x;
  gdouble      y;
  gdouble      width;
  gdouble      height;

  /*  values in view coordinates  */
  gint         p_x;
  gint         p_y;
  gint         p_width;
  gint         p_height;

  gint         motion_offset_x;
  gint         motion_offset_y;
  gboolean     has_grab;

  GdkGC       *gc;
};
</STRUCT>
<STRUCT>
<NAME>GimpNavigationViewClass</NAME>
struct _GimpNavigationViewClass
{
  GimpViewClass  parent_class;

  void (* marker_changed) (GimpNavigationView *view,
                           gdouble             x,
                           gdouble             y);
  void (* zoom)           (GimpNavigationView *view,
                           GimpZoomType        direction);
  void (* scroll)         (GimpNavigationView *view,
                           GdkScrollDirection  direction);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_navigation_view_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_navigation_view_set_marker</NAME>
<RETURNS>void    </RETURNS>
GimpNavigationView *view,gdouble             x,gdouble             y,gdouble             width,gdouble             height
</FUNCTION>
<FUNCTION>
<NAME>gimp_navigation_view_grab_pointer</NAME>
<RETURNS>void    </RETURNS>
GimpNavigationView *view
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PALETTE_EDITOR</NAME>
#define GIMP_TYPE_PALETTE_EDITOR            (gimp_palette_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_EDITOR</NAME>
#define GIMP_PALETTE_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PALETTE_EDITOR, GimpPaletteEditor))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_EDITOR_CLASS</NAME>
#define GIMP_PALETTE_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PALETTE_EDITOR, GimpPaletteEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_EDITOR</NAME>
#define GIMP_IS_PALETTE_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PALETTE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_EDITOR_CLASS</NAME>
#define GIMP_IS_PALETTE_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PALETTE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_EDITOR_GET_CLASS</NAME>
#define GIMP_PALETTE_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PALETTE_EDITOR, GimpPaletteEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpPaletteEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaletteEditor</NAME>
struct _GimpPaletteEditor
{
  GimpDataEditor    parent_instance;

  GtkWidget        *view;
  GtkWidget        *scrolled_window;

  GtkWidget        *color_name;
  GtkAdjustment    *columns_data;

  GtkWidget        *color_dialog;

  GimpPaletteEntry *color;

  gfloat            zoom_factor;  /* range from 0.1 to 4.0 */
  gint              col_width;
  gint              last_width;
  gint              columns;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaletteEditorClass</NAME>
struct _GimpPaletteEditorClass
{
  GimpDataEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_palette_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp               *gimp,GimpMenuFactory    *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_editor_pick_color</NAME>
<RETURNS>void        </RETURNS>
GimpPaletteEditor  *editor,const GimpRGB      *color,GimpColorPickState  pick_state
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_editor_zoom</NAME>
<RETURNS>void        </RETURNS>
GimpPaletteEditor  *editor,GimpZoomType        zoom_type
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PALETTE_SELECT</NAME>
#define GIMP_TYPE_PALETTE_SELECT            (gimp_palette_select_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_SELECT</NAME>
#define GIMP_PALETTE_SELECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PALETTE_SELECT, GimpPaletteSelect))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_SELECT_CLASS</NAME>
#define GIMP_PALETTE_SELECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PALETTE_SELECT, GimpPaletteSelectClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_SELECT</NAME>
#define GIMP_IS_PALETTE_SELECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PALETTE_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_SELECT_CLASS</NAME>
#define GIMP_IS_PALETTE_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PALETTE_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_SELECT_GET_CLASS</NAME>
#define GIMP_PALETTE_SELECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PALETTE_SELECT, GimpPaletteSelectClass))
</MACRO>
<STRUCT>
<NAME>GimpPaletteSelectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaletteSelect</NAME>
struct _GimpPaletteSelect
{
  GimpPdbDialog  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaletteSelectClass</NAME>
struct _GimpPaletteSelectClass
{
  GimpPdbDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_palette_select_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PATTERN_FACTORY_VIEW</NAME>
#define GIMP_TYPE_PATTERN_FACTORY_VIEW            (gimp_pattern_factory_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_FACTORY_VIEW</NAME>
#define GIMP_PATTERN_FACTORY_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PATTERN_FACTORY_VIEW, GimpPatternFactoryView))
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_FACTORY_VIEW_CLASS</NAME>
#define GIMP_PATTERN_FACTORY_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PATTERN_FACTORY_VIEW, GimpPatternFactoryViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PATTERN_FACTORY_VIEW</NAME>
#define GIMP_IS_PATTERN_FACTORY_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PATTERN_FACTORY_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PATTERN_FACTORY_VIEW_CLASS</NAME>
#define GIMP_IS_PATTERN_FACTORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PATTERN_FACTORY_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_FACTORY_VIEW_GET_CLASS</NAME>
#define GIMP_PATTERN_FACTORY_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PATTERN_FACTORY_VIEW, GimpPatternFactoryViewClass))
</MACRO>
<STRUCT>
<NAME>GimpPatternFactoryViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPatternFactoryView</NAME>
struct _GimpPatternFactoryView
{
  GimpDataFactoryView  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPatternFactoryViewClass</NAME>
struct _GimpPatternFactoryViewClass
{
  GimpDataFactoryViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pattern_factory_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_factory_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpDataFactory *factory,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PATTERN_SELECT</NAME>
#define GIMP_TYPE_PATTERN_SELECT            (gimp_pattern_select_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_SELECT</NAME>
#define GIMP_PATTERN_SELECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PATTERN_SELECT, GimpPatternSelect))
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_SELECT_CLASS</NAME>
#define GIMP_PATTERN_SELECT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PATTERN_SELECT, GimpPatternSelectClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PATTERN_SELECT</NAME>
#define GIMP_IS_PATTERN_SELECT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PATTERN_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PATTERN_SELECT_CLASS</NAME>
#define GIMP_IS_PATTERN_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PATTERN_SELECT))
</MACRO>
<MACRO>
<NAME>GIMP_PATTERN_SELECT_GET_CLASS</NAME>
#define GIMP_PATTERN_SELECT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PATTERN_SELECT, GimpPatternSelectClass))
</MACRO>
<STRUCT>
<NAME>GimpPatternSelectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPatternSelect</NAME>
struct _GimpPatternSelect
{
  GimpPdbDialog  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpPatternSelectClass</NAME>
struct _GimpPatternSelectClass
{
  GimpPdbDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pattern_select_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PDB_DIALOG</NAME>
#define GIMP_TYPE_PDB_DIALOG            (gimp_pdb_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PDB_DIALOG</NAME>
#define GIMP_PDB_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PDB_DIALOG, GimpPdbDialog))
</MACRO>
<MACRO>
<NAME>GIMP_PDB_DIALOG_CLASS</NAME>
#define GIMP_PDB_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PDB_DIALOG, GimpPdbDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PDB_DIALOG</NAME>
#define GIMP_IS_PDB_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PDB_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PDB_DIALOG_CLASS</NAME>
#define GIMP_IS_PDB_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PDB_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_PDB_DIALOG_GET_CLASS</NAME>
#define GIMP_PDB_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PDB_DIALOG, GimpPdbDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpPdbDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPdbDialog</NAME>
struct _GimpPdbDialog
{
  GimpDialog       parent_instance;

  /*  The context we were created with. This is the context the plug-in
   *  exists in and must be used when calling the plug-in.
   */
  GimpContext     *caller_context;

  /*  The dialog's private context, serves just as model for the
   *  select widgets and must not be used when calling the plug-in.
   */
  GimpContext     *context;

  GType            select_type;
  GimpObject      *initial_object;
  gchar           *callback_name;
  gboolean         callback_busy;

  GimpMenuFactory *menu_factory;
  GtkWidget       *view;
};
</STRUCT>
<STRUCT>
<NAME>GimpPdbDialogClass</NAME>
struct _GimpPdbDialogClass
{
  GimpDialogClass  parent_class;

  GList           *dialogs;

  GValueArray * (* run_callback) (GimpPdbDialog *dialog,
                                  GimpObject    *object,
                                  gboolean       closing);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_pdb_dialog_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialog_run_callback</NAME>
<RETURNS>void            </RETURNS>
GimpPdbDialog      *dialog,gboolean            closing
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialog_get_by_callback</NAME>
<RETURNS>GimpPdbDialog *</RETURNS>
GimpPdbDialogClass *klass,const gchar        *callback_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_pdb_dialogs_check_callback</NAME>
<RETURNS>void            </RETURNS>
GimpPdbDialogClass *klass
</FUNCTION>
<FUNCTION>
<NAME>gimp_pixbuf_get_formats</NAME>
<RETURNS>GSList *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_pixbuf_targets_add</NAME>
<RETURNS>void     </RETURNS>
GtkTargetList *target_list,guint          info,gboolean       writable
</FUNCTION>
<FUNCTION>
<NAME>gimp_pixbuf_targets_remove</NAME>
<RETURNS>void     </RETURNS>
GtkTargetList *target_list
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PLUG_IN_ACTION</NAME>
#define GIMP_TYPE_PLUG_IN_ACTION            (gimp_plug_in_action_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PLUG_IN_ACTION</NAME>
#define GIMP_PLUG_IN_ACTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PLUG_IN_ACTION, GimpPlugInAction))
</MACRO>
<MACRO>
<NAME>GIMP_PLUG_IN_ACTION_CLASS</NAME>
#define GIMP_PLUG_IN_ACTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PLUG_IN_ACTION, GimpPlugInActionClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PLUG_IN_ACTION</NAME>
#define GIMP_IS_PLUG_IN_ACTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PLUG_IN_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PLUG_IN_ACTION_CLASS</NAME>
#define GIMP_IS_PLUG_IN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), GIMP_TYPE_PLUG_IN_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_PLUG_IN_ACTION_GET_CLASS</NAME>
#define GIMP_PLUG_IN_ACTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GIMP_TYPE_PLUG_IN_ACTION, GimpPlugInActionClass))
</MACRO>
<STRUCT>
<NAME>GimpPlugInActionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPlugInAction</NAME>
struct _GimpPlugInAction
{
  GimpAction           parent_instance;

  GimpPlugInProcedure *proc;
};
</STRUCT>
<STRUCT>
<NAME>GimpPlugInActionClass</NAME>
struct _GimpPlugInActionClass
{
  GimpActionClass parent_class;

  void (* selected) (GimpPlugInAction    *action,
                     GimpPlugInProcedure *proc);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_plug_in_action_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_action_new</NAME>
<RETURNS>GimpPlugInAction *</RETURNS>
const gchar         *name,const gchar         *label,const gchar         *tooltip,const gchar         *stock_id,GimpPlugInProcedure *proc
</FUNCTION>
<FUNCTION>
<NAME>gimp_plug_in_action_selected</NAME>
<RETURNS>void               </RETURNS>
GimpPlugInAction    *action,GimpPlugInProcedure *proc
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PROGRESS_BOX</NAME>
#define GIMP_TYPE_PROGRESS_BOX            (gimp_progress_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_BOX</NAME>
#define GIMP_PROGRESS_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PROGRESS_BOX, GimpProgressBox))
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_BOX_CLASS</NAME>
#define GIMP_PROGRESS_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PROGRESS_BOX, GimpProgressBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROGRESS_BOX</NAME>
#define GIMP_IS_PROGRESS_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PROGRESS_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROGRESS_BOX_CLASS</NAME>
#define GIMP_IS_PROGRESS_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PROGRESS_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_BOX_GET_CLASS</NAME>
#define GIMP_PROGRESS_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PROGRESS_BOX, GimpProgressBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpProgressBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProgressBox</NAME>
struct _GimpProgressBox
{
  GtkVBox     parent_instance;

  gboolean    active;
  gboolean    cancelable;

  GtkWidget  *label;
  GtkWidget  *progress;
};
</STRUCT>
<STRUCT>
<NAME>GimpProgressBoxClass</NAME>
struct _GimpProgressBoxClass
{
  GtkVBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_progress_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PROGRESS_DIALOG</NAME>
#define GIMP_TYPE_PROGRESS_DIALOG            (gimp_progress_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_DIALOG</NAME>
#define GIMP_PROGRESS_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PROGRESS_DIALOG, GimpProgressDialog))
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_DIALOG_CLASS</NAME>
#define GIMP_PROGRESS_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PROGRESS_DIALOG, GimpProgressDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROGRESS_DIALOG</NAME>
#define GIMP_IS_PROGRESS_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PROGRESS_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PROGRESS_DIALOG_CLASS</NAME>
#define GIMP_IS_PROGRESS_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PROGRESS_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_PROGRESS_DIALOG_GET_CLASS</NAME>
#define GIMP_PROGRESS_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PROGRESS_DIALOG, GimpProgressDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpProgressDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProgressDialog</NAME>
struct _GimpProgressDialog
{
  GimpDialog  parent_instance;

  GtkWidget  *box;
};
</STRUCT>
<STRUCT>
<NAME>GimpProgressDialogClass</NAME>
struct _GimpProgressDialogClass
{
  GimpDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_progress_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_progress_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_paint_mode_menu_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GObject     *config,const gchar *property_name,gboolean     with_behind_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_color_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GObject     *config,const gchar *property_name,const gchar *title,gint         width,gint         height,GimpColorAreaType  type
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GObject     *config,const gchar *property_name,gint         size
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SAMPLE_POINT_EDITOR</NAME>
#define GIMP_TYPE_SAMPLE_POINT_EDITOR            (gimp_sample_point_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SAMPLE_POINT_EDITOR</NAME>
#define GIMP_SAMPLE_POINT_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SAMPLE_POINT_EDITOR, GimpSamplePointEditor))
</MACRO>
<MACRO>
<NAME>GIMP_SAMPLE_POINT_EDITOR_CLASS</NAME>
#define GIMP_SAMPLE_POINT_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SAMPLE_POINT_EDITOR, GimpSamplePointEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SAMPLE_POINT_EDITOR</NAME>
#define GIMP_IS_SAMPLE_POINT_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SAMPLE_POINT_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SAMPLE_POINT_EDITOR_CLASS</NAME>
#define GIMP_IS_SAMPLE_POINT_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SAMPLE_POINT_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_SAMPLE_POINT_EDITOR_GET_CLASS</NAME>
#define GIMP_SAMPLE_POINT_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SAMPLE_POINT_EDITOR, GimpSamplePointEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpSamplePointEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSamplePointEditor</NAME>
struct _GimpSamplePointEditor
{
  GimpImageEditor  parent_instance;

  GtkWidget       *table;
  GtkWidget       *color_frames[4];

  gboolean         dirty[4];
  guint            dirty_idle_id;

  gboolean         sample_merged;
};
</STRUCT>
<STRUCT>
<NAME>GimpSamplePointEditorClass</NAME>
struct _GimpSamplePointEditorClass
{
  GimpImageEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_sample_point_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_sample_point_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpMenuFactory *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_sample_point_editor_set_sample_merged</NAME>
<RETURNS>void        </RETURNS>
GimpSamplePointEditor *editor,gboolean               sample_merged
</FUNCTION>
<FUNCTION>
<NAME>gimp_sample_point_editor_get_sample_merged</NAME>
<RETURNS>gboolean    </RETURNS>
GimpSamplePointEditor *editor
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_uri_list</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,GList            *uris
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_uri_list</NAME>
<RETURNS>GList         *</RETURNS>
GtkSelectionData *selection
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_color</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,const GimpRGB    *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_color</NAME>
<RETURNS>gboolean        </RETURNS>
GtkSelectionData *selection,GimpRGB          *color
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_stream</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,const guchar     *stream,gsize             stream_length
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_stream</NAME>
<RETURNS>const guchar  *</RETURNS>
GtkSelectionData *selection,gsize            *stream_length
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_image</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,GimpImage        *image
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_image</NAME>
<RETURNS>GimpImage     *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_component</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,GimpImage        *image,GimpChannelType   channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_component</NAME>
<RETURNS>GimpImage     *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp,GimpChannelType  *channel
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_item</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,GimpItem         *item
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_item</NAME>
<RETURNS>GimpItem      *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_set_object</NAME>
<RETURNS>void            </RETURNS>
GtkSelectionData *selection,GimpObject       *object
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_brush</NAME>
<RETURNS>GimpBrush     *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_pattern</NAME>
<RETURNS>GimpPattern   *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_gradient</NAME>
<RETURNS>GimpGradient  *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_palette</NAME>
<RETURNS>GimpPalette   *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_font</NAME>
<RETURNS>GimpFont      *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_buffer</NAME>
<RETURNS>GimpBuffer    *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_imagefile</NAME>
<RETURNS>GimpImagefile *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_template</NAME>
<RETURNS>GimpTemplate  *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_data_get_tool_info</NAME>
<RETURNS>GimpToolInfo  *</RETURNS>
GtkSelectionData *selection,Gimp             *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SELECTION_EDITOR</NAME>
#define GIMP_TYPE_SELECTION_EDITOR            (gimp_selection_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_EDITOR</NAME>
#define GIMP_SELECTION_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SELECTION_EDITOR, GimpSelectionEditor))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_EDITOR_CLASS</NAME>
#define GIMP_SELECTION_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SELECTION_EDITOR, GimpSelectionEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_EDITOR</NAME>
#define GIMP_IS_SELECTION_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SELECTION_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SELECTION_EDITOR_CLASS</NAME>
#define GIMP_IS_SELECTION_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SELECTION_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_SELECTION_EDITOR_GET_CLASS</NAME>
#define GIMP_SELECTION_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SELECTION_EDITOR, GimpSelectionEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpSelectionEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSelectionEditor</NAME>
struct _GimpSelectionEditor
{
  GimpImageEditor  parent_instance;

  GtkWidget       *view;

  GtkWidget       *all_button;
  GtkWidget       *none_button;
  GtkWidget       *invert_button;
  GtkWidget       *save_button;
  GtkWidget       *path_button;
  GtkWidget       *stroke_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpSelectionEditorClass</NAME>
struct _GimpSelectionEditorClass
{
  GimpImageEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_selection_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_selection_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpMenuFactory *menu_factory
</FUNCTION>
<STRUCT>
<NAME>GimpSessionInfo</NAME>
struct _GimpSessionInfo
{
  gint       x;
  gint       y;
  gint       width;
  gint       height;
  gboolean   open;   /*  only valid while restoring and saving the session  */
  gint       screen; /*  only valid while restoring and saving the session  */

  /*  dialog specific list of GimpSessionInfoAux  */
  GList     *aux_info;

  GtkWidget *widget;

  /*  only one of these is valid  */
  GimpDialogFactoryEntry *toplevel_entry;
  GimpDialogFactoryEntry *dockable_entry;

  /*  list of GimpSessionInfoBook  */
  GList     *books;
};
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfoBook</NAME>
struct _GimpSessionInfoBook
{
  gint       position;
  gint       current_page;

  GtkWidget *widget;

  /*  list of GimpSessionInfoDockable  */
  GList     *dockables;
};
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfoDockable</NAME>
struct _GimpSessionInfoDockable
{
  gchar        *identifier;
  GimpTabStyle  tab_style;
  gint          view_size;

  /*  dialog specific list of GimpSessionInfoAux  */
  GList        *aux_info;
};
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfoAux</NAME>
struct _GimpSessionInfoAux
{
  gchar *name;
  gchar *value;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_session_info_free</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_book_free</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfoBook     *book
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_dockable_free</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfoDockable *dockable
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_aux_new</NAME>
<RETURNS>GimpSessionInfoAux  *</RETURNS>
const gchar             *name,const gchar             *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_aux_free</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfoAux      *aux
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_aux_new_from_props</NAME>
<RETURNS>GList *</RETURNS>
GObject            *object,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_aux_set_props</NAME>
<RETURNS>void       </RETURNS>
GObject            *object,GList              *aux,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_save</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfo         *info,const gchar             *factory_name,GimpConfigWriter        *writer
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_deserialize</NAME>
<RETURNS>GTokenType </RETURNS>
GScanner                *scanner,gint                     old_scope
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_restore</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfo         *info,GimpDialogFactory       *factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_set_geometry</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>gimp_session_info_get_geometry</NAME>
<RETURNS>void       </RETURNS>
GimpSessionInfo         *info
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_SIZE_BOX</NAME>
#define GIMP_TYPE_SIZE_BOX            (gimp_size_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_SIZE_BOX</NAME>
#define GIMP_SIZE_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_SIZE_BOX, GimpSizeBox))
</MACRO>
<MACRO>
<NAME>GIMP_SIZE_BOX_CLASS</NAME>
#define GIMP_SIZE_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_SIZE_BOX, GimpSizeBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SIZE_BOX</NAME>
#define GIMP_IS_SIZE_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_SIZE_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_SIZE_BOX_CLASS</NAME>
#define GIMP_IS_SIZE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_SIZE_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_SIZE_BOX_GET_CLASS</NAME>
#define GIMP_SIZE_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_SIZE_BOX, GimpSizeBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpSizeBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSizeBox</NAME>
struct _GimpSizeBox
{
  GtkVBox       parent_instance;

  GtkSizeGroup *size_group;

  gint          width;
  gint          height;
  GimpUnit      unit;
  gdouble       xresolution;
  gdouble       yresolution;
  GimpUnit      resolution_unit;

  gboolean      edit_resolution;
};
</STRUCT>
<STRUCT>
<NAME>GimpSizeBoxClass</NAME>
struct _GimpSizeBoxClass
{
  GtkVBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_size_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_STRING_ACTION</NAME>
#define GIMP_TYPE_STRING_ACTION            (gimp_string_action_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_STRING_ACTION</NAME>
#define GIMP_STRING_ACTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_STRING_ACTION, GimpStringAction))
</MACRO>
<MACRO>
<NAME>GIMP_STRING_ACTION_CLASS</NAME>
#define GIMP_STRING_ACTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_STRING_ACTION, GimpStringActionClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STRING_ACTION</NAME>
#define GIMP_IS_STRING_ACTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_STRING_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STRING_ACTION_CLASS</NAME>
#define GIMP_IS_STRING_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), GIMP_TYPE_STRING_ACTION))
</MACRO>
<MACRO>
<NAME>GIMP_STRING_ACTION_GET_CLASS</NAME>
#define GIMP_STRING_ACTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GIMP_TYPE_STRING_ACTION, GimpStringActionClass))
</MACRO>
<STRUCT>
<NAME>GimpStringActionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStringAction</NAME>
struct _GimpStringAction
{
  GimpAction  parent_instance;

  gchar      *value;
};
</STRUCT>
<STRUCT>
<NAME>GimpStringActionClass</NAME>
struct _GimpStringActionClass
{
  GimpActionClass parent_class;

  void (* selected) (GimpStringAction *action,
                     const gchar      *value);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_string_action_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_string_action_new</NAME>
<RETURNS>GimpStringAction *</RETURNS>
const gchar      *name,const gchar      *label,const gchar      *tooltip,const gchar      *stock_id,const gchar      *value
</FUNCTION>
<FUNCTION>
<NAME>gimp_string_action_selected</NAME>
<RETURNS>void               </RETURNS>
GimpStringAction *action,const gchar      *value
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_STROKE_EDITOR</NAME>
#define GIMP_TYPE_STROKE_EDITOR            (gimp_stroke_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_EDITOR</NAME>
#define GIMP_STROKE_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_STROKE_EDITOR, GimpStrokeEditor))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_EDITOR_CLASS</NAME>
#define GIMP_STROKE_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_STROKE_EDITOR, GimpStrokeEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_EDITOR</NAME>
#define GIMP_IS_STROKE_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_STROKE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_STROKE_EDITOR_CLASS</NAME>
#define GIMP_IS_STROKE_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_STROKE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_STROKE_EDITOR_GET_CLASS</NAME>
#define GIMP_STROKE_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_STROKE_EDITOR, GimpStrokeEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpStrokeEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStrokeEditor</NAME>
struct _GimpStrokeEditor
{
  GtkVBox            parent_instance;

  GimpStrokeOptions *options;
  gdouble            resolution;
};
</STRUCT>
<STRUCT>
<NAME>GimpStrokeEditorClass</NAME>
struct _GimpStrokeEditorClass
{
  GtkVBoxClass       parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_stroke_editor_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_stroke_editor_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GimpStrokeOptions *options,gdouble            resolution
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEMPLATE_EDITOR</NAME>
#define GIMP_TYPE_TEMPLATE_EDITOR            (gimp_template_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_EDITOR</NAME>
#define GIMP_TEMPLATE_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEMPLATE_EDITOR, GimpTemplateEditor))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_EDITOR_CLASS</NAME>
#define GIMP_TEMPLATE_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEMPLATE_EDITOR, GimpTemplateEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPLATE_EDITOR</NAME>
#define GIMP_IS_TEMPLATE_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEMPLATE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPLATE_EDITOR_CLASS</NAME>
#define GIMP_IS_TEMPLATE_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEMPLATE_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_EDITOR_GET_CLASS</NAME>
#define GIMP_TEMPLATE_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEMPLATE_EDITOR, GimpTemplateEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpTemplateEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemplateEditor</NAME>
struct _GimpTemplateEditor
{
  GtkVBox        parent_instance;

  GimpTemplate  *template;

  GimpContainer *stock_id_container;
  GimpContext   *stock_id_context;

  GtkWidget     *aspect_button;
  gboolean       block_aspect;

  GtkWidget     *expander;
  GtkWidget     *size_se;
  GtkWidget     *memsize_label;
  GtkWidget     *pixel_label;
  GtkWidget     *more_label;
  GtkWidget     *resolution_se;
};
</STRUCT>
<STRUCT>
<NAME>GimpTemplateEditorClass</NAME>
struct _GimpTemplateEditorClass
{
  GtkVBoxClass   parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_template_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_template_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpTemplate       *template,Gimp               *gimp,gboolean            edit_template
</FUNCTION>
<FUNCTION>
<NAME>gimp_template_editor_show_advanced</NAME>
<RETURNS>void        </RETURNS>
GimpTemplateEditor *editor,gboolean            expanded
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEMPLATE_VIEW</NAME>
#define GIMP_TYPE_TEMPLATE_VIEW            (gimp_template_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_VIEW</NAME>
#define GIMP_TEMPLATE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEMPLATE_VIEW, GimpTemplateView))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_VIEW_CLASS</NAME>
#define GIMP_TEMPLATE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TEMPLATE_VIEW, GimpTemplateViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPLATE_VIEW</NAME>
#define GIMP_IS_TEMPLATE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEMPLATE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEMPLATE_VIEW_CLASS</NAME>
#define GIMP_IS_TEMPLATE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TEMPLATE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_TEMPLATE_VIEW_GET_CLASS</NAME>
#define GIMP_TEMPLATE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TEMPLATE_VIEW, GimpTemplateViewClass))
</MACRO>
<STRUCT>
<NAME>GimpTemplateViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemplateView</NAME>
struct _GimpTemplateView
{
  GimpContainerEditor  parent_instance;

  GtkWidget           *create_button;
  GtkWidget           *new_button;
  GtkWidget           *duplicate_button;
  GtkWidget           *edit_button;
  GtkWidget           *delete_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpTemplateViewClass</NAME>
struct _GimpTemplateViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_template_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_template_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpContainer   *container,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TEXT_EDITOR</NAME>
#define GIMP_TYPE_TEXT_EDITOR    (gimp_text_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TEXT_EDITOR</NAME>
#define GIMP_TEXT_EDITOR(obj)    (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TEXT_EDITOR, GimpTextEditor))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TEXT_EDITOR</NAME>
#define GIMP_IS_TEXT_EDITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TEXT_EDITOR))
</MACRO>
<STRUCT>
<NAME>GimpTextEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextEditor</NAME>
struct _GimpTextEditor
{
  GimpDialog         parent_instance;

  /*<  private  >*/
  GimpTextDirection  base_dir;
  gchar             *font_name;

  GtkWidget         *view;
  GtkWidget         *font_toggle;
  GtkWidget         *file_dialog;
  GimpUIManager     *ui_manager;
};
</STRUCT>
<STRUCT>
<NAME>GimpTextEditorClass</NAME>
struct _GimpTextEditorClass
{
  GimpDialogClass   parent_class;

  void (* text_changed) (GimpTextEditor *editor);
  void (* dir_changed)  (GimpTextEditor *editor);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_text_editor_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_new</NAME>
<RETURNS>GtkWidget         *</RETURNS>
const gchar       *title,GimpMenuFactory   *menu_factory
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_set_text</NAME>
<RETURNS>void                </RETURNS>
GimpTextEditor    *editor,const gchar       *text,gint               len
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_get_text</NAME>
<RETURNS>gchar             *</RETURNS>
GimpTextEditor    *editor
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_set_direction</NAME>
<RETURNS>void                </RETURNS>
GimpTextEditor    *editor,GimpTextDirection  base_dir
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_get_direction</NAME>
<RETURNS>GimpTextDirection   </RETURNS>
GimpTextEditor    *editor
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_set_font_name</NAME>
<RETURNS>void                </RETURNS>
GimpTextEditor    *editor,const gchar       *font_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_editor_get_font_name</NAME>
<RETURNS>const gchar       *</RETURNS>
GimpTextEditor    *editor
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_THUMB_BOX</NAME>
#define GIMP_TYPE_THUMB_BOX            (gimp_thumb_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_THUMB_BOX</NAME>
#define GIMP_THUMB_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_THUMB_BOX, GimpThumbBox))
</MACRO>
<MACRO>
<NAME>GIMP_THUMB_BOX_CLASS</NAME>
#define GIMP_THUMB_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_THUMB_BOX, GimpThumbBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_THUMB_BOX</NAME>
#define GIMP_IS_THUMB_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_THUMB_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_THUMB_BOX_CLASS</NAME>
#define GIMP_IS_THUMB_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_THUMB_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_THUMB_BOX_GET_CLASS</NAME>
#define GIMP_THUMB_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_THUMB_BOX, GimpThumbBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpThumbBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpThumbBox</NAME>
struct _GimpThumbBox
{
  GtkFrame       parent_instance;

  GimpImagefile *imagefile;
  GSList        *uris;

  GtkWidget     *preview;
  GtkWidget     *filename;
  GtkWidget     *info;
  GtkWidget     *thumb_progress;

  gboolean       progress_active;
  GtkWidget     *progress;

  guint          idle_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpThumbBoxClass</NAME>
struct _GimpThumbBoxClass
{
  GtkFrameClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_thumb_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_thumb_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp         *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_thumb_box_set_uri</NAME>
<RETURNS>void        </RETURNS>
GimpThumbBox *box,const gchar  *uri
</FUNCTION>
<FUNCTION>
<NAME>gimp_thumb_box_take_uris</NAME>
<RETURNS>void        </RETURNS>
GimpThumbBox *box,GSList       *uris
</FUNCTION>
<FUNCTION>
<NAME>gimp_toolbox_color_area_create</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolbox *toolbox,gint         width,gint         height
</FUNCTION>
<FUNCTION>
<NAME>gimp_toolbox_dnd_init</NAME>
<RETURNS>void   </RETURNS>
GimpToolbox *toolbox
</FUNCTION>
<FUNCTION>
<NAME>gimp_toolbox_image_area_create</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolbox *toolbox,gint         width,gint         height
</FUNCTION>
<FUNCTION>
<NAME>gimp_toolbox_indicator_area_create</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolbox *toolbox
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOLBOX</NAME>
#define GIMP_TYPE_TOOLBOX            (gimp_toolbox_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOLBOX</NAME>
#define GIMP_TOOLBOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOLBOX, GimpToolbox))
</MACRO>
<MACRO>
<NAME>GIMP_TOOLBOX_CLASS</NAME>
#define GIMP_TOOLBOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOLBOX, GimpToolboxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOLBOX</NAME>
#define GIMP_IS_TOOLBOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOLBOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOLBOX_CLASS</NAME>
#define GIMP_IS_TOOLBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOLBOX))
</MACRO>
<MACRO>
<NAME>GIMP_TOOLBOX_GET_CLASS</NAME>
#define GIMP_TOOLBOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOLBOX, GimpToolboxClass))
</MACRO>
<STRUCT>
<NAME>GimpToolboxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolbox</NAME>
struct _GimpToolbox
{
  GimpImageDock  parent_instance;

  GtkWidget     *menu_bar;
  GtkWidget     *tool_wbox;
  GtkWidget     *area_wbox;
  GtkWidget     *color_area;
  GtkWidget     *foo_area;
  GtkWidget     *image_area;

  gint           tool_rows;
  gint           tool_columns;
  gint           area_rows;
  gint           area_columns;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolboxClass</NAME>
struct _GimpToolboxClass
{
  GimpImageDockClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_toolbox_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_toolbox_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDialogFactory *factory,Gimp              *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL_DIALOG</NAME>
#define GIMP_TYPE_TOOL_DIALOG            (gimp_tool_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_DIALOG</NAME>
#define GIMP_TOOL_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_DIALOG, GimpToolDialog))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_DIALOG_CLASS</NAME>
#define GIMP_TOOL_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_DIALOG, GimpToolDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_DIALOG</NAME>
#define GIMP_IS_TOOL_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_DIALOG_CLASS</NAME>
#define GIMP_IS_TOOL_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_DIALOG_GET_CLASS</NAME>
#define GIMP_TOOL_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_DIALOG, GimpToolDialogClass))
</MACRO>
<TYPEDEF>
<NAME>GimpToolDialogClass</NAME>
typedef struct _GimpViewableDialogClass GimpToolDialogClass;
</TYPEDEF>
<STRUCT>
<NAME>GimpToolDialog</NAME>
struct _GimpToolDialog
{
  GimpViewableDialog  parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpToolInfo *tool_info,GtkWidget    *parent,const gchar  *desc,...
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL_OPTIONS_EDITOR</NAME>
#define GIMP_TYPE_TOOL_OPTIONS_EDITOR            (gimp_tool_options_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_OPTIONS_EDITOR</NAME>
#define GIMP_TOOL_OPTIONS_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_OPTIONS_EDITOR, GimpToolOptionsEditor))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_OPTIONS_EDITOR_CLASS</NAME>
#define GIMP_TOOL_OPTIONS_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_OPTIONS_EDITOR, GimpToolOptionsEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_OPTIONS_EDITOR</NAME>
#define GIMP_IS_TOOL_OPTIONS_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_OPTIONS_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_OPTIONS_EDITOR_CLASS</NAME>
#define GIMP_IS_TOOL_OPTIONS_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_OPTIONS_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_OPTIONS_EDITOR_GET_CLASS</NAME>
#define GIMP_TOOL_OPTIONS_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_OPTIONS_EDITOR, GimpToolOptionsEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpToolOptionsEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolOptionsEditor</NAME>
struct _GimpToolOptionsEditor
{
  GimpEditor       parent_instance;

  Gimp            *gimp;

  GtkWidget       *scrolled_window;
  GtkWidget       *options_vbox;

  GtkWidget       *save_button;
  GtkWidget       *restore_button;
  GtkWidget       *delete_button;
  GtkWidget       *reset_button;

  GimpToolOptions *visible_tool_options;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolOptionsEditorClass</NAME>
struct _GimpToolOptionsEditorClass
{
  GimpEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_options_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_options_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
Gimp            *gimp,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_TOOL_VIEW</NAME>
#define GIMP_TYPE_TOOL_VIEW            (gimp_tool_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_VIEW</NAME>
#define GIMP_TOOL_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_TOOL_VIEW, GimpToolView))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_VIEW_CLASS</NAME>
#define GIMP_TOOL_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_TOOL_VIEW, GimpToolViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_VIEW</NAME>
#define GIMP_IS_TOOL_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_TOOL_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_TOOL_VIEW_CLASS</NAME>
#define GIMP_IS_TOOL_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_TOOL_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_TOOL_VIEW_GET_CLASS</NAME>
#define GIMP_TOOL_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_TOOL_VIEW, GimpToolViewClass))
</MACRO>
<STRUCT>
<NAME>GimpToolViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolView</NAME>
struct _GimpToolView
{
  GimpContainerEditor  parent_instance;

  GQuark               visible_handler_id;

  GtkWidget           *raise_button;
  GtkWidget           *lower_button;
  GtkWidget           *reset_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpToolViewClass</NAME>
struct _GimpToolViewClass
{
  GimpContainerEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_tool_view_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_tool_view_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewType     view_type,GimpContainer   *container,GimpContext     *context,gint             view_size,gint             view_border_width,GimpMenuFactory *menu_factory
</FUNCTION>
<STRUCT>
<NAME>GimpUIManagerUIEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUIManagerUIEntry</NAME>
struct _GimpUIManagerUIEntry
{
  gchar                  *ui_path;
  gchar                  *basename;
  GimpUIManagerSetupFunc  setup_func;
  guint                   merge_id;
  GtkWidget              *widget;
};
</STRUCT>
<MACRO>
<NAME>GIMP_TYPE_UI_MANAGER</NAME>
#define GIMP_TYPE_UI_MANAGER              (gimp_ui_manager_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_UI_MANAGER</NAME>
#define GIMP_UI_MANAGER(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_UI_MANAGER, GimpUIManager))
</MACRO>
<MACRO>
<NAME>GIMP_UI_MANAGER_CLASS</NAME>
#define GIMP_UI_MANAGER_CLASS(vtable)     (G_TYPE_CHECK_CLASS_CAST ((vtable), GIMP_TYPE_UI_MANAGER, GimpUIManagerClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UI_MANAGER</NAME>
#define GIMP_IS_UI_MANAGER(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_UI_MANAGER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UI_MANAGER_CLASS</NAME>
#define GIMP_IS_UI_MANAGER_CLASS(vtable)  (G_TYPE_CHECK_CLASS_TYPE ((vtable), GIMP_TYPE_UI_MANAGER))
</MACRO>
<MACRO>
<NAME>GIMP_UI_MANAGER_GET_CLASS</NAME>
#define GIMP_UI_MANAGER_GET_CLASS(inst)   (G_TYPE_INSTANCE_GET_CLASS ((inst), GIMP_TYPE_UI_MANAGER, GimpUIManagerClass))
</MACRO>
<STRUCT>
<NAME>GimpUIManagerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUIManager</NAME>
struct _GimpUIManager
{
  GtkUIManager  parent_instance;

  gchar        *name;
  Gimp         *gimp;
  GList        *registered_uis;
};
</STRUCT>
<STRUCT>
<NAME>GimpUIManagerClass</NAME>
struct _GimpUIManagerClass
{
  GtkUIManagerClass  parent_class;

  GHashTable        *managers;

  void (* update)       (GimpUIManager *manager,
                         gpointer       update_data);
  void (* show_tooltip) (GimpUIManager *manager,
                         const gchar   *tooltip);
  void (* hide_tooltip) (GimpUIManager *manager);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_ui_manager_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_manager_new</NAME>
<RETURNS>GimpUIManager *</RETURNS>
Gimp                   *gimp,const gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_managers_from_name</NAME>
<RETURNS>GList         *</RETURNS>
const gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_manager_update</NAME>
<RETURNS>void            </RETURNS>
GimpUIManager          *manager,gpointer                update_data
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_manager_get_action_group</NAME>
<RETURNS>GimpActionGroup *</RETURNS>
GimpUIManager   *manager,const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_manager_find_action</NAME>
<RETURNS>GtkAction     *</RETURNS>
GimpUIManager          *manager,const gchar            *group_name,const gchar            *action_name
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_manager_ui_register</NAME>
<RETURNS>void            </RETURNS>
GimpUIManager          *manager,const gchar            *ui_path,const gchar            *basename,GimpUIManagerSetupFunc  setup_func
</FUNCTION>
<FUNCTION>
<NAME>gimp_ui_manager_ui_popup</NAME>
<RETURNS>void            </RETURNS>
GimpUIManager          *manager,const gchar            *ui_path,GtkWidget              *parent,GimpMenuPositionFunc    position_func,gpointer                position_data,GtkDestroyNotify        popdown_func,gpointer                popdown_data
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_UNDO_EDITOR</NAME>
#define GIMP_TYPE_UNDO_EDITOR            (gimp_undo_editor_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_EDITOR</NAME>
#define GIMP_UNDO_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_UNDO_EDITOR, GimpUndoEditor))
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_EDITOR_CLASS</NAME>
#define GIMP_UNDO_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_UNDO_EDITOR, GimpUndoEditorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNDO_EDITOR</NAME>
#define GIMP_IS_UNDO_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_UNDO_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNDO_EDITOR_CLASS</NAME>
#define GIMP_IS_UNDO_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_UNDO_EDITOR))
</MACRO>
<MACRO>
<NAME>GIMP_UNDO_EDITOR_GET_CLASS</NAME>
#define GIMP_UNDO_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_UNDO_EDITOR, GimpUndoEditorClass))
</MACRO>
<STRUCT>
<NAME>GimpUndoEditorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndoEditor</NAME>
struct _GimpUndoEditor
{
  GimpImageEditor  parent_instance;

  GimpContainer   *container;
  GtkWidget       *view;
  GimpViewSize     view_size;

  GimpUndo        *base_item;

  GtkWidget       *undo_button;
  GtkWidget       *redo_button;
  GtkWidget       *clear_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpUndoEditorClass</NAME>
struct _GimpUndoEditorClass
{
  GimpImageEditorClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_undo_editor_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_undo_editor_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpCoreConfig  *config,GimpMenuFactory *menu_factory
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_UNIT_COMBO_BOX</NAME>
#define GIMP_TYPE_UNIT_COMBO_BOX            (gimp_unit_combo_box_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_UNIT_COMBO_BOX</NAME>
#define GIMP_UNIT_COMBO_BOX(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_UNIT_COMBO_BOX, GimpUnitComboBox))
</MACRO>
<MACRO>
<NAME>GIMP_UNIT_COMBO_BOX_CLASS</NAME>
#define GIMP_UNIT_COMBO_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_UNIT_COMBO_BOX, GimpUnitComboBoxClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNIT_COMBO_BOX</NAME>
#define GIMP_IS_UNIT_COMBO_BOX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_UNIT_COMBO_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNIT_COMBO_BOX_CLASS</NAME>
#define GIMP_IS_UNIT_COMBO_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_UNIT_COMBO_BOX))
</MACRO>
<MACRO>
<NAME>GIMP_UNIT_COMBO_BOX_GET_CLASS</NAME>
#define GIMP_UNIT_COMBO_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_UNIT_COMBO_BOX, GimpUnitComboBoxClass))
</MACRO>
<STRUCT>
<NAME>GimpUnitComboBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUnitComboBoxClass</NAME>
struct _GimpUnitComboBoxClass
{
  GtkComboBoxClass  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpUnitComboBox</NAME>
struct _GimpUnitComboBox
{
  GtkComboBox       parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_unit_combo_box_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_combo_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_combo_box_new_with_model</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpUnitStore    *model
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_combo_box_get_active</NAME>
<RETURNS>GimpUnit    </RETURNS>
GimpUnitComboBox *combo
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_combo_box_set_active</NAME>
<RETURNS>void        </RETURNS>
GimpUnitComboBox *combo,GimpUnit          unit
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_UNIT_STORE</NAME>
#define GIMP_TYPE_UNIT_STORE            (gimp_unit_store_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_UNIT_STORE</NAME>
#define GIMP_UNIT_STORE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_UNIT_STORE, GimpUnitStore))
</MACRO>
<MACRO>
<NAME>GIMP_UNIT_STORE_CLASS</NAME>
#define GIMP_UNIT_STORE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_UNIT_STORE, GimpUnitStoreClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNIT_STORE</NAME>
#define GIMP_IS_UNIT_STORE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_UNIT_STORE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_UNIT_STORE_CLASS</NAME>
#define GIMP_IS_UNIT_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_UNIT_STORE))
</MACRO>
<MACRO>
<NAME>GIMP_UNIT_STORE_GET_CLASS</NAME>
#define GIMP_UNIT_STORE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_UNIT_STORE, GimpUnitStoreClass))
</MACRO>
<STRUCT>
<NAME>GimpUnitStoreClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUnitStoreClass</NAME>
struct _GimpUnitStoreClass
{
  GObjectClass  parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GimpUnitStore</NAME>
struct _GimpUnitStore
{
  GObject       parent_instance;

  gint          num_values;
  gdouble      *values;
  gdouble      *resolutions;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_unit_store_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_new</NAME>
<RETURNS>GimpUnitStore *</RETURNS>
gint           num_values
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_set_pixel_value</NAME>
<RETURNS>void            </RETURNS>
GimpUnitStore *store,gint           index,gdouble        value
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_set_pixel_values</NAME>
<RETURNS>void            </RETURNS>
GimpUnitStore *store,gdouble        first_value,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_set_resolution</NAME>
<RETURNS>void            </RETURNS>
GimpUnitStore *store,gint           index,gdouble        resolution
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_set_resolutions</NAME>
<RETURNS>void            </RETURNS>
GimpUnitStore *store,gdouble        first_resolution,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_get_value</NAME>
<RETURNS>gdouble         </RETURNS>
GimpUnitStore *store,GimpUnit       unit,gint           index
</FUNCTION>
<FUNCTION>
<NAME>gimp_unit_store_get_values</NAME>
<RETURNS>void            </RETURNS>
GimpUnitStore *store,GimpUnit       unit,gdouble       *first_value,...
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VECTORS_TREE_VIEW</NAME>
#define GIMP_TYPE_VECTORS_TREE_VIEW            (gimp_vectors_tree_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VECTORS_TREE_VIEW</NAME>
#define GIMP_VECTORS_TREE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VECTORS_TREE_VIEW, GimpVectorsTreeView))
</MACRO>
<MACRO>
<NAME>GIMP_VECTORS_TREE_VIEW_CLASS</NAME>
#define GIMP_VECTORS_TREE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VECTORS_TREE_VIEW, GimpVectorsTreeViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTORS_TREE_VIEW</NAME>
#define GIMP_IS_VECTORS_TREE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VECTORS_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VECTORS_TREE_VIEW_CLASS</NAME>
#define GIMP_IS_VECTORS_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VECTORS_TREE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_VECTORS_TREE_VIEW_GET_CLASS</NAME>
#define GIMP_VECTORS_TREE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VECTORS_TREE_VIEW, GimpVectorsTreeViewClass))
</MACRO>
<STRUCT>
<NAME>GimpVectorsTreeViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectorsTreeView</NAME>
struct _GimpVectorsTreeView
{
  GimpItemTreeView  parent_instance;

  GtkWidget        *toselection_button;
  GtkWidget        *tovectors_button;
  GtkWidget        *stroke_button;
};
</STRUCT>
<STRUCT>
<NAME>GimpVectorsTreeViewClass</NAME>
struct _GimpVectorsTreeViewClass
{
  GimpItemTreeViewClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_vectors_tree_view_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_popup_show</NAME>
<RETURNS>gboolean   </RETURNS>
GtkWidget      *widget,GdkEventButton *bevent,GimpViewable   *viewable,gint            view_width,gint            view_height,gboolean        dot_for_dot
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW</NAME>
#define GIMP_TYPE_VIEW            (gimp_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW</NAME>
#define GIMP_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW, GimpView))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_CLASS</NAME>
#define GIMP_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW, GimpViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW</NAME>
#define GIMP_IS_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_CLASS</NAME>
#define GIMP_IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_GET_CLASS</NAME>
#define GIMP_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW, GimpViewClass))
</MACRO>
<STRUCT>
<NAME>GimpViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpView</NAME>
struct _GimpView
{
  GtkWidget         parent_instance;

  GdkWindow        *event_window;

  GimpViewable     *viewable;
  GimpViewRenderer *renderer;

  gboolean          clickable;
  gboolean          eat_button_events;
  gboolean          show_popup;
  gboolean          expand;

  /*< private >*/
  gboolean          in_button;
  gboolean          has_grab;
  GdkModifierType   press_state;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewClass</NAME>
struct _GimpViewClass
{
  GtkWidgetClass  parent_class;

  /*  signals  */
  void        (* set_viewable)   (GimpView        *view,
                                  GimpViewable    *old_viewable,
                                  GimpViewable    *new_viewable);
  void        (* clicked)        (GimpView        *view,
                                  GdkModifierType  modifier_state);
  void        (* double_clicked) (GimpView        *view);
  void        (* context)        (GimpView        *view);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_new</NAME>
<RETURNS>GtkWidget    *</RETURNS>
GimpViewable  *viewable,gint           size,gint           border_width,gboolean       is_popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_new_full</NAME>
<RETURNS>GtkWidget    *</RETURNS>
GimpViewable  *viewable,gint           width,gint           height,gint           border_width,gboolean       is_popup,gboolean       clickable,gboolean       show_popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_new_by_types</NAME>
<RETURNS>GtkWidget    *</RETURNS>
GType          view_type,GType          viewable_type,gint           size,gint           border_width,gboolean       is_popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_new_full_by_types</NAME>
<RETURNS>GtkWidget    *</RETURNS>
GType          view_type,GType          viewable_type,gint           width,gint           height,gint           border_width,gboolean       is_popup,gboolean       clickable,gboolean       show_popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_get_viewable</NAME>
<RETURNS>GimpViewable *</RETURNS>
GimpView      *view
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_set_viewable</NAME>
<RETURNS>void           </RETURNS>
GimpView      *view,GimpViewable  *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_set_expand</NAME>
<RETURNS>void           </RETURNS>
GimpView      *view,gboolean       expand
</FUNCTION>
<FUNCTION>
<NAME>gimp_brush_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_brush_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing,const gchar   *view_type_prop,const gchar   *view_size_prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_pattern_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_pattern_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing,const gchar   *view_type_prop,const gchar   *view_size_prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_gradient_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           scacing,const gchar   *reverse_prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_gradient_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           scacing,const gchar   *view_type_prop,const gchar   *view_size_prop,const gchar   *reverse_prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_palette_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing,const gchar   *view_type_prop,const gchar   *view_size_prop
</FUNCTION>
<FUNCTION>
<NAME>gimp_font_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing
</FUNCTION>
<FUNCTION>
<NAME>gimp_prop_font_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer *container,GimpContext   *context,gint           spacing,const gchar   *view_type_prop,const gchar   *view_size_prop
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEWABLE_BUTTON</NAME>
#define GIMP_TYPE_VIEWABLE_BUTTON            (gimp_viewable_button_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_BUTTON</NAME>
#define GIMP_VIEWABLE_BUTTON(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEWABLE_BUTTON, GimpViewableButton))
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_BUTTON_CLASS</NAME>
#define GIMP_VIEWABLE_BUTTON_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEWABLE_BUTTON, GimpViewableButtonClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEWABLE_BUTTON</NAME>
#define GIMP_IS_VIEWABLE_BUTTON(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VIEWABLE_BUTTON))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEWABLE_BUTTON_CLASS</NAME>
#define GIMP_IS_VIEWABLE_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEWABLE_BUTTON))
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_BUTTON_GET_CLASS</NAME>
#define GIMP_VIEWABLE_BUTTON_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEWABLE_BUTTON, GimpViewableButtonClass))
</MACRO>
<STRUCT>
<NAME>GimpViewableButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewableButton</NAME>
struct _GimpViewableButton
{
  GimpButton         parent_instance;

  GimpContainer     *container;
  GimpContext       *context;

  GimpViewType       popup_view_type;
  gint               popup_view_size;

  gint               button_view_size;
  gint               view_border_width;

  GimpDialogFactory *dialog_factory;
  gchar             *dialog_identifier;
  gchar             *dialog_stock_id;
  gchar             *dialog_tooltip;

  GtkWidget         *view;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewableButtonClass</NAME>
struct _GimpViewableButtonClass
{
  GimpButtonClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_viewable_button_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpContainer      *container,GimpContext        *context,GimpViewType        view_type,gint                button_view_size,gint                view_size,gint                view_border_width,GimpDialogFactory  *dialog_factory,const gchar        *dialog_identifier,const gchar        *dialog_stock_id,const gchar        *dialog_tooltip
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_button_get_view_type</NAME>
<RETURNS>GimpViewType </RETURNS>
GimpViewableButton *button
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_button_set_view_type</NAME>
<RETURNS>void         </RETURNS>
GimpViewableButton *button,GimpViewType        view_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_button_get_view_size</NAME>
<RETURNS>gint         </RETURNS>
GimpViewableButton *button
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_button_set_view_size</NAME>
<RETURNS>void         </RETURNS>
GimpViewableButton *button,gint                view_size
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEWABLE_DIALOG</NAME>
#define GIMP_TYPE_VIEWABLE_DIALOG            (gimp_viewable_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_DIALOG</NAME>
#define GIMP_VIEWABLE_DIALOG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEWABLE_DIALOG, GimpViewableDialog))
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_DIALOG_CLASS</NAME>
#define GIMP_VIEWABLE_DIALOG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEWABLE_DIALOG, GimpViewableDialogClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEWABLE_DIALOG</NAME>
#define GIMP_IS_VIEWABLE_DIALOG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_VIEWABLE_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEWABLE_DIALOG_CLASS</NAME>
#define GIMP_IS_VIEWABLE_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEWABLE_DIALOG))
</MACRO>
<MACRO>
<NAME>GIMP_VIEWABLE_DIALOG_GET_CLASS</NAME>
#define GIMP_VIEWABLE_DIALOG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEWABLE_DIALOG, GimpViewableDialogClass))
</MACRO>
<STRUCT>
<NAME>GimpViewableDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewableDialog</NAME>
struct _GimpViewableDialog
{
  GimpDialog  parent_instance;

  GtkWidget  *icon;
  GtkWidget  *view;
  GtkWidget  *desc_label;
  GtkWidget  *viewable_label;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewableDialogClass</NAME>
struct _GimpViewableDialogClass
{
  GimpDialogClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_viewable_dialog_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpViewable       *viewable,const gchar        *title,const gchar        *role,const gchar        *stock_id,const gchar        *desc,GtkWidget          *parent,GimpHelpFunc        help_func,const gchar        *help_id,...
</FUNCTION>
<FUNCTION>
<NAME>gimp_viewable_dialog_set_viewable</NAME>
<RETURNS>void    </RETURNS>
GimpViewableDialog *dialog,GimpViewable       *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_get_frame_pixbuf</NAME>
<RETURNS>GdkPixbuf *</RETURNS>
GimpViewRenderer *renderer,GtkWidget        *widget,gint              width,gint              height
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_get_frame_size</NAME>
<RETURNS>void        </RETURNS>
gint             *width,gint             *height
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_type_from_viewable_type</NAME>
<RETURNS>GType   </RETURNS>
GType viewable_type
</FUNCTION>
<MACRO>
<NAME>GIMP_VIEW_MAX_BORDER_WIDTH</NAME>
#define GIMP_VIEW_MAX_BORDER_WIDTH 16
</MACRO>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER</NAME>
#define GIMP_TYPE_VIEW_RENDERER            (gimp_view_renderer_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER</NAME>
#define GIMP_VIEW_RENDERER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER, GimpViewRenderer))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_CLASS</NAME>
#define GIMP_VIEW_RENDERER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER, GimpViewRendererClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER</NAME>
#define GIMP_IS_VIEW_RENDERER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER, GimpViewRendererClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRenderer</NAME>
struct _GimpViewRenderer
{
  GObject             parent_instance;

  GType               viewable_type;
  GimpViewable       *viewable;

  gint                width;
  gint                height;
  gint                border_width;
  gboolean            dot_for_dot;
  gboolean            is_popup;

  GimpViewBorderType  border_type;
  GimpRGB             border_color;
  GdkGC              *gc;

  /*< private >*/
  guchar             *buffer;
  gint                rowstride;
  gint                bytes;
  GdkPixbuf          *pixbuf;
  gchar              *bg_stock_id;

  gint                size;
  gboolean            needs_render;
  guint               idle_id;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererClass</NAME>
struct _GimpViewRendererClass
{
  GObjectClass   parent_class;

  GdkPixbuf     *frame;
  gint           frame_left;
  gint           frame_right;
  gint           frame_bottom;
  gint           frame_top;

  /*  signals  */
  void (* update) (GimpViewRenderer   *renderer);

  /*  virtual functions  */
  void (* draw)   (GimpViewRenderer   *renderer,
                   GdkWindow          *window,
                   GtkWidget          *widget,
                   const GdkRectangle *draw_area,
                   const GdkRectangle *expose_area);
  void (* render) (GimpViewRenderer   *renderer,
                   GtkWidget          *widget);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_new</NAME>
<RETURNS>GimpViewRenderer *</RETURNS>
GType    viewable_type,gint     size,gint     border_width,gboolean is_popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_new_full</NAME>
<RETURNS>GimpViewRenderer *</RETURNS>
GType    viewable_type,gint     width,gint     height,gint     border_width,gboolean is_popup
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_viewable</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,GimpViewable       *viewable
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_size</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,gint                size,gint                border_width
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_size_full</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,gint                width,gint                height,gint                border_width
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_dot_for_dot</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,gboolean            dot_for_dot
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_border_type</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,GimpViewBorderType  border_type
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_border_color</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,const GimpRGB      *border_color
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_set_background</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,const gchar        *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_unrealize</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_invalidate</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_update</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_update_idle</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_remove_idle</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_draw</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer   *renderer,GdkWindow          *window,GtkWidget          *widget,const GdkRectangle *draw_area,const GdkRectangle *expose_area
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_default_render_buffer</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer *renderer,GtkWidget        *widget,TempBuf          *temp_buf
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_default_render_stock</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer *renderer,GtkWidget        *widget,const gchar      *stock_id
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_render_buffer</NAME>
<RETURNS>void   </RETURNS>
GimpViewRenderer *renderer,TempBuf          *temp_buf,gint              channel,GimpViewBG        inside_bg,GimpViewBG        outside_bg
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_render_pixbuf</NAME>
<RETURNS>void    </RETURNS>
GimpViewRenderer *renderer,GdkPixbuf        *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_render_to_buffer</NAME>
<RETURNS>void   </RETURNS>
TempBuf    *temp_buf,gint        channel,GimpViewBG  inside_bg,GimpViewBG  outside_bg,guchar     *dest_buffer,gint        dest_width,gint        dest_height,gint        dest_rowstride,gint        dest_bytes
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_BRUSH</NAME>
#define GIMP_TYPE_VIEW_RENDERER_BRUSH            (gimp_view_renderer_brush_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_BRUSH</NAME>
#define GIMP_VIEW_RENDERER_BRUSH(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_BRUSH, GimpViewRendererBrush))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_BRUSH_CLASS</NAME>
#define GIMP_VIEW_RENDERER_BRUSH_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_BRUSH, GimpViewRendererBrushClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_BRUSH</NAME>
#define GIMP_IS_VIEW_RENDERER_BRUSH(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_BRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_BRUSH_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_BRUSH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_BRUSH))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_BRUSH_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_BRUSH_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_BRUSH, GimpViewRendererBrushClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererBrushClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererBrush</NAME>
struct _GimpViewRendererBrush
{
  GimpViewRenderer parent_instance;

  guint            pipe_timeout_id;
  gint             pipe_animation_index;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererBrushClass</NAME>
struct _GimpViewRendererBrushClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_brush_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_BUFFER</NAME>
#define GIMP_TYPE_VIEW_RENDERER_BUFFER            (gimp_view_renderer_buffer_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_BUFFER</NAME>
#define GIMP_VIEW_RENDERER_BUFFER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_BUFFER, GimpViewRendererBuffer))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_BUFFER_CLASS</NAME>
#define GIMP_VIEW_RENDERER_BUFFER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_BUFFER, GimpViewRendererBufferClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_BUFFER</NAME>
#define GIMP_IS_VIEW_RENDERER_BUFFER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_BUFFER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_BUFFER_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_BUFFER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_BUFFER))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_BUFFER_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_BUFFER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_BUFFER, GimpViewRendererBufferClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererBufferClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererBuffer</NAME>
struct _GimpViewRendererBuffer
{
  GimpViewRenderer  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererBufferClass</NAME>
struct _GimpViewRendererBufferClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_buffer_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_DRAWABLE</NAME>
#define GIMP_TYPE_VIEW_RENDERER_DRAWABLE            (gimp_view_renderer_drawable_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_DRAWABLE</NAME>
#define GIMP_VIEW_RENDERER_DRAWABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_DRAWABLE, GimpViewRendererDrawable))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_DRAWABLE_CLASS</NAME>
#define GIMP_VIEW_RENDERER_DRAWABLE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_DRAWABLE, GimpViewRendererDrawableClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_DRAWABLE</NAME>
#define GIMP_IS_VIEW_RENDERER_DRAWABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_DRAWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_DRAWABLE_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_DRAWABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_DRAWABLE))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_DRAWABLE_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_DRAWABLE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_DRAWABLE, GimpViewRendererDrawableClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererDrawableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererDrawable</NAME>
struct _GimpViewRendererDrawable
{
  GimpViewRenderer  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererDrawableClass</NAME>
struct _GimpViewRendererDrawableClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_drawable_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_GRADIENT</NAME>
#define GIMP_TYPE_VIEW_RENDERER_GRADIENT            (gimp_view_renderer_gradient_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_GRADIENT</NAME>
#define GIMP_VIEW_RENDERER_GRADIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_GRADIENT, GimpViewRendererGradient))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_GRADIENT_CLASS</NAME>
#define GIMP_VIEW_RENDERER_GRADIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_GRADIENT, GimpViewRendererGradientClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_GRADIENT</NAME>
#define GIMP_IS_VIEW_RENDERER_GRADIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_GRADIENT))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_GRADIENT_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_GRADIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_GRADIENT))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_GRADIENT_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_GRADIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_GRADIENT, GimpViewRendererGradientClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererGradientClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererGradient</NAME>
struct _GimpViewRendererGradient
{
  GimpViewRenderer  parent_instance;

  guchar           *even;
  guchar           *odd;
  gint              width;
  gdouble           left;
  gdouble           right;

  gboolean          reverse;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererGradientClass</NAME>
struct _GimpViewRendererGradientClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_gradient_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_gradient_set_offsets</NAME>
<RETURNS>void    </RETURNS>
GimpViewRendererGradient *renderer,gdouble                   left,gdouble                   right,gboolean                  instant_update
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_gradient_set_reverse</NAME>
<RETURNS>void    </RETURNS>
GimpViewRendererGradient *renderer,gboolean                  reverse
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_IMAGE</NAME>
#define GIMP_TYPE_VIEW_RENDERER_IMAGE            (gimp_view_renderer_image_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_IMAGE</NAME>
#define GIMP_VIEW_RENDERER_IMAGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_IMAGE, GimpViewRendererImage))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_IMAGE_CLASS</NAME>
#define GIMP_VIEW_RENDERER_IMAGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_IMAGE, GimpViewRendererImageClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_IMAGE</NAME>
#define GIMP_IS_VIEW_RENDERER_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_IMAGE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_IMAGE_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_IMAGE))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_IMAGE_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_IMAGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_IMAGE, GimpViewRendererImageClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererImageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererImage</NAME>
struct _GimpViewRendererImage
{
  GimpViewRenderer parent_instance;

  GimpChannelType     channel;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererImageClass</NAME>
struct _GimpViewRendererImageClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_image_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_IMAGEFILE</NAME>
#define GIMP_TYPE_VIEW_RENDERER_IMAGEFILE            (gimp_view_renderer_imagefile_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_IMAGEFILE</NAME>
#define GIMP_VIEW_RENDERER_IMAGEFILE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_IMAGEFILE, GimpViewRendererImagefile))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_IMAGEFILE_CLASS</NAME>
#define GIMP_VIEW_RENDERER_IMAGEFILE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_IMAGEFILE, GimpViewRendererImagefileClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_IMAGEFILE</NAME>
#define GIMP_IS_VIEW_RENDERER_IMAGEFILE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_IMAGEFILE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_IMAGEFILE_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_IMAGEFILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_IMAGEFILE))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_IMAGEFILE_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_IMAGEFILE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_IMAGEFILE, GimpViewRendererImagefileClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererImagefileClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererImagefile</NAME>
struct _GimpViewRendererImagefile
{
  GimpViewRenderer parent_instance;

#ifdef ENABLE_FILE_SYSTEM_ICONS
  gpointer            file_system;
#endif
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererImagefileClass</NAME>
struct _GimpViewRendererImagefileClass
{
  GimpViewRendererClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_imagefile_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_LAYER</NAME>
#define GIMP_TYPE_VIEW_RENDERER_LAYER            (gimp_view_renderer_layer_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_LAYER</NAME>
#define GIMP_VIEW_RENDERER_LAYER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_LAYER, GimpViewRendererLayer))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_LAYER_CLASS</NAME>
#define GIMP_VIEW_RENDERER_LAYER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_LAYER, GimpViewRendererLayerClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_LAYER</NAME>
#define GIMP_IS_VIEW_RENDERER_LAYER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_LAYER))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_LAYER_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_LAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_LAYER))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_LAYER_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_LAYER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_LAYER, GimpViewRendererLayerClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererLayer</NAME>
struct _GimpViewRendererLayer
{
  GimpViewRendererDrawable  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererLayerClass</NAME>
struct _GimpViewRendererLayerClass
{
  GimpViewRendererDrawableClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_layer_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_VECTORS</NAME>
#define GIMP_TYPE_VIEW_RENDERER_VECTORS            (gimp_view_renderer_vectors_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_VECTORS</NAME>
#define GIMP_VIEW_RENDERER_VECTORS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_VECTORS, GimpViewRendererVectors))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_VECTORS_CLASS</NAME>
#define GIMP_VIEW_RENDERER_VECTORS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_VECTORS, GimpViewRendererVectorsClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_VECTORS</NAME>
#define GIMP_IS_VIEW_RENDERER_VECTORS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_VECTORS))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_VECTORS_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_VECTORS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_VECTORS))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_VECTORS_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_VECTORS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_VECTORS, GimpViewRendererVectorsClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererVectorsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererVectors</NAME>
struct _GimpViewRendererVectors
{
  GimpViewRenderer  parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererVectorsClass</NAME>
struct _GimpViewRendererVectorsClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_vectors_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_paint_mode_menu_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gboolean with_behind_mode
</FUNCTION>
<FUNCTION>
<NAME>gimp_menu_position</NAME>
<RETURNS>void              </RETURNS>
GtkMenu         *menu,gint            *x,gint            *y
</FUNCTION>
<FUNCTION>
<NAME>gimp_button_menu_position</NAME>
<RETURNS>void              </RETURNS>
GtkWidget       *button,GtkMenu         *menu,GtkPositionType  position,gint            *x,gint            *y
</FUNCTION>
<FUNCTION>
<NAME>gimp_table_attach_stock</NAME>
<RETURNS>void              </RETURNS>
GtkTable        *table,gint             row,const gchar     *stock_id,GtkWidget       *widget,gint             colspan,gboolean         left_align
</FUNCTION>
<FUNCTION>
<NAME>gimp_enum_radio_frame_add</NAME>
<RETURNS>void              </RETURNS>
GtkFrame        *frame,GtkWidget       *widget,gint             enum_value
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_icon_size</NAME>
<RETURNS>GtkIconSize       </RETURNS>
GtkWidget       *widget,const gchar     *stock_id,GtkIconSize      max_size,gint             width,gint             height
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_mod_name_shift</NAME>
<RETURNS>const gchar     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_mod_name_control</NAME>
<RETURNS>const gchar     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_mod_name_alt</NAME>
<RETURNS>const gchar     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_mod_separator</NAME>
<RETURNS>const gchar     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_mod_string</NAME>
<RETURNS>const gchar     *</RETURNS>
GdkModifierType  modifiers
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_accel_string</NAME>
<RETURNS>gchar           *</RETURNS>
guint            key,GdkModifierType  modifiers
</FUNCTION>
<FUNCTION>
<NAME>gimp_get_screen_resolution</NAME>
<RETURNS>void              </RETURNS>
GdkScreen       *screen,gdouble         *xres,gdouble         *yres
</FUNCTION>
<FUNCTION>
<NAME>gimp_rgb_get_gdk_color</NAME>
<RETURNS>void              </RETURNS>
const GimpRGB   *rgb,GdkColor        *gdk_color
</FUNCTION>
<FUNCTION>
<NAME>gimp_rgb_set_gdk_color</NAME>
<RETURNS>void              </RETURNS>
GimpRGB         *rgb,const GdkColor  *gdk_color
</FUNCTION>
<FUNCTION>
<NAME>gimp_window_set_hint</NAME>
<RETURNS>void              </RETURNS>
GtkWindow       *window,GimpWindowHint   hint
</FUNCTION>
<FUNCTION>
<NAME>gimp_window_get_native</NAME>
<RETURNS>GdkNativeWindow   </RETURNS>
GtkWindow       *window
</FUNCTION>
<FUNCTION>
<NAME>gimp_dialog_set_sensitive</NAME>
<RETURNS>void              </RETURNS>
GtkDialog       *dialog,gboolean         sensitive
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_buffer_load</NAME>
<RETURNS>gboolean          </RETURNS>
GtkTextBuffer   *buffer,const gchar     *filename,GError         **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_text_buffer_save</NAME>
<RETURNS>gboolean          </RETURNS>
GtkTextBuffer   *buffer,const gchar     *filename,gboolean         selection_only,GError         **error
</FUNCTION>
<FUNCTION>
<NAME>gimp_toggle_button_set_visible</NAME>
<RETURNS>void          </RETURNS>
GtkToggleButton *toggle,GtkWidget       *widget
</FUNCTION>
<FUNCTION>
<NAME>gimp_widget_set_accel_help</NAME>
<RETURNS>void              </RETURNS>
GtkWidget       *widget,GtkAction       *action
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HWRAP_BOX</NAME>
#define GTK_TYPE_HWRAP_BOX              (gtk_hwrap_box_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_HWRAP_BOX</NAME>
#define GTK_HWRAP_BOX(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_HWRAP_BOX, GtkHWrapBox))
</MACRO>
<MACRO>
<NAME>GTK_HWRAP_BOX_CLASS</NAME>
#define GTK_HWRAP_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_HWRAP_BOX, GtkHWrapBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_HWRAP_BOX</NAME>
#define GTK_IS_HWRAP_BOX(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_HWRAP_BOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_HWRAP_BOX_CLASS</NAME>
#define GTK_IS_HWRAP_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HWRAP_BOX))
</MACRO>
<MACRO>
<NAME>GTK_HWRAP_BOX_GET_CLASS</NAME>
#define GTK_HWRAP_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_HWRAP_BOX, GtkHWrapBoxClass))
</MACRO>
<STRUCT>
<NAME>GtkHWrapBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHWrapBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHWrapBox</NAME>
struct _GtkHWrapBox
{
  GtkWrapBox parent_widget;

  /*<h2v-off>*/
  guint      max_child_width;
  guint      max_child_height;
  /*<h2v-on>*/
};
</STRUCT>
<STRUCT>
<NAME>GtkHWrapBoxClass</NAME>
struct _GtkHWrapBoxClass
{
  GtkWrapBoxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hwrap_box_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hwrap_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gboolean homogeneous
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_VWRAP_BOX</NAME>
#define GTK_TYPE_VWRAP_BOX              (gtk_vwrap_box_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_VWRAP_BOX</NAME>
#define GTK_VWRAP_BOX(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_VWRAP_BOX, GtkVWrapBox))
</MACRO>
<MACRO>
<NAME>GTK_VWRAP_BOX_CLASS</NAME>
#define GTK_VWRAP_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_VWRAP_BOX, GtkVWrapBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_VWRAP_BOX</NAME>
#define GTK_IS_VWRAP_BOX(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_VWRAP_BOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_VWRAP_BOX_CLASS</NAME>
#define GTK_IS_VWRAP_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_VWRAP_BOX))
</MACRO>
<MACRO>
<NAME>GTK_VWRAP_BOX_GET_CLASS</NAME>
#define GTK_VWRAP_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_VWRAP_BOX, GtkVWrapBoxClass))
</MACRO>
<STRUCT>
<NAME>GtkVWrapBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVWrapBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVWrapBox</NAME>
struct _GtkVWrapBox
{
  GtkWrapBox parent_widget;

  /*<h2v-off>*/
  guint      max_child_width;
  guint      max_child_height;
  /*<h2v-on>*/
};
</STRUCT>
<STRUCT>
<NAME>GtkVWrapBoxClass</NAME>
struct _GtkVWrapBoxClass
{
  GtkWrapBoxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vwrap_box_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vwrap_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gboolean homogeneous
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_WRAP_BOX</NAME>
#define GTK_TYPE_WRAP_BOX             (gtk_wrap_box_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_WRAP_BOX</NAME>
#define GTK_WRAP_BOX(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_WRAP_BOX, GtkWrapBox))
</MACRO>
<MACRO>
<NAME>GTK_WRAP_BOX_CLASS</NAME>
#define GTK_WRAP_BOX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_WRAP_BOX, GtkWrapBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_WRAP_BOX</NAME>
#define GTK_IS_WRAP_BOX(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_WRAP_BOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_WRAP_BOX_CLASS</NAME>
#define GTK_IS_WRAP_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_WRAP_BOX))
</MACRO>
<MACRO>
<NAME>GTK_WRAP_BOX_GET_CLASS</NAME>
#define GTK_WRAP_BOX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_WRAP_BOX, GtkWrapBoxClass))
</MACRO>
<STRUCT>
<NAME>GtkWrapBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWrapBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWrapBoxChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWrapBox</NAME>
struct _GtkWrapBox
{
  GtkContainer     container;

  guint            homogeneous : 1;
  guint            justify : 4;
  guint            line_justify : 4;
  guint8           hspacing;
  guint8           vspacing;
  guint16          n_children;
  GtkWrapBoxChild *children;
  gfloat           aspect_ratio; /* 1/256..256 */
  guint            child_limit;
};
</STRUCT>
<STRUCT>
<NAME>GtkWrapBoxClass</NAME>
struct _GtkWrapBoxClass
{
  GtkContainerClass parent_class;

  GSList* (*rlist_line_children) (GtkWrapBox       *wbox,
                                  GtkWrapBoxChild **child_p,
                                  GtkAllocation    *area,
                                  guint            *max_child_size,
                                  gboolean         *expand_line);
};
</STRUCT>
<STRUCT>
<NAME>GtkWrapBoxChild</NAME>
struct _GtkWrapBoxChild
{
  GtkWidget *widget;
  guint      hexpand : 1;
  guint      hfill : 1;
  guint      vexpand : 1;
  guint      vfill : 1;
  guint      wrapped : 1;

  GtkWrapBoxChild *next;
};
</STRUCT>
<MACRO>
<NAME>GTK_JUSTIFY_TOP</NAME>
#define GTK_JUSTIFY_TOP    GTK_JUSTIFY_LEFT
</MACRO>
<MACRO>
<NAME>GTK_JUSTIFY_BOTTOM</NAME>
#define GTK_JUSTIFY_BOTTOM GTK_JUSTIFY_RIGHT
</MACRO>
<FUNCTION>
<NAME>gtk_wrap_box_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_homogeneous</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,gboolean         homogeneous
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_hspacing</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,guint            hspacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_vspacing</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,guint            vspacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_justify</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,GtkJustification justify
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_line_justify</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,GtkJustification line_justify
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_aspect_ratio</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,gfloat           aspect_ratio
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_pack</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,GtkWidget       *child,gboolean         hexpand,gboolean         hfill,gboolean         vexpand,gboolean         vfill
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_pack_wrapped</NAME>
<RETURNS>void           </RETURNS>
GtkWrapBox      *wbox,GtkWidget       *child,gboolean         hexpand,gboolean         hfill,gboolean         vexpand,gboolean         vfill,gboolean         wrapped
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_reorder_child</NAME>
<RETURNS>void       </RETURNS>
GtkWrapBox      *wbox,GtkWidget       *child,gint             position
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_query_child_packing</NAME>
<RETURNS>void       </RETURNS>
GtkWrapBox      *wbox,GtkWidget       *child,gboolean        *hexpand,gboolean        *hfill,gboolean        *vexpand,gboolean        *vfill,gboolean        *wrapped
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_set_child_packing</NAME>
<RETURNS>void       </RETURNS>
GtkWrapBox      *wbox,GtkWidget       *child,gboolean         hexpand,gboolean         hfill,gboolean         vexpand,gboolean         vfill,gboolean         wrapped
</FUNCTION>
<FUNCTION>
<NAME>gtk_wrap_box_query_line_lengths</NAME>
<RETURNS>guint*</RETURNS>
GtkWrapBox             *wbox,guint           *n_lines
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_ACTIVE_COLOR</NAME>
#define GIMP_TYPE_ACTIVE_COLOR (gimp_active_color_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_active_color_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpActiveColor</NAME>
typedef enum
{
  GIMP_ACTIVE_COLOR_FOREGROUND, /*< desc="Foreground" >*/
  GIMP_ACTIVE_COLOR_BACKGROUND  /*< desc="Background" >*/
} GimpActiveColor;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_ASPECT_TYPE</NAME>
#define GIMP_TYPE_ASPECT_TYPE (gimp_aspect_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_aspect_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpAspectType</NAME>
typedef enum
{
  GIMP_ASPECT_SQUARE,
  GIMP_ASPECT_PORTRAIT,       /*< desc="Portrait"  >*/
  GIMP_ASPECT_LANDSCAPE       /*< desc="Landscape" >*/
} GimpAspectType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_COLOR_DIALOG_STATE</NAME>
#define GIMP_TYPE_COLOR_DIALOG_STATE (gimp_color_dialog_state_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_color_dialog_state_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpColorDialogState</NAME>
typedef enum
{
  GIMP_COLOR_DIALOG_OK,
  GIMP_COLOR_DIALOG_CANCEL,
  GIMP_COLOR_DIALOG_UPDATE
} GimpColorDialogState;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_COLOR_FRAME_MODE</NAME>
#define GIMP_TYPE_COLOR_FRAME_MODE (gimp_color_frame_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_color_frame_mode_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpColorFrameMode</NAME>
typedef enum
{
  GIMP_COLOR_FRAME_MODE_PIXEL,  /*< desc="Pixel" >*/
  GIMP_COLOR_FRAME_MODE_RGB,    /*< desc="RGB"   >*/
  GIMP_COLOR_FRAME_MODE_HSV,    /*< desc="HSV"   >*/
  GIMP_COLOR_FRAME_MODE_CMYK    /*< desc="CMYK"  >*/
} GimpColorFrameMode;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_COLOR_PICK_STATE</NAME>
#define GIMP_TYPE_COLOR_PICK_STATE (gimp_color_pick_state_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_color_pick_state_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpColorPickState</NAME>
typedef enum
{
  GIMP_COLOR_PICK_STATE_NEW,
  GIMP_COLOR_PICK_STATE_UPDATE
} GimpColorPickState;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_CURSOR_FORMAT</NAME>
#define GIMP_TYPE_CURSOR_FORMAT (gimp_cursor_format_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_cursor_format_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpCursorFormat</NAME>
typedef enum
{
  GIMP_CURSOR_FORMAT_BITMAP, /*< desc="Black & white" >*/
  GIMP_CURSOR_FORMAT_PIXBUF  /*< desc="Fancy"         >*/
} GimpCursorFormat;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_HELP_BROWSER_TYPE</NAME>
#define GIMP_TYPE_HELP_BROWSER_TYPE (gimp_help_browser_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_help_browser_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpHelpBrowserType</NAME>
typedef enum
{
  GIMP_HELP_BROWSER_GIMP,        /*< desc="GIMP help browser" >*/
  GIMP_HELP_BROWSER_WEB_BROWSER  /*< desc="Web browser"       >*/
} GimpHelpBrowserType;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_HISTOGRAM_SCALE</NAME>
#define GIMP_TYPE_HISTOGRAM_SCALE (gimp_histogram_scale_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_histogram_scale_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpHistogramScale</NAME>
typedef enum
{
  GIMP_HISTOGRAM_SCALE_LINEAR,       /*< desc="Linear"      >*/
  GIMP_HISTOGRAM_SCALE_LOGARITHMIC   /*< desc="Logarithmic" >*/
} GimpHistogramScale;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_TAB_STYLE</NAME>
#define GIMP_TYPE_TAB_STYLE (gimp_tab_style_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_tab_style_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpTabStyle</NAME>
typedef enum
{
  GIMP_TAB_STYLE_ICON,          /*< desc="Icon"           >*/
  GIMP_TAB_STYLE_PREVIEW,       /*< desc="Current status" >*/
  GIMP_TAB_STYLE_NAME,          /*< desc="Text"           >*/
  GIMP_TAB_STYLE_BLURB,         /*< desc="Description"    >*/
  GIMP_TAB_STYLE_ICON_NAME,     /*< desc="Icon & text"    >*/
  GIMP_TAB_STYLE_ICON_BLURB,    /*< desc="Icon & desc"    >*/
  GIMP_TAB_STYLE_PREVIEW_NAME,  /*< desc="Status & text"  >*/
  GIMP_TAB_STYLE_PREVIEW_BLURB  /*< desc="Status & desc"  >*/
} GimpTabStyle;
</ENUM>
<MACRO>
<NAME>GIMP_TYPE_WINDOW_HINT</NAME>
#define GIMP_TYPE_WINDOW_HINT (gimp_window_hint_get_type ())
</MACRO>
<FUNCTION>
<NAME>gimp_window_hint_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GimpWindowHint</NAME>
typedef enum
{
  GIMP_WINDOW_HINT_NORMAL,     /*< desc="Normal window"  >*/
  GIMP_WINDOW_HINT_UTILITY,    /*< desc="Utility window" >*/
  GIMP_WINDOW_HINT_KEEP_ABOVE  /*< desc="Keep above"     >*/
} GimpWindowHint;
</ENUM>
<ENUM>
<NAME>GimpViewBG</NAME>
typedef enum  /*< skip >*/
{
  GIMP_VIEW_BG_CHECKS,
  GIMP_VIEW_BG_WHITE
} GimpViewBG;
</ENUM>
<ENUM>
<NAME>GimpViewBorderType</NAME>
typedef enum  /*< skip >*/
{
  GIMP_VIEW_BORDER_BLACK,
  GIMP_VIEW_BORDER_WHITE,
  GIMP_VIEW_BORDER_RED,
  GIMP_VIEW_BORDER_GREEN
} GimpViewBorderType;
</ENUM>
<ENUM>
<NAME>GimpDndType</NAME>
typedef enum  /*< skip >*/
{
  GIMP_DND_TYPE_NONE         = 0,
  GIMP_DND_TYPE_URI_LIST     = 1,
  GIMP_DND_TYPE_TEXT_PLAIN   = 2,
  GIMP_DND_TYPE_NETSCAPE_URL = 3,
  GIMP_DND_TYPE_XDS          = 4,
  GIMP_DND_TYPE_COLOR        = 5,
  GIMP_DND_TYPE_SVG          = 6,
  GIMP_DND_TYPE_SVG_XML      = 7,
  GIMP_DND_TYPE_PIXBUF       = 8,
  GIMP_DND_TYPE_IMAGE        = 9,
  GIMP_DND_TYPE_COMPONENT    = 10,
  GIMP_DND_TYPE_LAYER        = 11,
  GIMP_DND_TYPE_CHANNEL      = 12,
  GIMP_DND_TYPE_LAYER_MASK   = 13,
  GIMP_DND_TYPE_VECTORS      = 14,
  GIMP_DND_TYPE_BRUSH        = 15,
  GIMP_DND_TYPE_PATTERN      = 16,
  GIMP_DND_TYPE_GRADIENT     = 17,
  GIMP_DND_TYPE_PALETTE      = 18,
  GIMP_DND_TYPE_FONT         = 19,
  GIMP_DND_TYPE_BUFFER       = 20,
  GIMP_DND_TYPE_IMAGEFILE    = 21,
  GIMP_DND_TYPE_TEMPLATE     = 22,
  GIMP_DND_TYPE_TOOL_INFO    = 23,
  GIMP_DND_TYPE_DIALOG       = 24,

  GIMP_DND_TYPE_LAST         = GIMP_DND_TYPE_DIALOG
} GimpDndType;
</ENUM>
<ENUM>
<NAME>GimpDropType</NAME>
typedef enum  /*< skip >*/
{
  GIMP_DROP_NONE,
  GIMP_DROP_ABOVE,
  GIMP_DROP_BELOW
} GimpDropType;
</ENUM>
<ENUM>
<NAME>GimpCursorType</NAME>
typedef enum  /*< skip >*/
{
  GIMP_CURSOR_NONE = 1024,  /* (GDK_LAST_CURSOR + 2) yes, this is insane */
  GIMP_CURSOR_MOUSE,
  GIMP_CURSOR_CROSSHAIR,
  GIMP_CURSOR_CROSSHAIR_SMALL,
  GIMP_CURSOR_BAD,
  GIMP_CURSOR_ZOOM,
  GIMP_CURSOR_COLOR_PICKER,
  GIMP_CURSOR_LAST
} GimpCursorType;
</ENUM>
<ENUM>
<NAME>GimpToolCursorType</NAME>
typedef enum  /*< skip >*/
{
  GIMP_TOOL_CURSOR_NONE,
  GIMP_TOOL_CURSOR_RECT_SELECT,
  GIMP_TOOL_CURSOR_ELLIPSE_SELECT,
  GIMP_TOOL_CURSOR_FREE_SELECT,
  GIMP_TOOL_CURSOR_FUZZY_SELECT,
  GIMP_TOOL_CURSOR_PATHS,
  GIMP_TOOL_CURSOR_PATHS_ANCHOR,
  GIMP_TOOL_CURSOR_PATHS_CONTROL,
  GIMP_TOOL_CURSOR_PATHS_SEGMENT,
  GIMP_TOOL_CURSOR_ISCISSORS,
  GIMP_TOOL_CURSOR_MOVE,
  GIMP_TOOL_CURSOR_ZOOM,
  GIMP_TOOL_CURSOR_CROP,
  GIMP_TOOL_CURSOR_RESIZE,
  GIMP_TOOL_CURSOR_ROTATE,
  GIMP_TOOL_CURSOR_SHEAR,
  GIMP_TOOL_CURSOR_PERSPECTIVE,
  GIMP_TOOL_CURSOR_FLIP_HORIZONTAL,
  GIMP_TOOL_CURSOR_FLIP_VERTICAL,
  GIMP_TOOL_CURSOR_TEXT,
  GIMP_TOOL_CURSOR_COLOR_PICKER,
  GIMP_TOOL_CURSOR_BUCKET_FILL,
  GIMP_TOOL_CURSOR_BLEND,
  GIMP_TOOL_CURSOR_PENCIL,
  GIMP_TOOL_CURSOR_PAINTBRUSH,
  GIMP_TOOL_CURSOR_AIRBRUSH,
  GIMP_TOOL_CURSOR_INK,
  GIMP_TOOL_CURSOR_CLONE,
  GIMP_TOOL_CURSOR_ERASER,
  GIMP_TOOL_CURSOR_SMUDGE,
  GIMP_TOOL_CURSOR_BLUR,
  GIMP_TOOL_CURSOR_DODGE,
  GIMP_TOOL_CURSOR_BURN,
  GIMP_TOOL_CURSOR_MEASURE,
  GIMP_TOOL_CURSOR_HAND,
  GIMP_TOOL_CURSOR_LAST
} GimpToolCursorType;
</ENUM>
<ENUM>
<NAME>GimpCursorModifier</NAME>
typedef enum  /*< skip >*/
{
  GIMP_CURSOR_MODIFIER_NONE,
  GIMP_CURSOR_MODIFIER_PLUS,
  GIMP_CURSOR_MODIFIER_MINUS,
  GIMP_CURSOR_MODIFIER_INTERSECT,
  GIMP_CURSOR_MODIFIER_MOVE,
  GIMP_CURSOR_MODIFIER_RESIZE,
  GIMP_CURSOR_MODIFIER_CONTROL,
  GIMP_CURSOR_MODIFIER_ANCHOR,
  GIMP_CURSOR_MODIFIER_FOREGROUND,
  GIMP_CURSOR_MODIFIER_BACKGROUND,
  GIMP_CURSOR_MODIFIER_PATTERN,
  GIMP_CURSOR_MODIFIER_JOIN,
  GIMP_CURSOR_MODIFIER_LAST
} GimpCursorModifier;
</ENUM>
<ENUM>
<NAME>GimpDeviceValues</NAME>
typedef enum  /*< skip >*/
{
  GIMP_DEVICE_VALUE_MODE       = 1 << 0,
  GIMP_DEVICE_VALUE_AXES       = 1 << 1,
  GIMP_DEVICE_VALUE_KEYS       = 1 << 2,
  GIMP_DEVICE_VALUE_TOOL       = 1 << 3,
  GIMP_DEVICE_VALUE_FOREGROUND = 1 << 4,
  GIMP_DEVICE_VALUE_BACKGROUND = 1 << 5,
  GIMP_DEVICE_VALUE_BRUSH      = 1 << 6,
  GIMP_DEVICE_VALUE_PATTERN    = 1 << 7,
  GIMP_DEVICE_VALUE_GRADIENT   = 1 << 8
} GimpDeviceValues;
</ENUM>
<STRUCT>
<NAME>GimpDeviceInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerKeyboard</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerWheel</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDock</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockSeparator</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageDock</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMenuDock</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolbox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockbook</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDocked</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCursorView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDeviceStatus</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpErrorConsole</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolOptionsEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradientEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaletteEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColormapEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpComponentEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogramEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSamplePointEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSelectionEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUndoEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerComboBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerGridView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerTreeView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpItemTreeView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDrawableTreeView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpLayerTreeView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpChannelTreeView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpVectorsTreeView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerPopup</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewableButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpContainerEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBufferView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDocumentView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFontView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImageView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemplateView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDataFactoryView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushFactoryView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPatternFactoryView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEnumAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPlugInAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStringAction</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMenuFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUIManager</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpErrorDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFileDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMessageDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProgressDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTextEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToolDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewableDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPdbDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBrushSelect</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGradientSelect</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaletteSelect</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPatternSelect</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFontSelect</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpBlobEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorBar</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorDisplayEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpColorPanel</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpControllerList</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDashEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFgBgEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFgBgView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpFileProcView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpGridEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogramBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpHistogramView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpImagePropView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpMessageBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpProgressBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSizeBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStrokeEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpTemplateEditor</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpThumbBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaletteView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpNavigationView</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRenderer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererBrush</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererDrawable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererGradient</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererPalette</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererImage</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererImagefile</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererVectors</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererAccel</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererDashes</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererViewable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDialogFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUnitStore</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpUnitComboBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpActionEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpToggleActionEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpRadioActionEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpEnumActionEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpStringActionEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPlugInActionEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDialogFactoryEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfoBook</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfoDockable</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpSessionInfoAux</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GimpActionGroupSetupFunc</NAME>
<RETURNS>void </RETURNS>
GimpActionGroup *group
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpActionGroupUpdateFunc</NAME>
<RETURNS>void </RETURNS>
GimpActionGroup *group,
                                            gpointer         data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpUIManagerSetupFunc</NAME>
<RETURNS>void </RETURNS>
GimpUIManager   *manager,
                                            const gchar     *ui_path
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GimpMenuPositionFunc</NAME>
<RETURNS>void </RETURNS>
GtkMenu         *menu,
                                            gint            *x,
                                            gint            *y,
                                            gpointer         data
</USER_FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_CELL_RENDERER_DASHES</NAME>
#define GIMP_TYPE_CELL_RENDERER_DASHES            (gimp_cell_renderer_dashes_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_DASHES</NAME>
#define GIMP_CELL_RENDERER_DASHES(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CELL_RENDERER_DASHES, GimpCellRendererDashes))
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_DASHES_CLASS</NAME>
#define GIMP_CELL_RENDERER_DASHES_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_CELL_RENDERER_DASHES, GimpCellRendererDashesClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CELL_RENDERER_DASHES</NAME>
#define GIMP_IS_CELL_RENDERER_DASHES(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CELL_RENDERER_DASHES))
</MACRO>
<MACRO>
<NAME>GIMP_IS_CELL_RENDERER_DASHES_CLASS</NAME>
#define GIMP_IS_CELL_RENDERER_DASHES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_CELL_RENDERER_DASHES))
</MACRO>
<MACRO>
<NAME>GIMP_CELL_RENDERER_DASHES_GET_CLASS</NAME>
#define GIMP_CELL_RENDERER_DASHES_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_CELL_RENDERER_DASHES, GimpCellRendererDashesClass))
</MACRO>
<STRUCT>
<NAME>GimpCellRendererDashesClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererDashes</NAME>
struct _GimpCellRendererDashes
{
  GtkCellRenderer   parent_instance;

  gboolean         *segments;
};
</STRUCT>
<STRUCT>
<NAME>GimpCellRendererDashesClass</NAME>
struct _GimpCellRendererDashesClass
{
  GtkCellRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_cell_renderer_dashes_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_cell_renderer_dashes_new</NAME>
<RETURNS>GtkCellRenderer *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_PALETTE_VIEW</NAME>
#define GIMP_TYPE_PALETTE_VIEW            (gimp_palette_view_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_VIEW</NAME>
#define GIMP_PALETTE_VIEW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_PALETTE_VIEW, GimpPaletteView))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_VIEW_CLASS</NAME>
#define GIMP_PALETTE_VIEW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_PALETTE_VIEW, GimpPaletteViewClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_VIEW</NAME>
#define GIMP_IS_PALETTE_VIEW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_PALETTE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_IS_PALETTE_VIEW_CLASS</NAME>
#define GIMP_IS_PALETTE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_PALETTE_VIEW))
</MACRO>
<MACRO>
<NAME>GIMP_PALETTE_VIEW_GET_CLASS</NAME>
#define GIMP_PALETTE_VIEW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_PALETTE_VIEW, GimpPaletteViewClass))
</MACRO>
<STRUCT>
<NAME>GimpPaletteViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpPaletteView</NAME>
struct _GimpPaletteView
{
  GimpView          parent_instance;

  GimpPaletteEntry *selected;
  GimpPaletteEntry *dnd_entry;
  GdkGC            *gc;
};
</STRUCT>
<STRUCT>
<NAME>GimpPaletteViewClass</NAME>
struct _GimpPaletteViewClass
{
  GimpViewClass  parent_class;

  void (* entry_clicked)   (GimpPaletteView  *view,
                            GimpPaletteEntry *entry,
                            GdkModifierType   state);
  void (* entry_selected)  (GimpPaletteView  *view,
                            GimpPaletteEntry *entry);
  void (* entry_activated) (GimpPaletteView  *view,
                            GimpPaletteEntry *entry);
  void (* entry_context)   (GimpPaletteView  *view,
                            GimpPaletteEntry *entry);
  void (* color_dropped)   (GimpPaletteView  *view,
                            GimpPaletteEntry *entry,
                            const GimpRGB    *color);
};
</STRUCT>
<FUNCTION>
<NAME>gimp_palette_view_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_palette_view_select_entry</NAME>
<RETURNS>void    </RETURNS>
GimpPaletteView  *view,GimpPaletteEntry *entry
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_VIEW_RENDERER_PALETTE</NAME>
#define GIMP_TYPE_VIEW_RENDERER_PALETTE            (gimp_view_renderer_palette_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_PALETTE</NAME>
#define GIMP_VIEW_RENDERER_PALETTE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_VIEW_RENDERER_PALETTE, GimpViewRendererPalette))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_PALETTE_CLASS</NAME>
#define GIMP_VIEW_RENDERER_PALETTE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_VIEW_RENDERER_PALETTE, GimpViewRendererPaletteClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_PALETTE</NAME>
#define GIMP_IS_VIEW_RENDERER_PALETTE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE (obj, GIMP_TYPE_VIEW_RENDERER_PALETTE))
</MACRO>
<MACRO>
<NAME>GIMP_IS_VIEW_RENDERER_PALETTE_CLASS</NAME>
#define GIMP_IS_VIEW_RENDERER_PALETTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_VIEW_RENDERER_PALETTE))
</MACRO>
<MACRO>
<NAME>GIMP_VIEW_RENDERER_PALETTE_GET_CLASS</NAME>
#define GIMP_VIEW_RENDERER_PALETTE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_VIEW_RENDERER_PALETTE, GimpViewRendererPaletteClass))
</MACRO>
<STRUCT>
<NAME>GimpViewRendererPaletteClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererPalette</NAME>
struct _GimpViewRendererPalette
{
  GimpViewRenderer  parent_instance;

  gint              cell_size;
  gboolean          draw_grid;

  gint              cell_width;
  gint              cell_height;
  gint              columns;
  gint              rows;
};
</STRUCT>
<STRUCT>
<NAME>GimpViewRendererPaletteClass</NAME>
struct _GimpViewRendererPaletteClass
{
  GimpViewRendererClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_view_renderer_palette_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_palette_set_cell_size</NAME>
<RETURNS>void    </RETURNS>
GimpViewRendererPalette *renderer,gint                     cell_size
</FUNCTION>
<FUNCTION>
<NAME>gimp_view_renderer_palette_set_draw_grid</NAME>
<RETURNS>void    </RETURNS>
GimpViewRendererPalette *renderer,gboolean                 draw_grid
</FUNCTION>
<MACRO>
<NAME>GIMP_RENDER_BUF_WIDTH</NAME>
#define GIMP_RENDER_BUF_WIDTH  256
</MACRO>
<MACRO>
<NAME>GIMP_RENDER_BUF_HEIGHT</NAME>
#define GIMP_RENDER_BUF_HEIGHT 256
</MACRO>
<VARIABLE>
<NAME>gimp_render_check_buf</NAME>
extern guchar *gimp_render_check_buf;
</VARIABLE>
<VARIABLE>
<NAME>gimp_render_empty_buf</NAME>
extern guchar *gimp_render_empty_buf;
</VARIABLE>
<VARIABLE>
<NAME>gimp_render_white_buf</NAME>
extern guchar *gimp_render_white_buf;
</VARIABLE>
<VARIABLE>
<NAME>gimp_render_temp_buf</NAME>
extern guchar *gimp_render_temp_buf;
</VARIABLE>
<VARIABLE>
<NAME>gimp_render_blend_dark_check</NAME>
extern guchar *gimp_render_blend_dark_check;
</VARIABLE>
<VARIABLE>
<NAME>gimp_render_blend_light_check</NAME>
extern guchar *gimp_render_blend_light_check;
</VARIABLE>
<VARIABLE>
<NAME>gimp_render_blend_white</NAME>
extern guchar *gimp_render_blend_white;
</VARIABLE>
<FUNCTION>
<NAME>gimp_render_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>gimp_render_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<MACRO>
<NAME>GIMP_TYPE_DOCK_SEPARATOR</NAME>
#define GIMP_TYPE_DOCK_SEPARATOR            (gimp_dock_separator_get_type ())
</MACRO>
<MACRO>
<NAME>GIMP_DOCK_SEPARATOR</NAME>
#define GIMP_DOCK_SEPARATOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DOCK_SEPARATOR, GimpDockSeparator))
</MACRO>
<MACRO>
<NAME>GIMP_DOCK_SEPARATOR_CLASS</NAME>
#define GIMP_DOCK_SEPARATOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIMP_TYPE_DOCK_SEPARATOR, GimpDockSeparatorClass))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCK_SEPARATOR</NAME>
#define GIMP_IS_DOCK_SEPARATOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DOCK_SEPARATOR))
</MACRO>
<MACRO>
<NAME>GIMP_IS_DOCK_SEPARATOR_CLASS</NAME>
#define GIMP_IS_DOCK_SEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIMP_TYPE_DOCK_SEPARATOR))
</MACRO>
<MACRO>
<NAME>GIMP_DOCK_SEPARATOR_GET_CLASS</NAME>
#define GIMP_DOCK_SEPARATOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIMP_TYPE_DOCK_SEPARATOR, GimpDockSeparatorClass))
</MACRO>
<STRUCT>
<NAME>GimpDockSeparatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GimpDockSeparator</NAME>
struct _GimpDockSeparator
{
  GtkEventBox  parent_instance;

  GimpDock    *dock;

  GtkWidget   *frame;
  GtkWidget   *label;
};
</STRUCT>
<STRUCT>
<NAME>GimpDockSeparatorClass</NAME>
struct _GimpDockSeparatorClass
{
  GtkEventBoxClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gimp_dock_separator_get_type</NAME>
<RETURNS>GType       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_separator_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GimpDock          *dock
</FUNCTION>
<FUNCTION>
<NAME>gimp_dock_separator_set_show_label</NAME>
<RETURNS>void        </RETURNS>
GimpDockSeparator *separator,gboolean           show
</FUNCTION>
<FUNCTION>
<NAME>xcf_load_image</NAME>
<RETURNS>GimpImage *</RETURNS>
Gimp    *gimp,XcfInfo *info
</FUNCTION>
<ENUM>
<NAME>PropType</NAME>
typedef enum
{
  PROP_END                =  0,
  PROP_COLORMAP           =  1,
  PROP_ACTIVE_LAYER       =  2,
  PROP_ACTIVE_CHANNEL     =  3,
  PROP_SELECTION          =  4,
  PROP_FLOATING_SELECTION =  5,
  PROP_OPACITY            =  6,
  PROP_MODE               =  7,
  PROP_VISIBLE            =  8,
  PROP_LINKED             =  9,
  PROP_LOCK_ALPHA         = 10,
  PROP_APPLY_MASK         = 11,
  PROP_EDIT_MASK          = 12,
  PROP_SHOW_MASK          = 13,
  PROP_SHOW_MASKED        = 14,
  PROP_OFFSETS            = 15,
  PROP_COLOR              = 16,
  PROP_COMPRESSION        = 17,
  PROP_GUIDES             = 18,
  PROP_RESOLUTION         = 19,
  PROP_TATTOO             = 20,
  PROP_PARASITES          = 21,
  PROP_UNIT               = 22,
  PROP_PATHS              = 23,
  PROP_USER_UNIT          = 24,
  PROP_VECTORS            = 25,
  PROP_TEXT_LAYER_FLAGS   = 26
} PropType;
</ENUM>
<ENUM>
<NAME>XcfCompressionType</NAME>
typedef enum
{
  COMPRESS_NONE              =  0,
  COMPRESS_RLE               =  1,
  COMPRESS_ZLIB              =  2,  /* unused */
  COMPRESS_FRACTAL           =  3   /* unused */
} XcfCompressionType;
</ENUM>
<ENUM>
<NAME>XcfOrientationType</NAME>
typedef enum
{
  XCF_ORIENTATION_HORIZONTAL = 1,
  XCF_ORIENTATION_VERTICAL   = 2
} XcfOrientationType;
</ENUM>
<ENUM>
<NAME>XcfStrokeType</NAME>
typedef enum
{
  XCF_STROKETYPE_STROKE        = 0,
  XCF_STROKETYPE_BEZIER_STROKE = 1
} XcfStrokeType;
</ENUM>
<STRUCT>
<NAME>XcfInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>XcfInfo</NAME>
struct _XcfInfo
{
  FILE               *fp;
  guint               cp;
  const gchar        *filename;
  GimpTattoo          tattoo_state;
  GimpLayer          *active_layer;
  GimpChannel        *active_channel;
  GimpDrawable       *floating_sel_drawable;
  GimpLayer          *floating_sel;
  guint               floating_sel_offset;
  gint                swap_num;
  gint               *ref_count;
  XcfCompressionType  compression;
  gint                file_version;
};
</STRUCT>
<FUNCTION>
<NAME>xcf_read_int32</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,guint32  *data,gint      count
</FUNCTION>
<FUNCTION>
<NAME>xcf_read_float</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,gfloat   *data,gint      count
</FUNCTION>
<FUNCTION>
<NAME>xcf_read_int8</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,guint8   *data,gint      count
</FUNCTION>
<FUNCTION>
<NAME>xcf_read_string</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,gchar   **data,gint      count
</FUNCTION>
<FUNCTION>
<NAME>xcf_save_choose_format</NAME>
<RETURNS>void   </RETURNS>
XcfInfo   *info,GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>xcf_save_image</NAME>
<RETURNS>gint   </RETURNS>
XcfInfo   *info,GimpImage *image
</FUNCTION>
<FUNCTION>
<NAME>xcf_seek_pos</NAME>
<RETURNS>gboolean   </RETURNS>
XcfInfo *info,guint    pos,GError **error
</FUNCTION>
<FUNCTION>
<NAME>xcf_seek_end</NAME>
<RETURNS>gboolean   </RETURNS>
XcfInfo *info,GError **error
</FUNCTION>
<FUNCTION>
<NAME>xcf_write_int32</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,guint32  *data,gint      count,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>xcf_write_float</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,gfloat   *data,gint      count,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>xcf_write_int8</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,guint8   *data,gint      count,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>xcf_write_string</NAME>
<RETURNS>guint   </RETURNS>
FILE     *fp,gchar   **data,gint      count,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>xcf_init</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>
<FUNCTION>
<NAME>xcf_exit</NAME>
<RETURNS>void   </RETURNS>
Gimp *gimp
</FUNCTION>

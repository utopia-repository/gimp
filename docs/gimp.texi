\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename gimp
@settitle The GIMP
@setchapternewpage odd
@c %**end of header

@set edition 0.5
@set update-date 19 November 1995
@set update-month November 1995

@ifinfo
This file documents the GIMP, the General Image Manipulation Program.

Copyright (C) 1995 Peter Mattis and Spencer Kimball

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies

@ignore
Permission is granted to process this file throught TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by Peter Mattis or Spencer Kimball.
@end ifinfo

@titlepage
@title The GIMP
@subtitle The General Image Manipulation Program
@subtitle Version 0.5
@author by Peter Mattis and Spencer Kimball

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995 Peter Mattis and Spencer Kimball

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
 
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
 
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by Peter Mattis or Spencer Kimball.
@end titlepage

@ifinfo
@node Top, Copying, (dir), (dir)
@top The General Image Manipulation Program

The GIMP is our attempt to provide graphical, interactive image manipulation
cababilities to the unix community.

This documentation is broken up into two main parts. The first is a reference
section which describes the use of the various aspects of the GIMP. The second
part is comprised of a series of tutorials which aim to show how to use
the various abilities of the GIMP to accomplish particular tasks.

This is Edition @value{edition} of the GIMP documentation,
@w{@value{update-date},} for the GIMP v1.0.
@end ifinfo

@menu
* Copying::                     Your rights.
* Genesis::                     The beginnings.
* Introduction::                The purpose of the GIMP.
* Selections::                  Creating, modifying and using selections.
* Transformations::             The transformation tools.
* Painting::                    The painting tools.
* Plug-ins::                    Extending the GIMP.
@end menu

@node Copying, Genesis, Top, Top
@comment node-name, next, previous, up
@unnumbered The GIMP Copying Conditions
@cindex The GIMP Copying Conditions

The GIMP is @dfn{free}; this means that everyone is free to use it and free
to redestribute it on a free basis. The GIMP is not in the public domain; it
is copyrighted and there are restrictions on its distribution, but these
restrictions are designed to permit everything that a good cooperating citizen
would want to do. What is not allowed is to try to prevent others from further
sharing any version of the GIMP that they might get from you.

Specifically, we want to make sure that you have the right to give away 
copies of the GIMP, that you receive source code or else can get it if you 
want it, that you can change the GIMP or use pieces of it in new free programs,
and that you know you can do these things.

To make sure that everyone has such rights, we have to forbid you to deprive
anyone else of these rights. For example, if you distribute copies of the GIMP,
you must give the recipients all the rights that you have. You must make sure
that they, too, receive or can get the source code. And you must tell them their
rights.

Also, for our own protection, we must make certain that everyone finds out
that there is no warranty for the GIMP. f the GIMP is modified by someone else
and passed on, we want their recipients to know that what they have is not what
we distributed, so that any problems introduced by others will no reflect on our
reputation.

The precise conditions of the licenses for the GIMP are found in the General
Public Licenses that accompanies it.

@node Genesis, Introduction, Copying, Top
@comment node-name, next, previous, up
@chapter Genesis of the GIMP
@cindex Genesis of the GIMP

The GIMP arose from the ashes of a hideously crafted cs164 (compilers)
class project. The setting: early morning. We were both weary from
lack of sleep and the terrible strain of programming a compiler in LISP.
The limits of our patience had long been exceeded, and yet still the dam
held.

And then it happened. Common LISP messily dumped core when it could
not allocate the 17 MB it needed to generate a parser for a simple
grammar using ``jyack''. An unbelieving moment passed, there was one
shared look of disgust, and then our project was vapor. We had to write
something...ANYTHING...useful. Something in C. Something that did not
rely on nested lists to represent a bitmap. Thus, the GIMP was born.

Like the phoenix, glorious, new life sprung out of the burnt remnants
of LISP and jyacc. Ideas went flying, decisions were made, the GIMP
began to take form.

An image manipulation program was the consensus. A program which
would at the very least lessen the necessity of using commercial
software under ``Windoze'' or on the ``Macintoy''. A program that would
provide the features missing from the other X painting and imaging
tools. A program that would help maintain the long tradition of excellent and
free UNIX applications.

Six months later, we've reached an early BETA stage. We want to release
now to start working on compatibility issues and cross platform
stability. Also, we feel now that the program is actually usable and
would like to see other interested programmers developing plug-ins and
various file format support.

@node Introduction, Selections, Genesis, Top
@comment node-name, next, previous, up
@chapter Introduction to the GIMP
@cindex Introduction to the GIMP

The GIMP is designed to provide an intuitive graphical interface to a 
variety of image editing operations. The following list describes parts
of the GIMP's functionality.

@itemize

@item
@strong{Views}. A window on the screen is essentially a viewport into
the image space. This means that multiple windows can look into the same
space. By this same reasoning, changing the image in one window causes
the change to propogate to all the other windows.

@item
@strong{Undo}. There is no restriction on the number of possible
undo/redo operations. However, limited memory means that for practical
purposes limiting the size and length of the undo stack is
necessary. The GIMP allows these values to be customized by the
user. Undo/redo works for almost all operations. The few operations
which cannot be undone are normally have semantics that would make undo
unwanted. For instance, duplicating an image creates a new image from an
old one. Undo-ing this operation would consist of destroying the new
image, something the user might not expect.

@item
@strong{Selections}. Selections allow the user to manipulate areas of an
image. They are used to mask operations during painting and plug-in
usage and to specify the active area when using the transformation 
tools. @xref{Selections}, for more info.

@item
@strong{Crop}. The crop tool allows the quick and easy cropping of an
image.

@item
@strong{Painting}. The painting tools provide the ability to edit an
image in a variety of ways. Different operations include adding brush
strokes, cloning parts of an image, convolving parts of an image,
filling parts of an image and adding text.

@item
@strong{Transforming}. The transformation tools operate on
selections. They modify both the selection and the pixels within the
selection. The currently available transformations are rotate, scale,
shear, flip horizontal and flip vertical.

@item
@strong{Plug-ins}. Plug-ins provide a mechanism for easily extending the
GIMP in certain areas. Namely, operations that work on images and that
do not require interactive user input. Currently, plug-ins fill the role
of loading and saving images as well as performing various effects on
images. @xref{Plug-ins}, for more info.

@end itemize

@node Selections, Transformations, Introduction, Top
@comment node-name, next, previous, up
@chapter Creating, modifying and using selections
@cindex Creating, modifying and using selections

A @dfn{selection} is defined as the currently active region of an image.
Selections can be made with single pixel precision, and can be
arbitrarily complex. A GIMP selection is represented graphically by a
boundary line drawn around the represented region. The line appears
to move, and so is easy to discern even when used with a complex
image. This moving lines can at times be distracting, or obscure
important image information; they can be toggled on or off via the
(/Edit/Selection Toggle) menu item.

Selections are created and modified using the suite of selection
tools which include: rectangular, elliptical, free hand, fuzzy,
bezier, and intelligent. Each successive use of a tool replaces
the current selection with a new one. However, the current selection
can be changed instead of replaced by holding down either the @kbd{shift}
or @kbd{control} keys. The @kbd{shift} key has the effect of taking the
union of the current selection and the new selection. The @kbd{control}
key takes the difference.

While a selection is active in an image window, operations only affect
the portion of the image which is inside the selection. Effects filters,
for example, only change the pixels defined by the active selection. The
various painting tools work in the same fashion.

@menu
* Editing selections::          Moving, cutting, copying and pasting.
* Advanced selection usage::    Using selections to the limit.
* Selection tools::             The selection tools.
@end menu

@node Editing selections, Advanced selection usage, Selections, Selections
@comment node-name, next, previous, up
@section Editing Selections
@cindex Editing selections

Intuitively, clicking with the mouse inside a selection allows
the selection to be dragged to a new location. This functionality
is only present when one of the selection tools is the active tool.
The GIMP represents a selection being dragged by its outline or its
bounding box. The bounding box is useful when the outlines become
very complex and the host machine is slow. The default is to use
the selection's outline, but bounding boxes can be enabled through a
command line switch or an X resource.

Selected regions can be precisely positioned using the keyboard's
cursor keys. Holding down the @kbd{shift} key has the effect of
increasing the step size of each movement. 

Standard editing functions are available for use on selections. In a
basic sense, cut, copy, & paste work on selected image areas just like
they might work on selected text. Cutting a selected region removes
both the selection and the associated image region, replacing the
former pixel colors with the background color. The cut selection is
now stored in a global buffer, from which the cut selection can be
pasted any number of times. Copying has the same effect as cut, but
does not remove the selection being copied. Successive copies or cuts
replace the former contents of the global buffer.

Paste copies the selection in the global buffer to the current image,
replacing the image's selection, if one existed. It positions the new
selection so that its center corresponds to the center of the former
selection. If there was no fomer selection, the pasted selection is
centered with respect to the entire image.

A selection that is pasted or moved is considered to be @dfn{floating}.
That is, the contents of the image under it are preserved. Moving a
floating selection to a new location restores the image previously
hidden to its former state. A floating selection can be anchored by a
invoking the (/Edit/Selection Anchor) menu item. This effectively
replaces the contents of the image underneath with the contents of the
floating selection, and does away with the ``floating'' status.
Modifying a floating selection's boundary with selection tools has the
same effect.

The transparency of floating selections can be modified through
the (Edit/Paste Opacity) menu item. This invokes a dialog with a
slider that control the percentage of the floating buffer's opacity.
100% corresponds to no transparency or full opacity. The lower the
opacity is set to, the more transparent the floating buffer becomes
until at 0%, the floating buffer is invisible and only the image
under it can be seen.

@node Advanced selection usage, Selection tools, Editing selections, Selections
@comment node-name, next, previous, up
@section Advanced selection usage
@cindex Advanced selection usage

There is support in GIMP selections for an alpha value at each pixel
in the selected area. That is, each pixel can have a value from 0 to
255 associated with it. This extra data is used by the GIMP in more 
complex operations such as anti-aliasing and image composition.

Cutting a selection from an image uses this alpha value to determine
how much of a former pixel should remain behind and how much should be
cut. If the alpha value is 255, then the entire pixel will be removed,
and only the background color will remain. If the alpha value is 0,
then nothing will be cut and the pixel on the image will remain the
same. If the alpha value is 127, then half of the pixel's previous
color will be cut, and what remains will be a 50/50 combination of
the background color and the former pixel color.

A floating selection uses the alpha value to @dfn{blend} the color of the
pixel it represents with the color underneath that pixel. The
effect is transparency in the floating selection. This essentially is
how floating selections can achieve anti-aliasing.

A selection's alpha channel can be edited through the menu item:
(/Edit/Selection To Mask), which represents the current selection as
an editable grayscale image. White in the image corresponds to an
alpha value of 255. Black in the image similarly corresponds to an
alpha value of 0. Shades of gray represent all of the intermediate
values. This image is identical in every respect to a standard
grayscale image, and can be modified in the same ways.

The grayscale image created by (/Edit/Selection To Mask) can be
converted back into a selection via the (/Edit/Selection From Mask)
menu item. This call pops up a dialog with an option menu requesting
the mask source image. It then translates the shades of gray into a
new selection with the corresponding alpha values.

Because the global buffer discussed previously can only hold one
selection, named selection buffers are supported by the GIMP. Instead
of the usual (/Edit/Cut) or (/Edit/Copy), using (/Edit/Cut Named) or
(/Edit/Copy Named) pops up a dialog box asking for the name of the new
buffer. In this fashion, an arbitrary number of selections can be
saved and recalled at convenient times. (/Edit/Paste Named) calls a
dialog box which allows any of the previously saved buffers to be
pasted.

@node Selection tools, , Advanced selection usage, Selections
@comment node-name, next, previous, up
@section The selection tools
@cindex The selection tools

The GIMP currently supports six different selection tools. In order
of appearance in the tool box they are: rectangle, ellipse, free,
fuzzy, bezier, and intelligent. Each tool has its advantages and
disadvantages--no one tool is clearly superior to the others. In
general, a combination of tools proves to be the optimal strategy for
complex selection tasks. Following is a more complete description of
each tool, including strengths and weaknesses as well as features.

@menu
* Rectangle and ellipse::       Rectangle and ellipse selection tools.
* Free::                        Free selection tool.
* Fuzzy::                       Fuzzy selection tool.
* Bezier::                      Bezier selection tool.
* Intelligent::                 Intelligent selection tool.
@end menu

@node Rectangle and ellipse, Free, Selection tools, Selection tools
@comment node-name, next, previous, up
@subsection Rectangle and ellipse selection tools
@cindex Rectangle and ellipse selection tools

These tools are self-explanatory. Rectangles and ellipses can be
placed in an image by clicking in the image window with the left mouse
button. The width and height are specified by dragging the mouse with
the button still pressed. Holding down the `Shift' and `Control' keys
simultaneously keeps the width and height equal, effectively producing
squares or circles. As with all selection tools, holding down `Shift'
when the rectangle or ellipse is initially placed adds the resulting
shape to the current selection; `Control' subtracts from the current
selection.

@node Free, Fuzzy, Rectangle and ellipse, Selection tools
@comment node-name, next, previous, up
@subsection Free selection tool
@cindex Free selection tool

Free select allows an arbitrarily complex curve to be drawn with the
mouse which is then scan converted into a polygon and incorporated
into the current selection. Free select is especially good for
``touching up'' selections--either subtracting extraneous pixels or
adding a few missing pixels. Selecting large complex shapes is
possible, but time consuming and inaccurate. 

@node Fuzzy, Bezier, Free, Selection tools
@comment node-name, next, previous, up
@subsection Fuzzy selection tool
@cindex Fuzzy selection tool

Fuzzy select or ``magic wand'' is initiated by specifying a seed pixel
with the left mouse button. The resulting selection will include the
seed pixel and contiguous pixels of similar color. Essentially, the
selection flows outward from the seed pixel until it reaches pixels
which are sufficiently dissimilar in color. The threshold value which
determinates what is ``sufficient'' can be dynamically set by dragging
the mouse with the left button still pressed. Moving left or up
decreases the threshold, shrinking the selection. Moving right or
down increases the threshold, enlarging the selection. When the
proposed selection is satisfactory, it can be combined with the
current selection by releasing the left mouse button. Subsequent use
of the fuzzy tool will start with the final threshold value of the
previous use.

Fuzzy selections are well suited to selecting objects of near constant
color. Unfortunately, objects of this nature seldom appear in images.
When used in conjunction with other tools, however, fuzzy select
proves invaluable. It is especially effective in subtracting
background pixels from roughly drawn boundaries.

@node Bezier, Intelligent, Fuzzy, Selection tools
@comment node-name, next, previous, up
@subsection Bezier selection tool
@cindex Bezier selection tool

Bezier select allows the interactive creation of closed bezier
curves. The curves are made up of a series of segments and the
segments are in turn made up of a series of points. Clicking the left
mouse button when this tool is active places an anchor point. Clicking
and dragging places an anchor point and allows the specification of
the next control point on the curve which is then placed when the
button is released. While moving a control point, the anchor point
can be moved by holding down the `Control' key. The continuity between
curve segments can be controlled by using the `Shift' key. Holding
down the `Shift' key while a control point is being moved causes the
continuity between to segments to be disrupted. Releasing the `Shift'
key causes it to be restored. (This allows for the creation of sharp
corners on the curve). Control points are displayed as squares and anchor
points as circles. The active point (whether it is a control or anchor
point) is displayed filled while all other points or unfilled. 

The curve is changed into a selection by clicking inside of
it. Similar to other selection tools, holding down `Shift' adds to the
current selection while holding down `Control' subtracts from the
current selection.

The bezier selection tool is particularly well suited for selecting
curved regions of an image, such as the outline of a teapot. Conversely,
it is inadequate for selecting regions which contain a lot of variation.

@node Intelligent, , Bezier, Selection tools
@comment node-name, next, previous, up
@subsection Intelligent selection tool
@cindex Intelligent selection tool

Intelligent selection or ``intelligent scissors'' is a computationaly
expensive tool that often provess well worth the extra CPU cycles.
This tool is specifically for selecting well definined objects in an
image. Selections are created by placing control points at
appropriate positions along the edges of the desired object. The
intelligence of the tool is its ability to discern a path between each
set of adjacent control points that corresponds closely to the
object's edge. Clicking the left mouse button on the image displays a
target cursor specifying where the control point will be placed when
the button is released. Dragging the mouse with the button still
pressed moves the target cursor as well. Instead of following the
mouse cursor exactly, the target cursor ``jumps'' to the nearest
perceived edge in the image. This behavior is useful because good
results using this tool are achieved with control points that lie on
strong edges. It can be disabled by holding down the `Shift' key
while dragging the mouse.

To finish the selection, specify the last control point as the
original control point, which connects the boundary. Control points
can be modified by dragging them to new positions. New control points
can be inserted by clicking on the curves between any set of existing
control points. Clicking inside the connected boundary results in the
final selection. As with other tools, holding down `Shift' adds to
the current selection while holding down `Control' subtracts from the
current selection.

Though smarter than most other selection tools, intelligent select is
stupid compared to the average human, so it is not surprising that it
is prone to foolish errors. By adding additional control
points--explicitly defining where the edge of the object is--this tool
can be shown the error of its ways. Intelligent select is especially
good at selecting objects with strong, well defined edges. When these
conditions do not exist, the bezier selection tool is a better choice.
Some errors that the tool makes are very difficult to correct by
adding additional control points. In these cases, using free
selection or fuzzy selection to ``touch up'' the intelligent selection
makes sense.


@node Transformations, Painting, Selections, Top
@comment node-name, next, previous, up
@chapter The transformation tools
@cindex The transformation tools


@node Painting, Plug-ins, Transformations, Top
@comment node-name, next, previous, up
@chapter The painting tools
@cindex The painting tools


@node Plug-ins, , Painting, Top
@comment node-name, next, previous, up
@chapter Extending the GIMP
@cindex Extending the GIMP

Plug-ins are external programs which offer an easy method of extending
parts of the GIMP's functionality. Basically, they can be used to
operate on images perform such useful tasks as loading and saving images
to disk as fell as applying various effects filters. Plug-ins are easy
to write, easy to use and a vary nice solution to the problem of
bloating the main program with a lot of code that rarely gets used.

@menu
* Using plug-ins::              How to use plug-ins.
* Standard plug-ins::           Plug-ins that come with the GIMP.
* Programming plug-ins::        Information for plug-in developers.
@end menu

@node Using plug-ins, Standard plug-ins, Plug-ins, Plug-ins
@comment node-name, next, previous, up
@section How to Use Plug-ins
@cindex How to Use Plug-ins

Plug-ins, as part of their functionality, must be easily accessible from
within the GIMP. This is accomplished by putting them within easy reach
in the image popup menu which is accessed by clicking the right mouse
button within the image. The user need only select the appropriate
plug-in from the choices for it to run.

Actually, the above is a simplification of the actual mechanism. The
GIMP uses a configuration file that is parsed at startup to determine
which plug-ins should be accessible to the user. The configuration file
allows the user to specify a hierarchy of menus in which the plug-ins
lie. The configuration file also specifies a search path to look through
in order to find the actual location of the plug-in binaries.

File plug-ins work slightly differently than other plug-ins. They are
accessed semi-invisibly when the user opens or saves a file using the
(file/open) or (file/save) commands. The correct file plug-in is
determined by examining the extension used to save or open the
file. (ie. If a file ``temp.jpg'' is opened then the ``jpeg'' file
plug-in will be used). The configuration file described above provides a
mapping between extensions and file plug-ins. The user can also specify
a particular file plug-in to use when opening and saving files which
overrides the extension mechanism. This allows a file to be opened or
saved which doesn't have an extension.

Many of the plug-ins provide simple dialog interfaces to parameters that
affect their operation. These dialogs share the common theme that
clicking the ``ok'' button has the effect of applying the plug-in and
clicking the ``cancel'' button has the effect of canceling the
plug-in.

@node Standard plug-ins, Programming plug-ins, Using plug-ins, Plug-ins
@comment node-name, next, previous, up
@section The Standard Plug-ins
@cindex The Standard Plug-ins

The GIMP is distributed with an assortment of plug-ins to extend its
functionality. Some of these plug-ins, the file plug-ins for instance,
should be viewed as integral parts of the GIMP since using the GIMP
would be difficult without them.

Plug-ins are broken into 3 categories. File plug-ins load and save files
to disk. Filter plug-ins perform effects on an image. These effects
modify the image and are restricted to take place within the current
selection. And lastly, channel operations operate on entire images at a
single time and perform such operations as duplicate and
composite. Below is a list of the plug-ins that come with the GIMP and a
short description of their operation.

@itemize

@item
add - channel operation. Adds together two images by adding
corresponding pixels and creating a new image.

@item
bleed - filter. Acts as a low pass filter on the rgb components of an
rgb image. 

@item
blend - channel operation. Blends together two images by a specified
percentage.

@item
blur - filter. Blurs an image using a 3x3 convolution kernel.

@item
compose - channel operation. Composes an rgb image out of three
grayscale images. It interpret the grayscale images as the rgb
components of the new image or as hsv (hue/saturation/value) components
of the new image. Used in conjunction with `decompose'.

@item
composite - channel operation. Composites three images together and
creates a new image. The three images are two source images and a mask
image. 

@item
decompose - channel operation. Decomposes an rgb image into three
grayscale images. The grayscale images can be specified as the rgb
channels or the hsv channels of the original image.

@item
difference - channel operation. Takes the absolute value of the
difference between two images and creates a new image.

@item
duplicate - channel operation. Duplicates the new image and creates a
new image.

@item
edge - filter. Performs edge detection on the input image. The edge
detection technique used is to take the Pythagorean sum of two Sobel
gradient operators at 90 degrees to each other.

@item
enhance - filter. Enhances edges in the input image.

@item
flip_horz - filter. Flips the image horizontally.

@item
flip_vert - filter. Flips the image vertically.

@item
gamma - filter. Gamma corrects the image.

@item
gbrush - file. Saves or loads an image in the `gbrush' format used for
brushes. 

@item
gif - file. Saves or loads an image in the `gif' format.

@item
grayify - filter. Replaces the rgb components in an rgb image by their
grayscale equivalent.

@item
invert - filter. Inverts an image.

@item
jpeg - file. Saves or loads an image in the `jpeg' format.

@item
multiply - channel operation. Multiplies two images together and creates
a new image.

@item
offset - channel operation. Offsets an image by a specified amount and
creates a new image.

@item
pixelize - filter.

@item
png - file. Saves or loads an image in the `png' format.

@item
relief - filter. Performs a Laplacian convolution on the input
image. This effect is sometimes known as emboss.

@item
rotate - channel operation. Rotates the input image and creates a new
image. Blank areas are filled with the background color.

@item
scale - channel operation. Scales an image and creates a new image.

@item
shift - filter. Displaces each row of pixels by a random user specified
amount. 

@item
spread - filter. Displaces each pixel by a random user specified
amount.

@item
subtract - channel operation. Takes the difference between two images
and creates a new image.

@item
tiff - file. Saves or loads an image in the `tiff' format.

@item
to-color - channel operation. Converts a grayscale or indexed color
image to an rgb color image.

@item
to-gray - channel operation. Converts an rgb color or indexed color
image to a grayscale image.

@item
to-indexed - channel operation. Converts an rgb color or grayscale image
to an indexed color image.

@end itemize

@node Programming plug-ins, , Standard plug-ins, Plug-ins
@comment node-name, next, previous, up
@section Programing for Plug-ins
@cindex Programming for Plug-ins

Plug-ins are simply ordinary programs that are run by the GIMP. They
communicate with the GIMP using a simple message passing system that
currently works using a combination of unix pipes and shared
memory.

The message passing system allows plug-ins to access services provided
by the GIMP, such as creating and displaying an image. It is, however,
too low level to be used for everyday programming. The solution is a
high level library that provides another layer on top of the message
passing system. It is this library and its usage that will be
described.

@menu
* Initialization::              Initializing the plug-in library.
* Images::                      Getting and operating on images.
* Dialogs::                     Creating and using dialogs.
* Miscellaneous::               Miscellaneous library functions.
* Example filter::              An example of a filter plug-in.
* Example channel operation::   An example of a channel operation.
* Example file::                An example of a file plug-in.
@end menu

@node Initialization, Images, Programming plug-ins, Programming plug-ins
@comment node-name, next, previous, up
@subsection Initializing the plug-in library
@cindex Initializing the plug-in library

Initialization of the GIMP library is necessary so the library can setup
its communication channels with the GIMP. The GIMP passes in information
to be used to setup these channels on the command line when the plug-in
is run. All that is needed to initialize the library, however, is to
call the @code{gimp_init} function with the @var{argc} and @var{argv}
arguments.

@deftypefun int gimp_init (int @var{argc}, char **@var{argv})
This function initializes the GIMP library. The arguments @var{argc} and
@var{argv} are simply the @var{argc} and @var{argv} values passed into
@code{main} upon invocation.
@end deftypefun

@example
int
main (argc, argv)
     int argc;
     char **argv;
@{
  if (gimp_init (argc, argv))
    @{
      /* do some stuff */
    @}
@} 
@end example

@node Images, Dialogs, Initialization, Programming plug-ins
@comment node-name, next, previous, up
@subsection Getting and operating on images
@cindex Getting and operating on images

Several functions are provided by the GIMP library for manipulating
images. These functions all lie at the lowest level of operation. They
include, getting images and information about images, creating images
and displaying images.

Many of the following functions operate on the @code{Image} data
type. This is an opaque data type that contains such information as the
images size and active area. This information is intended to be accessed
through the appropriate accessor functions.

@deftypefun void gimp_free_image (Image @var{image})
This function tells the GIMP library to free its link to
@var{image}. The image is not actually destroyed since the GIMP will
retain its link.
@end deftypefun

@deftypefun void gimp_destroy_image (Image @var{image})
This function tells the GIMP library to free its link to @var{image} and
to tell the GIMP to also free its link. The result is that @var{image}
will be destroyed.
@end deftypefun

@deftypefun Image gimp_new_image (char *@var{title}, long @var{width}, long @var{height}, ImageType @var{type})
This function creates a new image with the given title, width, height
and type. The new image is returned in the opaque type @code{Image}. Use
the @code{gimp_image_*} functions to get information out of the image.

@var{type} should be specified as one of @code{RGB_IMAGE},
@code{GRAY_IMAGE} or @code{INDEXED_IMAGE} to create a new RGB image,
grayscale image or indexed color image respectively.
@end deftypefun

@deftypefun Image gimp_get_input_image (long @var{id})
@code{gimp_get_input_image} gets an input image with the given ID. Every
image in the main GIMP application has a unique ID value assigned to it
at creation. Values are assigned starting from 1. This function can be
used to get any valid image in the GIMP. However, this action is not
recommended since it is impossible to tell which ID's are valid.

The main usage is to get the default image which is specified by an ID
value of 0. (This is used since no actual image in the GIMP will have an
ID of 0).

Input images are defined to be read-only. That is, the programmer should
not modify the image. (This is enforced by the library by only read-only
to the shared memory segment).
@end deftypefun

@deftypefun Image gimp_get_output_image (long @var{id})
@code{gimp_get_output_image} is analogous to @code{gimp_get_input_image}
except that it gets an output image. An output image is defined to be
read-write. Meaning that data can be read to and written from. It may
seem strange, but getting both the input image and output image for the
same ID actually returns two different images and two different data
segments. Writing to the input image does not affect the output image
and vice-versa.
@end deftypefun

@deftypefun void gimp_display_image (Image @var{image})
This function displays an image. A new view is created in the
process. Therefore, it is not necessary to display an image that is
already displayed. (This function is used mainly by file plug-ins which
must tell the GIMP to display a newly created image).
@end deftypefun

@deftypefun void gimp_update_image (Image @var{image})
This function tells the GIMP to redraw an image. The image is redrawn in
every view.
@end deftypefun

@deftypefun char* gimp_image_name (Image @var{image})
This function returns an images name.
@end deftypefun

@deftypefun long gimp_image_width (Image @var{image})
This function returns an images width.
@end deftypefun

@deftypefun long gimp_image_height (Image @var{image})
This function returns an images height.
@end deftypefun

@deftypefun long gimp_image_channels (Image @var{image})
This function returns an images channels. RGB images have 3
channels. Grayscale and indexed color images have 1 channel.
@end deftypefun

@deftypefun ImageType gimp_image_type (Image @var{image})
This function returns the type of an image. The type is one of
@code{RGB_IMAGE}, @code{GRAY_IMAGE}, @code{INDEXED_IMAGE}, or
@code{UNKNOWN_IMAGE}. If @code{UNKNOWN_IMAGE} is returned an error has
occurred within the library. (ie. This should never happen).
@end deftypefun

@deftypefun void gimp_image_area (Image @var{image}, int *@var{x1}, int *@var{y1}, int *@var{x2}, int *@var{y2})
This function returns the active area of operation for a plug-in. The
area is returned as a rectangle defined by the upper-left corner
(@var{x1}, @var{y1}) and the lower-right corner (@var{x2},
@var{y2}). This is useful for effects filters which have their results
masked by the current selection in an image. By only operating within
the active area a slow running plug-in can dramatically increase its
speed. (Even a fast running plug-in can dramatically increase its speed
since the user may have only selected a small portion of the image).

It should be noted that a plug-in should run the same whether or not it
uses the information about the active image area. That is, operating on
the entire image and operating on the active area should have the same
end effect from the users point of view.
@end deftypefun

@deftypefun void* gimp_image_data (Image @var{image})
This function returns the actual pixel data for the image. For RGB
images the data is laid out as a series of RGB triplets where each
triplet is 3 bytes. For grayscale and indexed color images, each pixel
value is a single byte corresponding to a grayscale value or pixel index
respectively.
@end deftypefun

@deftypefun void* gimp_image_cmap (Image @var{image})
This function returns the colormap associated with an image. It is only
valid for indexed color images. The colormap is a series of RGB triplets
where each triplet is 3 bytes. The size of the colormap is always 768
bytes, however, only the first @code{gimp_image_colors (@var{image})}
triplets are valid.
@end deftypefun

@deftypefun long gimp_image_colors (Image @var{image})
This function returns the number of colors in an indexed color image. It
is only valid for indexed color images.
@end deftypefun

@deftypefun void gimp_set_image_colors (Image @var{image}, void *@var{cmap}, long @var{ncolors})
This function sets an images colormap and the number of colors
associated with it. It is only valid for indexed color
images. 
@end deftypefun

@deftypefun void gimp_foreground_color (unsigned char *@var{red}, unsigned char *@var{green}, unsigned char *@var{blue})
This function returns the current foreground color in the GIMP application.
@end deftypefun

@deftypefun void gimp_background_color (unsigned char *@var{red}, unsigned char *@var{green}, unsigned char *@var{blue})
This function returns the current background color in the GIMP application.
@end deftypefun

@node Dialogs, Miscellaneous, Images, Programming plug-ins
@comment node-name, next, previous, up
@subsection Creating and using dialogs
@cindex Creating and using dialogs

Many plug-ins allow the user to specify various parameters that affect
their operation. It is recommended that these paramaters be modifiable
through a dialog. There are 2 major methods of creating such a dialog. The
first is to use X11 and Motif directly. This method has the advantage that
arbitrarily complex dialogs and interfaces can be created. However, it
has the disadvantage that the plug-in must be linked with the X11 and
Motif libraries. In addition, if the GIMP is ever ported to Windows or
the Mac, your plug-in will have to be modified to deal with the new GUI
(Graphical User Interface).

The second option is to use a simple dialog interface supported by the
GIMP library and the GIMP. It allows the creation of dialogs which have
items such as text fields, scales, check buttons, radio buttons, labels
and frames. Callbacks can be specified for any active item and the GIMP
library will transparently handle receiving such callbacks from the
GIMP. It has the disadvantage in that the programmer is somewhat limited
in what can be done. However, most (if not all) plug-ins need fairly
simple interfaces that are better handled by a simple API (Applications
Programmer Interface), than by a complex one such as X11 and Motif.

It is this second option which is used by the standard plug-ins that
come with the GIMP. To use the dialog facilities a few items should be
explained. First, the dialog is actually created by the main GIMP
application. Second, the ID values returned by many of the dialog
creation routines are simply integer values used by the library to
communicate with the GIMP. An ID value is guaranteed to be unique for
any item within a particular dialog and all dialog ID values are
guaranteed to be unique. However, items in different dialogs may have
the same ID value.

@deftp {Data Type} GimpItemCallbackProc
This data type is a function pointer that is used by the GIMP library to
handle callbacks. It accepts three arguments. The ID of the item which
has initiated the callback, a pointer to user specified client data and
a pointer to callback specific call data.
@end deftp

@deftypefun int gimp_new_dialog (char *@var{title})
@end deftypefun

@deftypefun int gimp_show_dialog (int @var{dialog_ID})
@end deftypefun

@deftypefun void gimp_close_dialog (int @var{dialog_ID}, int @var{return_val})
@end deftypefun

@deftypefun int gimp_ok_item_id (int @var{dialog_ID})
@end deftypefun

@deftypefun int gimp_cancel_item_id (int @var{dialog_ID})
@end deftypefun

@deftypefun int gimp_new_row_group (int @var{dialog_ID}, int @var{parent_ID}, int @var{group_type}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_column_group (int @var{dialog_ID}, int @var{parent_ID}, int @var{group_type}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_push_button (int @var{dialog_ID}, int @var{parent_ID}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_check_button (int @var{dialog_ID}, int @var{parent_ID}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_radio_button (int @var{dialog_ID}, int @var{parent_ID}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_image_menu (int @var{dialog_ID}, int @var{parent_ID}, char @var{constraint}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_scale (int @var{dialog_ID}, int @var{parent_ID}, long @var{min}, long @var{max}, long @var{start_value}, long @var{precision})
@end deftypefun

@deftypefun int gimp_new_frame (int @var{dialog_ID}, int @var{parent_ID}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_label (int @var{dialog_ID}, int @var{parent_ID}, char *@var{title})
@end deftypefun

@deftypefun int gimp_new_text (int @var{dialog_ID}, int @var{parent_ID}, char *@var{title})
@end deftypefun

@deftypefun void gimp_change_item (int @var{dialog_ID}, int @var{item_ID}, long @var{data_size}, void *@var{data})
@end deftypefun

@deftypefun void gimp_show_item (int @var{dialog_ID}, int @var{item_ID})
@end deftypefun

@deftypefun void gimp_hide_item (int @var{dialog_ID}, int @var{item_ID})
@end deftypefun

@deftypefun void gimp_delete_item (int @var{dialog_ID}, int @var{item_ID})
@end deftypefun

@deftypefun void gimp_add_callback (int @var{dialog_ID}, int @var{item_ID}, GimpItemCallbackProc @var{callback}, void *@var{callback_data})
@end deftypefun


@node Miscellaneous, Example filter, Dialogs, Programming plug-ins
@comment node-name, next, previous, up
@subsection Miscellaneous library functions
@cindex Miscellaneous library functions

@node Example filter, Example channel operation, Miscellaneous, Programming plug-ins
@comment node-name, next, previous, up
@subsection An example of a filter plug-in
@cindex An example of a filter plug-in

@node Example channel operation, Example file, Example filter, Programming plug-ins
@comment node-name, next, previous, up
@subsection An example of a file plug-in
@cindex An example of a file plug-in

@node Example file, , Example channel operation, Programming plug-ins
@comment node-name, next, previous, up
@subsection An example of a channel operation
@cindex An example of a channel operation

@bye
